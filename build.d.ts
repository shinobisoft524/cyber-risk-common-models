
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Assessment
 * 
 */
export type Assessment = $Result.DefaultSelection<Prisma.$AssessmentPayload>
/**
 * Model AssessmentQuestion
 * 
 */
export type AssessmentQuestion = $Result.DefaultSelection<Prisma.$AssessmentQuestionPayload>
/**
 * Model AssessmentTeam
 * 
 */
export type AssessmentTeam = $Result.DefaultSelection<Prisma.$AssessmentTeamPayload>
/**
 * Model Organisation
 * 
 */
export type Organisation = $Result.DefaultSelection<Prisma.$OrganisationPayload>
/**
 * Model OrganisationRole
 * 
 */
export type OrganisationRole = $Result.DefaultSelection<Prisma.$OrganisationRolePayload>
/**
 * Model OrganisationStructure
 * 
 */
export type OrganisationStructure = $Result.DefaultSelection<Prisma.$OrganisationStructurePayload>
/**
 * Model OrganisationTemplate
 * 
 */
export type OrganisationTemplate = $Result.DefaultSelection<Prisma.$OrganisationTemplatePayload>
/**
 * Model QuestionAnswer
 * 
 */
export type QuestionAnswer = $Result.DefaultSelection<Prisma.$QuestionAnswerPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Template
 * 
 */
export type Template = $Result.DefaultSelection<Prisma.$TemplatePayload>
/**
 * Model TemplateStage
 * 
 */
export type TemplateStage = $Result.DefaultSelection<Prisma.$TemplateStagePayload>
/**
 * Model TemplateQuestion
 * 
 */
export type TemplateQuestion = $Result.DefaultSelection<Prisma.$TemplateQuestionPayload>
/**
 * Model TemplateQuestionAnswer
 * 
 */
export type TemplateQuestionAnswer = $Result.DefaultSelection<Prisma.$TemplateQuestionAnswerPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Assessments
 * const assessments = await prisma.assessment.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Assessments
   * const assessments = await prisma.assessment.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.assessment`: Exposes CRUD operations for the **Assessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assessments
    * const assessments = await prisma.assessment.findMany()
    * ```
    */
  get assessment(): Prisma.AssessmentDelegate<ExtArgs>;

  /**
   * `prisma.assessmentQuestion`: Exposes CRUD operations for the **AssessmentQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssessmentQuestions
    * const assessmentQuestions = await prisma.assessmentQuestion.findMany()
    * ```
    */
  get assessmentQuestion(): Prisma.AssessmentQuestionDelegate<ExtArgs>;

  /**
   * `prisma.assessmentTeam`: Exposes CRUD operations for the **AssessmentTeam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssessmentTeams
    * const assessmentTeams = await prisma.assessmentTeam.findMany()
    * ```
    */
  get assessmentTeam(): Prisma.AssessmentTeamDelegate<ExtArgs>;

  /**
   * `prisma.organisation`: Exposes CRUD operations for the **Organisation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organisations
    * const organisations = await prisma.organisation.findMany()
    * ```
    */
  get organisation(): Prisma.OrganisationDelegate<ExtArgs>;

  /**
   * `prisma.organisationRole`: Exposes CRUD operations for the **OrganisationRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganisationRoles
    * const organisationRoles = await prisma.organisationRole.findMany()
    * ```
    */
  get organisationRole(): Prisma.OrganisationRoleDelegate<ExtArgs>;

  /**
   * `prisma.organisationStructure`: Exposes CRUD operations for the **OrganisationStructure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganisationStructures
    * const organisationStructures = await prisma.organisationStructure.findMany()
    * ```
    */
  get organisationStructure(): Prisma.OrganisationStructureDelegate<ExtArgs>;

  /**
   * `prisma.organisationTemplate`: Exposes CRUD operations for the **OrganisationTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganisationTemplates
    * const organisationTemplates = await prisma.organisationTemplate.findMany()
    * ```
    */
  get organisationTemplate(): Prisma.OrganisationTemplateDelegate<ExtArgs>;

  /**
   * `prisma.questionAnswer`: Exposes CRUD operations for the **QuestionAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionAnswers
    * const questionAnswers = await prisma.questionAnswer.findMany()
    * ```
    */
  get questionAnswer(): Prisma.QuestionAnswerDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs>;

  /**
   * `prisma.template`: Exposes CRUD operations for the **Template** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Templates
    * const templates = await prisma.template.findMany()
    * ```
    */
  get template(): Prisma.TemplateDelegate<ExtArgs>;

  /**
   * `prisma.templateStage`: Exposes CRUD operations for the **TemplateStage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateStages
    * const templateStages = await prisma.templateStage.findMany()
    * ```
    */
  get templateStage(): Prisma.TemplateStageDelegate<ExtArgs>;

  /**
   * `prisma.templateQuestion`: Exposes CRUD operations for the **TemplateQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateQuestions
    * const templateQuestions = await prisma.templateQuestion.findMany()
    * ```
    */
  get templateQuestion(): Prisma.TemplateQuestionDelegate<ExtArgs>;

  /**
   * `prisma.templateQuestionAnswer`: Exposes CRUD operations for the **TemplateQuestionAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateQuestionAnswers
    * const templateQuestionAnswers = await prisma.templateQuestionAnswer.findMany()
    * ```
    */
  get templateQuestionAnswer(): Prisma.TemplateQuestionAnswerDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.19.1
   * Query Engine version: 69d742ee20b815d88e17e54db4a2a7a3b30324e3
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Assessment: 'Assessment',
    AssessmentQuestion: 'AssessmentQuestion',
    AssessmentTeam: 'AssessmentTeam',
    Organisation: 'Organisation',
    OrganisationRole: 'OrganisationRole',
    OrganisationStructure: 'OrganisationStructure',
    OrganisationTemplate: 'OrganisationTemplate',
    QuestionAnswer: 'QuestionAnswer',
    Role: 'Role',
    Team: 'Team',
    Template: 'Template',
    TemplateStage: 'TemplateStage',
    TemplateQuestion: 'TemplateQuestion',
    TemplateQuestionAnswer: 'TemplateQuestionAnswer',
    User: 'User',
    UserRole: 'UserRole'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "assessment" | "assessmentQuestion" | "assessmentTeam" | "organisation" | "organisationRole" | "organisationStructure" | "organisationTemplate" | "questionAnswer" | "role" | "team" | "template" | "templateStage" | "templateQuestion" | "templateQuestionAnswer" | "user" | "userRole"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Assessment: {
        payload: Prisma.$AssessmentPayload<ExtArgs>
        fields: Prisma.AssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          findFirst: {
            args: Prisma.AssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          findMany: {
            args: Prisma.AssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>[]
          }
          create: {
            args: Prisma.AssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          createMany: {
            args: Prisma.AssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          update: {
            args: Prisma.AssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          deleteMany: {
            args: Prisma.AssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentPayload>
          }
          aggregate: {
            args: Prisma.AssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssessment>
          }
          groupBy: {
            args: Prisma.AssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssessmentCountAggregateOutputType> | number
          }
        }
      }
      AssessmentQuestion: {
        payload: Prisma.$AssessmentQuestionPayload<ExtArgs>
        fields: Prisma.AssessmentQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          findFirst: {
            args: Prisma.AssessmentQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          findMany: {
            args: Prisma.AssessmentQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>[]
          }
          create: {
            args: Prisma.AssessmentQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          createMany: {
            args: Prisma.AssessmentQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AssessmentQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          update: {
            args: Prisma.AssessmentQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          deleteMany: {
            args: Prisma.AssessmentQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssessmentQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentQuestionPayload>
          }
          aggregate: {
            args: Prisma.AssessmentQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssessmentQuestion>
          }
          groupBy: {
            args: Prisma.AssessmentQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssessmentQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssessmentQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<AssessmentQuestionCountAggregateOutputType> | number
          }
        }
      }
      AssessmentTeam: {
        payload: Prisma.$AssessmentTeamPayload<ExtArgs>
        fields: Prisma.AssessmentTeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentTeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentTeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTeamPayload>
          }
          findFirst: {
            args: Prisma.AssessmentTeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentTeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTeamPayload>
          }
          findMany: {
            args: Prisma.AssessmentTeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTeamPayload>[]
          }
          create: {
            args: Prisma.AssessmentTeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTeamPayload>
          }
          createMany: {
            args: Prisma.AssessmentTeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AssessmentTeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTeamPayload>
          }
          update: {
            args: Prisma.AssessmentTeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTeamPayload>
          }
          deleteMany: {
            args: Prisma.AssessmentTeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentTeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssessmentTeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTeamPayload>
          }
          aggregate: {
            args: Prisma.AssessmentTeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssessmentTeam>
          }
          groupBy: {
            args: Prisma.AssessmentTeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssessmentTeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssessmentTeamCountArgs<ExtArgs>
            result: $Utils.Optional<AssessmentTeamCountAggregateOutputType> | number
          }
        }
      }
      Organisation: {
        payload: Prisma.$OrganisationPayload<ExtArgs>
        fields: Prisma.OrganisationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganisationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganisationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          findFirst: {
            args: Prisma.OrganisationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganisationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          findMany: {
            args: Prisma.OrganisationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>[]
          }
          create: {
            args: Prisma.OrganisationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          createMany: {
            args: Prisma.OrganisationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrganisationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          update: {
            args: Prisma.OrganisationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          deleteMany: {
            args: Prisma.OrganisationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganisationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganisationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          aggregate: {
            args: Prisma.OrganisationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganisation>
          }
          groupBy: {
            args: Prisma.OrganisationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganisationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganisationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganisationCountAggregateOutputType> | number
          }
        }
      }
      OrganisationRole: {
        payload: Prisma.$OrganisationRolePayload<ExtArgs>
        fields: Prisma.OrganisationRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganisationRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganisationRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationRolePayload>
          }
          findFirst: {
            args: Prisma.OrganisationRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganisationRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationRolePayload>
          }
          findMany: {
            args: Prisma.OrganisationRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationRolePayload>[]
          }
          create: {
            args: Prisma.OrganisationRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationRolePayload>
          }
          createMany: {
            args: Prisma.OrganisationRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrganisationRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationRolePayload>
          }
          update: {
            args: Prisma.OrganisationRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationRolePayload>
          }
          deleteMany: {
            args: Prisma.OrganisationRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganisationRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganisationRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationRolePayload>
          }
          aggregate: {
            args: Prisma.OrganisationRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganisationRole>
          }
          groupBy: {
            args: Prisma.OrganisationRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganisationRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganisationRoleCountArgs<ExtArgs>
            result: $Utils.Optional<OrganisationRoleCountAggregateOutputType> | number
          }
        }
      }
      OrganisationStructure: {
        payload: Prisma.$OrganisationStructurePayload<ExtArgs>
        fields: Prisma.OrganisationStructureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganisationStructureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationStructurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganisationStructureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationStructurePayload>
          }
          findFirst: {
            args: Prisma.OrganisationStructureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationStructurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganisationStructureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationStructurePayload>
          }
          findMany: {
            args: Prisma.OrganisationStructureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationStructurePayload>[]
          }
          create: {
            args: Prisma.OrganisationStructureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationStructurePayload>
          }
          createMany: {
            args: Prisma.OrganisationStructureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrganisationStructureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationStructurePayload>
          }
          update: {
            args: Prisma.OrganisationStructureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationStructurePayload>
          }
          deleteMany: {
            args: Prisma.OrganisationStructureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganisationStructureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganisationStructureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationStructurePayload>
          }
          aggregate: {
            args: Prisma.OrganisationStructureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganisationStructure>
          }
          groupBy: {
            args: Prisma.OrganisationStructureGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganisationStructureGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganisationStructureCountArgs<ExtArgs>
            result: $Utils.Optional<OrganisationStructureCountAggregateOutputType> | number
          }
        }
      }
      OrganisationTemplate: {
        payload: Prisma.$OrganisationTemplatePayload<ExtArgs>
        fields: Prisma.OrganisationTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganisationTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganisationTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationTemplatePayload>
          }
          findFirst: {
            args: Prisma.OrganisationTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganisationTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationTemplatePayload>
          }
          findMany: {
            args: Prisma.OrganisationTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationTemplatePayload>[]
          }
          create: {
            args: Prisma.OrganisationTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationTemplatePayload>
          }
          createMany: {
            args: Prisma.OrganisationTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrganisationTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationTemplatePayload>
          }
          update: {
            args: Prisma.OrganisationTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationTemplatePayload>
          }
          deleteMany: {
            args: Prisma.OrganisationTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganisationTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganisationTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationTemplatePayload>
          }
          aggregate: {
            args: Prisma.OrganisationTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganisationTemplate>
          }
          groupBy: {
            args: Prisma.OrganisationTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganisationTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganisationTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<OrganisationTemplateCountAggregateOutputType> | number
          }
        }
      }
      QuestionAnswer: {
        payload: Prisma.$QuestionAnswerPayload<ExtArgs>
        fields: Prisma.QuestionAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          findFirst: {
            args: Prisma.QuestionAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          findMany: {
            args: Prisma.QuestionAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>[]
          }
          create: {
            args: Prisma.QuestionAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          createMany: {
            args: Prisma.QuestionAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QuestionAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          update: {
            args: Prisma.QuestionAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          deleteMany: {
            args: Prisma.QuestionAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnswerPayload>
          }
          aggregate: {
            args: Prisma.QuestionAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionAnswer>
          }
          groupBy: {
            args: Prisma.QuestionAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionAnswerCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Template: {
        payload: Prisma.$TemplatePayload<ExtArgs>
        fields: Prisma.TemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findFirst: {
            args: Prisma.TemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findMany: {
            args: Prisma.TemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          create: {
            args: Prisma.TemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          createMany: {
            args: Prisma.TemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          update: {
            args: Prisma.TemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          deleteMany: {
            args: Prisma.TemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          aggregate: {
            args: Prisma.TemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplate>
          }
          groupBy: {
            args: Prisma.TemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateCountAggregateOutputType> | number
          }
        }
      }
      TemplateStage: {
        payload: Prisma.$TemplateStagePayload<ExtArgs>
        fields: Prisma.TemplateStageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateStageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateStagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateStageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateStagePayload>
          }
          findFirst: {
            args: Prisma.TemplateStageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateStagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateStageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateStagePayload>
          }
          findMany: {
            args: Prisma.TemplateStageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateStagePayload>[]
          }
          create: {
            args: Prisma.TemplateStageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateStagePayload>
          }
          createMany: {
            args: Prisma.TemplateStageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TemplateStageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateStagePayload>
          }
          update: {
            args: Prisma.TemplateStageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateStagePayload>
          }
          deleteMany: {
            args: Prisma.TemplateStageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateStageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TemplateStageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateStagePayload>
          }
          aggregate: {
            args: Prisma.TemplateStageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateStage>
          }
          groupBy: {
            args: Prisma.TemplateStageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateStageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateStageCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateStageCountAggregateOutputType> | number
          }
        }
      }
      TemplateQuestion: {
        payload: Prisma.$TemplateQuestionPayload<ExtArgs>
        fields: Prisma.TemplateQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionPayload>
          }
          findFirst: {
            args: Prisma.TemplateQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionPayload>
          }
          findMany: {
            args: Prisma.TemplateQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionPayload>[]
          }
          create: {
            args: Prisma.TemplateQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionPayload>
          }
          createMany: {
            args: Prisma.TemplateQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TemplateQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionPayload>
          }
          update: {
            args: Prisma.TemplateQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionPayload>
          }
          deleteMany: {
            args: Prisma.TemplateQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TemplateQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionPayload>
          }
          aggregate: {
            args: Prisma.TemplateQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateQuestion>
          }
          groupBy: {
            args: Prisma.TemplateQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateQuestionCountAggregateOutputType> | number
          }
        }
      }
      TemplateQuestionAnswer: {
        payload: Prisma.$TemplateQuestionAnswerPayload<ExtArgs>
        fields: Prisma.TemplateQuestionAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateQuestionAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateQuestionAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionAnswerPayload>
          }
          findFirst: {
            args: Prisma.TemplateQuestionAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateQuestionAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionAnswerPayload>
          }
          findMany: {
            args: Prisma.TemplateQuestionAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionAnswerPayload>[]
          }
          create: {
            args: Prisma.TemplateQuestionAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionAnswerPayload>
          }
          createMany: {
            args: Prisma.TemplateQuestionAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TemplateQuestionAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionAnswerPayload>
          }
          update: {
            args: Prisma.TemplateQuestionAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionAnswerPayload>
          }
          deleteMany: {
            args: Prisma.TemplateQuestionAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateQuestionAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TemplateQuestionAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateQuestionAnswerPayload>
          }
          aggregate: {
            args: Prisma.TemplateQuestionAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateQuestionAnswer>
          }
          groupBy: {
            args: Prisma.TemplateQuestionAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateQuestionAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateQuestionAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateQuestionAnswerCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AssessmentCountOutputType
   */

  export type AssessmentCountOutputType = {
    AssessmentQuestion: number
    AssessmentTeam: number
    QuestionAnswer: number
  }

  export type AssessmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AssessmentQuestion?: boolean | AssessmentCountOutputTypeCountAssessmentQuestionArgs
    AssessmentTeam?: boolean | AssessmentCountOutputTypeCountAssessmentTeamArgs
    QuestionAnswer?: boolean | AssessmentCountOutputTypeCountQuestionAnswerArgs
  }

  // Custom InputTypes
  /**
   * AssessmentCountOutputType without action
   */
  export type AssessmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentCountOutputType
     */
    select?: AssessmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssessmentCountOutputType without action
   */
  export type AssessmentCountOutputTypeCountAssessmentQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentQuestionWhereInput
  }

  /**
   * AssessmentCountOutputType without action
   */
  export type AssessmentCountOutputTypeCountAssessmentTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentTeamWhereInput
  }

  /**
   * AssessmentCountOutputType without action
   */
  export type AssessmentCountOutputTypeCountQuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAnswerWhereInput
  }


  /**
   * Count Type AssessmentQuestionCountOutputType
   */

  export type AssessmentQuestionCountOutputType = {
    QuestionAnswer: number
  }

  export type AssessmentQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QuestionAnswer?: boolean | AssessmentQuestionCountOutputTypeCountQuestionAnswerArgs
  }

  // Custom InputTypes
  /**
   * AssessmentQuestionCountOutputType without action
   */
  export type AssessmentQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestionCountOutputType
     */
    select?: AssessmentQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssessmentQuestionCountOutputType without action
   */
  export type AssessmentQuestionCountOutputTypeCountQuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAnswerWhereInput
  }


  /**
   * Count Type AssessmentTeamCountOutputType
   */

  export type AssessmentTeamCountOutputType = {
    QuestionAnswer: number
  }

  export type AssessmentTeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QuestionAnswer?: boolean | AssessmentTeamCountOutputTypeCountQuestionAnswerArgs
  }

  // Custom InputTypes
  /**
   * AssessmentTeamCountOutputType without action
   */
  export type AssessmentTeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTeamCountOutputType
     */
    select?: AssessmentTeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssessmentTeamCountOutputType without action
   */
  export type AssessmentTeamCountOutputTypeCountQuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAnswerWhereInput
  }


  /**
   * Count Type OrganisationCountOutputType
   */

  export type OrganisationCountOutputType = {
    Assessment: number
    Team: number
    OrganisationTemplate: number
    QuestionAnswer: number
    AssessmentTeam: number
  }

  export type OrganisationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Assessment?: boolean | OrganisationCountOutputTypeCountAssessmentArgs
    Team?: boolean | OrganisationCountOutputTypeCountTeamArgs
    OrganisationTemplate?: boolean | OrganisationCountOutputTypeCountOrganisationTemplateArgs
    QuestionAnswer?: boolean | OrganisationCountOutputTypeCountQuestionAnswerArgs
    AssessmentTeam?: boolean | OrganisationCountOutputTypeCountAssessmentTeamArgs
  }

  // Custom InputTypes
  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationCountOutputType
     */
    select?: OrganisationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentWhereInput
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountOrganisationTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationTemplateWhereInput
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountQuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAnswerWhereInput
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountAssessmentTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentTeamWhereInput
  }


  /**
   * Count Type OrganisationStructureCountOutputType
   */

  export type OrganisationStructureCountOutputType = {
    OrganisationRole: number
    QuestionAnswer: number
  }

  export type OrganisationStructureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrganisationRole?: boolean | OrganisationStructureCountOutputTypeCountOrganisationRoleArgs
    QuestionAnswer?: boolean | OrganisationStructureCountOutputTypeCountQuestionAnswerArgs
  }

  // Custom InputTypes
  /**
   * OrganisationStructureCountOutputType without action
   */
  export type OrganisationStructureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationStructureCountOutputType
     */
    select?: OrganisationStructureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganisationStructureCountOutputType without action
   */
  export type OrganisationStructureCountOutputTypeCountOrganisationRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationRoleWhereInput
  }

  /**
   * OrganisationStructureCountOutputType without action
   */
  export type OrganisationStructureCountOutputTypeCountQuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAnswerWhereInput
  }


  /**
   * Count Type OrganisationTemplateCountOutputType
   */

  export type OrganisationTemplateCountOutputType = {
    Assessment: number
  }

  export type OrganisationTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Assessment?: boolean | OrganisationTemplateCountOutputTypeCountAssessmentArgs
  }

  // Custom InputTypes
  /**
   * OrganisationTemplateCountOutputType without action
   */
  export type OrganisationTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationTemplateCountOutputType
     */
    select?: OrganisationTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganisationTemplateCountOutputType without action
   */
  export type OrganisationTemplateCountOutputTypeCountAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    UserRole: number
    OrganisationRole: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserRole?: boolean | RoleCountOutputTypeCountUserRoleArgs
    OrganisationRole?: boolean | RoleCountOutputTypeCountOrganisationRoleArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountOrganisationRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationRoleWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    OrganisationStructure: number
    AssessmentTeam: number
    QuestionAnswer: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrganisationStructure?: boolean | TeamCountOutputTypeCountOrganisationStructureArgs
    AssessmentTeam?: boolean | TeamCountOutputTypeCountAssessmentTeamArgs
    QuestionAnswer?: boolean | TeamCountOutputTypeCountQuestionAnswerArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountOrganisationStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationStructureWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountAssessmentTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentTeamWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountQuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAnswerWhereInput
  }


  /**
   * Count Type TemplateCountOutputType
   */

  export type TemplateCountOutputType = {
    TemplateStage: number
    OrganisationTemplate: number
  }

  export type TemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TemplateStage?: boolean | TemplateCountOutputTypeCountTemplateStageArgs
    OrganisationTemplate?: boolean | TemplateCountOutputTypeCountOrganisationTemplateArgs
  }

  // Custom InputTypes
  /**
   * TemplateCountOutputType without action
   */
  export type TemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateCountOutputType
     */
    select?: TemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TemplateCountOutputType without action
   */
  export type TemplateCountOutputTypeCountTemplateStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateStageWhereInput
  }

  /**
   * TemplateCountOutputType without action
   */
  export type TemplateCountOutputTypeCountOrganisationTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationTemplateWhereInput
  }


  /**
   * Count Type TemplateStageCountOutputType
   */

  export type TemplateStageCountOutputType = {
    TemplateQuestion: number
  }

  export type TemplateStageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TemplateQuestion?: boolean | TemplateStageCountOutputTypeCountTemplateQuestionArgs
  }

  // Custom InputTypes
  /**
   * TemplateStageCountOutputType without action
   */
  export type TemplateStageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateStageCountOutputType
     */
    select?: TemplateStageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TemplateStageCountOutputType without action
   */
  export type TemplateStageCountOutputTypeCountTemplateQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateQuestionWhereInput
  }


  /**
   * Count Type TemplateQuestionCountOutputType
   */

  export type TemplateQuestionCountOutputType = {
    TemplateQuestionAnswer: number
  }

  export type TemplateQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TemplateQuestionAnswer?: boolean | TemplateQuestionCountOutputTypeCountTemplateQuestionAnswerArgs
  }

  // Custom InputTypes
  /**
   * TemplateQuestionCountOutputType without action
   */
  export type TemplateQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestionCountOutputType
     */
    select?: TemplateQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TemplateQuestionCountOutputType without action
   */
  export type TemplateQuestionCountOutputTypeCountTemplateQuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateQuestionAnswerWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    UserRole: number
    OrganisationStructure: number
    QuestionAnswer: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserRole?: boolean | UserCountOutputTypeCountUserRoleArgs
    OrganisationStructure?: boolean | UserCountOutputTypeCountOrganisationStructureArgs
    QuestionAnswer?: boolean | UserCountOutputTypeCountQuestionAnswerArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrganisationStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationStructureWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAnswerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Assessment
   */

  export type AggregateAssessment = {
    _count: AssessmentCountAggregateOutputType | null
    _avg: AssessmentAvgAggregateOutputType | null
    _sum: AssessmentSumAggregateOutputType | null
    _min: AssessmentMinAggregateOutputType | null
    _max: AssessmentMaxAggregateOutputType | null
  }

  export type AssessmentAvgAggregateOutputType = {
    id: number | null
    organisationId: number | null
    organisationTemplateId: number | null
  }

  export type AssessmentSumAggregateOutputType = {
    id: number | null
    organisationId: number | null
    organisationTemplateId: number | null
  }

  export type AssessmentMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    logo: string | null
    organisationId: number | null
    password: string | null
    rememberToken: string | null
    isActive: boolean | null
    secretToken: string | null
    tfaToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    organisationTemplateId: number | null
  }

  export type AssessmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    logo: string | null
    organisationId: number | null
    password: string | null
    rememberToken: string | null
    isActive: boolean | null
    secretToken: string | null
    tfaToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    organisationTemplateId: number | null
  }

  export type AssessmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    logo: number
    organisationId: number
    password: number
    rememberToken: number
    isActive: number
    secretToken: number
    tfaToken: number
    createdAt: number
    updatedAt: number
    organisationTemplateId: number
    _all: number
  }


  export type AssessmentAvgAggregateInputType = {
    id?: true
    organisationId?: true
    organisationTemplateId?: true
  }

  export type AssessmentSumAggregateInputType = {
    id?: true
    organisationId?: true
    organisationTemplateId?: true
  }

  export type AssessmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logo?: true
    organisationId?: true
    password?: true
    rememberToken?: true
    isActive?: true
    secretToken?: true
    tfaToken?: true
    createdAt?: true
    updatedAt?: true
    organisationTemplateId?: true
  }

  export type AssessmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logo?: true
    organisationId?: true
    password?: true
    rememberToken?: true
    isActive?: true
    secretToken?: true
    tfaToken?: true
    createdAt?: true
    updatedAt?: true
    organisationTemplateId?: true
  }

  export type AssessmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logo?: true
    organisationId?: true
    password?: true
    rememberToken?: true
    isActive?: true
    secretToken?: true
    tfaToken?: true
    createdAt?: true
    updatedAt?: true
    organisationTemplateId?: true
    _all?: true
  }

  export type AssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assessment to aggregate.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assessments
    **/
    _count?: true | AssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentMaxAggregateInputType
  }

  export type GetAssessmentAggregateType<T extends AssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessment[P]>
      : GetScalarType<T[P], AggregateAssessment[P]>
  }




  export type AssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentWhereInput
    orderBy?: AssessmentOrderByWithAggregationInput | AssessmentOrderByWithAggregationInput[]
    by: AssessmentScalarFieldEnum[] | AssessmentScalarFieldEnum
    having?: AssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentCountAggregateInputType | true
    _avg?: AssessmentAvgAggregateInputType
    _sum?: AssessmentSumAggregateInputType
    _min?: AssessmentMinAggregateInputType
    _max?: AssessmentMaxAggregateInputType
  }

  export type AssessmentGroupByOutputType = {
    id: number
    name: string
    description: string | null
    logo: string | null
    organisationId: number
    password: string | null
    rememberToken: string | null
    isActive: boolean
    secretToken: string | null
    tfaToken: string | null
    createdAt: Date
    updatedAt: Date
    organisationTemplateId: number | null
    _count: AssessmentCountAggregateOutputType | null
    _avg: AssessmentAvgAggregateOutputType | null
    _sum: AssessmentSumAggregateOutputType | null
    _min: AssessmentMinAggregateOutputType | null
    _max: AssessmentMaxAggregateOutputType | null
  }

  type GetAssessmentGroupByPayload<T extends AssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    logo?: boolean
    organisationId?: boolean
    password?: boolean
    rememberToken?: boolean
    isActive?: boolean
    secretToken?: boolean
    tfaToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organisationTemplateId?: boolean
    Organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    AssessmentQuestion?: boolean | Assessment$AssessmentQuestionArgs<ExtArgs>
    OrganisationTemplate?: boolean | Assessment$OrganisationTemplateArgs<ExtArgs>
    AssessmentTeam?: boolean | Assessment$AssessmentTeamArgs<ExtArgs>
    QuestionAnswer?: boolean | Assessment$QuestionAnswerArgs<ExtArgs>
    _count?: boolean | AssessmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessment"]>


  export type AssessmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    logo?: boolean
    organisationId?: boolean
    password?: boolean
    rememberToken?: boolean
    isActive?: boolean
    secretToken?: boolean
    tfaToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organisationTemplateId?: boolean
  }

  export type AssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    AssessmentQuestion?: boolean | Assessment$AssessmentQuestionArgs<ExtArgs>
    OrganisationTemplate?: boolean | Assessment$OrganisationTemplateArgs<ExtArgs>
    AssessmentTeam?: boolean | Assessment$AssessmentTeamArgs<ExtArgs>
    QuestionAnswer?: boolean | Assessment$QuestionAnswerArgs<ExtArgs>
    _count?: boolean | AssessmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assessment"
    objects: {
      Organisation: Prisma.$OrganisationPayload<ExtArgs>
      AssessmentQuestion: Prisma.$AssessmentQuestionPayload<ExtArgs>[]
      OrganisationTemplate: Prisma.$OrganisationTemplatePayload<ExtArgs> | null
      AssessmentTeam: Prisma.$AssessmentTeamPayload<ExtArgs>[]
      QuestionAnswer: Prisma.$QuestionAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      logo: string | null
      organisationId: number
      password: string | null
      rememberToken: string | null
      isActive: boolean
      secretToken: string | null
      tfaToken: string | null
      createdAt: Date
      updatedAt: Date
      organisationTemplateId: number | null
    }, ExtArgs["result"]["assessment"]>
    composites: {}
  }

  type AssessmentGetPayload<S extends boolean | null | undefined | AssessmentDefaultArgs> = $Result.GetResult<Prisma.$AssessmentPayload, S>

  type AssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssessmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssessmentCountAggregateInputType | true
    }

  export interface AssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assessment'], meta: { name: 'Assessment' } }
    /**
     * Find zero or one Assessment that matches the filter.
     * @param {AssessmentFindUniqueArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssessmentFindUniqueArgs>(args: SelectSubset<T, AssessmentFindUniqueArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Assessment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssessmentFindUniqueOrThrowArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Assessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentFindFirstArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssessmentFindFirstArgs>(args?: SelectSubset<T, AssessmentFindFirstArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Assessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentFindFirstOrThrowArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Assessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assessments
     * const assessments = await prisma.assessment.findMany()
     * 
     * // Get first 10 Assessments
     * const assessments = await prisma.assessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentWithIdOnly = await prisma.assessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssessmentFindManyArgs>(args?: SelectSubset<T, AssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Assessment.
     * @param {AssessmentCreateArgs} args - Arguments to create a Assessment.
     * @example
     * // Create one Assessment
     * const Assessment = await prisma.assessment.create({
     *   data: {
     *     // ... data to create a Assessment
     *   }
     * })
     * 
     */
    create<T extends AssessmentCreateArgs>(args: SelectSubset<T, AssessmentCreateArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Assessments.
     * @param {AssessmentCreateManyArgs} args - Arguments to create many Assessments.
     * @example
     * // Create many Assessments
     * const assessment = await prisma.assessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssessmentCreateManyArgs>(args?: SelectSubset<T, AssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Assessment.
     * @param {AssessmentDeleteArgs} args - Arguments to delete one Assessment.
     * @example
     * // Delete one Assessment
     * const Assessment = await prisma.assessment.delete({
     *   where: {
     *     // ... filter to delete one Assessment
     *   }
     * })
     * 
     */
    delete<T extends AssessmentDeleteArgs>(args: SelectSubset<T, AssessmentDeleteArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Assessment.
     * @param {AssessmentUpdateArgs} args - Arguments to update one Assessment.
     * @example
     * // Update one Assessment
     * const assessment = await prisma.assessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssessmentUpdateArgs>(args: SelectSubset<T, AssessmentUpdateArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Assessments.
     * @param {AssessmentDeleteManyArgs} args - Arguments to filter Assessments to delete.
     * @example
     * // Delete a few Assessments
     * const { count } = await prisma.assessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssessmentDeleteManyArgs>(args?: SelectSubset<T, AssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assessments
     * const assessment = await prisma.assessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssessmentUpdateManyArgs>(args: SelectSubset<T, AssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assessment.
     * @param {AssessmentUpsertArgs} args - Arguments to update or create a Assessment.
     * @example
     * // Update or create a Assessment
     * const assessment = await prisma.assessment.upsert({
     *   create: {
     *     // ... data to create a Assessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assessment we want to update
     *   }
     * })
     */
    upsert<T extends AssessmentUpsertArgs>(args: SelectSubset<T, AssessmentUpsertArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentCountArgs} args - Arguments to filter Assessments to count.
     * @example
     * // Count the number of Assessments
     * const count = await prisma.assessment.count({
     *   where: {
     *     // ... the filter for the Assessments we want to count
     *   }
     * })
    **/
    count<T extends AssessmentCountArgs>(
      args?: Subset<T, AssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentAggregateArgs>(args: Subset<T, AssessmentAggregateArgs>): Prisma.PrismaPromise<GetAssessmentAggregateType<T>>

    /**
     * Group by Assessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assessment model
   */
  readonly fields: AssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    AssessmentQuestion<T extends Assessment$AssessmentQuestionArgs<ExtArgs> = {}>(args?: Subset<T, Assessment$AssessmentQuestionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findMany"> | Null>
    OrganisationTemplate<T extends Assessment$OrganisationTemplateArgs<ExtArgs> = {}>(args?: Subset<T, Assessment$OrganisationTemplateArgs<ExtArgs>>): Prisma__OrganisationTemplateClient<$Result.GetResult<Prisma.$OrganisationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    AssessmentTeam<T extends Assessment$AssessmentTeamArgs<ExtArgs> = {}>(args?: Subset<T, Assessment$AssessmentTeamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentTeamPayload<ExtArgs>, T, "findMany"> | Null>
    QuestionAnswer<T extends Assessment$QuestionAnswerArgs<ExtArgs> = {}>(args?: Subset<T, Assessment$QuestionAnswerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assessment model
   */ 
  interface AssessmentFieldRefs {
    readonly id: FieldRef<"Assessment", 'Int'>
    readonly name: FieldRef<"Assessment", 'String'>
    readonly description: FieldRef<"Assessment", 'String'>
    readonly logo: FieldRef<"Assessment", 'String'>
    readonly organisationId: FieldRef<"Assessment", 'Int'>
    readonly password: FieldRef<"Assessment", 'String'>
    readonly rememberToken: FieldRef<"Assessment", 'String'>
    readonly isActive: FieldRef<"Assessment", 'Boolean'>
    readonly secretToken: FieldRef<"Assessment", 'String'>
    readonly tfaToken: FieldRef<"Assessment", 'String'>
    readonly createdAt: FieldRef<"Assessment", 'DateTime'>
    readonly updatedAt: FieldRef<"Assessment", 'DateTime'>
    readonly organisationTemplateId: FieldRef<"Assessment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Assessment findUnique
   */
  export type AssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment findUniqueOrThrow
   */
  export type AssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment findFirst
   */
  export type AssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assessments.
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assessments.
     */
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Assessment findFirstOrThrow
   */
  export type AssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessment to fetch.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assessments.
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assessments.
     */
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Assessment findMany
   */
  export type AssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter, which Assessments to fetch.
     */
    where?: AssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assessments to fetch.
     */
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assessments.
     */
    cursor?: AssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assessments.
     */
    skip?: number
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Assessment create
   */
  export type AssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assessment.
     */
    data: XOR<AssessmentCreateInput, AssessmentUncheckedCreateInput>
  }

  /**
   * Assessment createMany
   */
  export type AssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assessments.
     */
    data: AssessmentCreateManyInput | AssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assessment update
   */
  export type AssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assessment.
     */
    data: XOR<AssessmentUpdateInput, AssessmentUncheckedUpdateInput>
    /**
     * Choose, which Assessment to update.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment updateMany
   */
  export type AssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assessments.
     */
    data: XOR<AssessmentUpdateManyMutationInput, AssessmentUncheckedUpdateManyInput>
    /**
     * Filter which Assessments to update
     */
    where?: AssessmentWhereInput
  }

  /**
   * Assessment upsert
   */
  export type AssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assessment to update in case it exists.
     */
    where: AssessmentWhereUniqueInput
    /**
     * In case the Assessment found by the `where` argument doesn't exist, create a new Assessment with this data.
     */
    create: XOR<AssessmentCreateInput, AssessmentUncheckedCreateInput>
    /**
     * In case the Assessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentUpdateInput, AssessmentUncheckedUpdateInput>
  }

  /**
   * Assessment delete
   */
  export type AssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    /**
     * Filter which Assessment to delete.
     */
    where: AssessmentWhereUniqueInput
  }

  /**
   * Assessment deleteMany
   */
  export type AssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assessments to delete
     */
    where?: AssessmentWhereInput
  }

  /**
   * Assessment.AssessmentQuestion
   */
  export type Assessment$AssessmentQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    where?: AssessmentQuestionWhereInput
    orderBy?: AssessmentQuestionOrderByWithRelationInput | AssessmentQuestionOrderByWithRelationInput[]
    cursor?: AssessmentQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentQuestionScalarFieldEnum | AssessmentQuestionScalarFieldEnum[]
  }

  /**
   * Assessment.OrganisationTemplate
   */
  export type Assessment$OrganisationTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationTemplate
     */
    select?: OrganisationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationTemplateInclude<ExtArgs> | null
    where?: OrganisationTemplateWhereInput
  }

  /**
   * Assessment.AssessmentTeam
   */
  export type Assessment$AssessmentTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTeam
     */
    select?: AssessmentTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTeamInclude<ExtArgs> | null
    where?: AssessmentTeamWhereInput
    orderBy?: AssessmentTeamOrderByWithRelationInput | AssessmentTeamOrderByWithRelationInput[]
    cursor?: AssessmentTeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentTeamScalarFieldEnum | AssessmentTeamScalarFieldEnum[]
  }

  /**
   * Assessment.QuestionAnswer
   */
  export type Assessment$QuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    where?: QuestionAnswerWhereInput
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    cursor?: QuestionAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * Assessment without action
   */
  export type AssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
  }


  /**
   * Model AssessmentQuestion
   */

  export type AggregateAssessmentQuestion = {
    _count: AssessmentQuestionCountAggregateOutputType | null
    _avg: AssessmentQuestionAvgAggregateOutputType | null
    _sum: AssessmentQuestionSumAggregateOutputType | null
    _min: AssessmentQuestionMinAggregateOutputType | null
    _max: AssessmentQuestionMaxAggregateOutputType | null
  }

  export type AssessmentQuestionAvgAggregateOutputType = {
    id: number | null
    assessmentId: number | null
  }

  export type AssessmentQuestionSumAggregateOutputType = {
    id: number | null
    assessmentId: number | null
  }

  export type AssessmentQuestionMinAggregateOutputType = {
    id: number | null
    assessmentId: number | null
    assessmentStage: string | null
    questionMongoId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssessmentQuestionMaxAggregateOutputType = {
    id: number | null
    assessmentId: number | null
    assessmentStage: string | null
    questionMongoId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssessmentQuestionCountAggregateOutputType = {
    id: number
    assessmentId: number
    assessmentStage: number
    questionMongoId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssessmentQuestionAvgAggregateInputType = {
    id?: true
    assessmentId?: true
  }

  export type AssessmentQuestionSumAggregateInputType = {
    id?: true
    assessmentId?: true
  }

  export type AssessmentQuestionMinAggregateInputType = {
    id?: true
    assessmentId?: true
    assessmentStage?: true
    questionMongoId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssessmentQuestionMaxAggregateInputType = {
    id?: true
    assessmentId?: true
    assessmentStage?: true
    questionMongoId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssessmentQuestionCountAggregateInputType = {
    id?: true
    assessmentId?: true
    assessmentStage?: true
    questionMongoId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssessmentQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentQuestion to aggregate.
     */
    where?: AssessmentQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionOrderByWithRelationInput | AssessmentQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssessmentQuestions
    **/
    _count?: true | AssessmentQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssessmentQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssessmentQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentQuestionMaxAggregateInputType
  }

  export type GetAssessmentQuestionAggregateType<T extends AssessmentQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessmentQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessmentQuestion[P]>
      : GetScalarType<T[P], AggregateAssessmentQuestion[P]>
  }




  export type AssessmentQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentQuestionWhereInput
    orderBy?: AssessmentQuestionOrderByWithAggregationInput | AssessmentQuestionOrderByWithAggregationInput[]
    by: AssessmentQuestionScalarFieldEnum[] | AssessmentQuestionScalarFieldEnum
    having?: AssessmentQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentQuestionCountAggregateInputType | true
    _avg?: AssessmentQuestionAvgAggregateInputType
    _sum?: AssessmentQuestionSumAggregateInputType
    _min?: AssessmentQuestionMinAggregateInputType
    _max?: AssessmentQuestionMaxAggregateInputType
  }

  export type AssessmentQuestionGroupByOutputType = {
    id: number
    assessmentId: number
    assessmentStage: string
    questionMongoId: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AssessmentQuestionCountAggregateOutputType | null
    _avg: AssessmentQuestionAvgAggregateOutputType | null
    _sum: AssessmentQuestionSumAggregateOutputType | null
    _min: AssessmentQuestionMinAggregateOutputType | null
    _max: AssessmentQuestionMaxAggregateOutputType | null
  }

  type GetAssessmentQuestionGroupByPayload<T extends AssessmentQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentQuestionGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessmentId?: boolean
    assessmentStage?: boolean
    questionMongoId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
    QuestionAnswer?: boolean | AssessmentQuestion$QuestionAnswerArgs<ExtArgs>
    _count?: boolean | AssessmentQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentQuestion"]>


  export type AssessmentQuestionSelectScalar = {
    id?: boolean
    assessmentId?: boolean
    assessmentStage?: boolean
    questionMongoId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssessmentQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
    QuestionAnswer?: boolean | AssessmentQuestion$QuestionAnswerArgs<ExtArgs>
    _count?: boolean | AssessmentQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AssessmentQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssessmentQuestion"
    objects: {
      Assessment: Prisma.$AssessmentPayload<ExtArgs>
      QuestionAnswer: Prisma.$QuestionAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assessmentId: number
      assessmentStage: string
      questionMongoId: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assessmentQuestion"]>
    composites: {}
  }

  type AssessmentQuestionGetPayload<S extends boolean | null | undefined | AssessmentQuestionDefaultArgs> = $Result.GetResult<Prisma.$AssessmentQuestionPayload, S>

  type AssessmentQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssessmentQuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssessmentQuestionCountAggregateInputType | true
    }

  export interface AssessmentQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssessmentQuestion'], meta: { name: 'AssessmentQuestion' } }
    /**
     * Find zero or one AssessmentQuestion that matches the filter.
     * @param {AssessmentQuestionFindUniqueArgs} args - Arguments to find a AssessmentQuestion
     * @example
     * // Get one AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssessmentQuestionFindUniqueArgs>(args: SelectSubset<T, AssessmentQuestionFindUniqueArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AssessmentQuestion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssessmentQuestionFindUniqueOrThrowArgs} args - Arguments to find a AssessmentQuestion
     * @example
     * // Get one AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssessmentQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, AssessmentQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AssessmentQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionFindFirstArgs} args - Arguments to find a AssessmentQuestion
     * @example
     * // Get one AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssessmentQuestionFindFirstArgs>(args?: SelectSubset<T, AssessmentQuestionFindFirstArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AssessmentQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionFindFirstOrThrowArgs} args - Arguments to find a AssessmentQuestion
     * @example
     * // Get one AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssessmentQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, AssessmentQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AssessmentQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestion.findMany()
     * 
     * // Get first 10 AssessmentQuestions
     * const assessmentQuestions = await prisma.assessmentQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentQuestionWithIdOnly = await prisma.assessmentQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssessmentQuestionFindManyArgs>(args?: SelectSubset<T, AssessmentQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AssessmentQuestion.
     * @param {AssessmentQuestionCreateArgs} args - Arguments to create a AssessmentQuestion.
     * @example
     * // Create one AssessmentQuestion
     * const AssessmentQuestion = await prisma.assessmentQuestion.create({
     *   data: {
     *     // ... data to create a AssessmentQuestion
     *   }
     * })
     * 
     */
    create<T extends AssessmentQuestionCreateArgs>(args: SelectSubset<T, AssessmentQuestionCreateArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AssessmentQuestions.
     * @param {AssessmentQuestionCreateManyArgs} args - Arguments to create many AssessmentQuestions.
     * @example
     * // Create many AssessmentQuestions
     * const assessmentQuestion = await prisma.assessmentQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssessmentQuestionCreateManyArgs>(args?: SelectSubset<T, AssessmentQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AssessmentQuestion.
     * @param {AssessmentQuestionDeleteArgs} args - Arguments to delete one AssessmentQuestion.
     * @example
     * // Delete one AssessmentQuestion
     * const AssessmentQuestion = await prisma.assessmentQuestion.delete({
     *   where: {
     *     // ... filter to delete one AssessmentQuestion
     *   }
     * })
     * 
     */
    delete<T extends AssessmentQuestionDeleteArgs>(args: SelectSubset<T, AssessmentQuestionDeleteArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AssessmentQuestion.
     * @param {AssessmentQuestionUpdateArgs} args - Arguments to update one AssessmentQuestion.
     * @example
     * // Update one AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssessmentQuestionUpdateArgs>(args: SelectSubset<T, AssessmentQuestionUpdateArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AssessmentQuestions.
     * @param {AssessmentQuestionDeleteManyArgs} args - Arguments to filter AssessmentQuestions to delete.
     * @example
     * // Delete a few AssessmentQuestions
     * const { count } = await prisma.assessmentQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssessmentQuestionDeleteManyArgs>(args?: SelectSubset<T, AssessmentQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssessmentQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssessmentQuestions
     * const assessmentQuestion = await prisma.assessmentQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssessmentQuestionUpdateManyArgs>(args: SelectSubset<T, AssessmentQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssessmentQuestion.
     * @param {AssessmentQuestionUpsertArgs} args - Arguments to update or create a AssessmentQuestion.
     * @example
     * // Update or create a AssessmentQuestion
     * const assessmentQuestion = await prisma.assessmentQuestion.upsert({
     *   create: {
     *     // ... data to create a AssessmentQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssessmentQuestion we want to update
     *   }
     * })
     */
    upsert<T extends AssessmentQuestionUpsertArgs>(args: SelectSubset<T, AssessmentQuestionUpsertArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AssessmentQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionCountArgs} args - Arguments to filter AssessmentQuestions to count.
     * @example
     * // Count the number of AssessmentQuestions
     * const count = await prisma.assessmentQuestion.count({
     *   where: {
     *     // ... the filter for the AssessmentQuestions we want to count
     *   }
     * })
    **/
    count<T extends AssessmentQuestionCountArgs>(
      args?: Subset<T, AssessmentQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssessmentQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentQuestionAggregateArgs>(args: Subset<T, AssessmentQuestionAggregateArgs>): Prisma.PrismaPromise<GetAssessmentQuestionAggregateType<T>>

    /**
     * Group by AssessmentQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentQuestionGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssessmentQuestion model
   */
  readonly fields: AssessmentQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssessmentQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Assessment<T extends AssessmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentDefaultArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    QuestionAnswer<T extends AssessmentQuestion$QuestionAnswerArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentQuestion$QuestionAnswerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssessmentQuestion model
   */ 
  interface AssessmentQuestionFieldRefs {
    readonly id: FieldRef<"AssessmentQuestion", 'Int'>
    readonly assessmentId: FieldRef<"AssessmentQuestion", 'Int'>
    readonly assessmentStage: FieldRef<"AssessmentQuestion", 'String'>
    readonly questionMongoId: FieldRef<"AssessmentQuestion", 'String'>
    readonly isActive: FieldRef<"AssessmentQuestion", 'Boolean'>
    readonly createdAt: FieldRef<"AssessmentQuestion", 'DateTime'>
    readonly updatedAt: FieldRef<"AssessmentQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssessmentQuestion findUnique
   */
  export type AssessmentQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestion to fetch.
     */
    where: AssessmentQuestionWhereUniqueInput
  }

  /**
   * AssessmentQuestion findUniqueOrThrow
   */
  export type AssessmentQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestion to fetch.
     */
    where: AssessmentQuestionWhereUniqueInput
  }

  /**
   * AssessmentQuestion findFirst
   */
  export type AssessmentQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestion to fetch.
     */
    where?: AssessmentQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionOrderByWithRelationInput | AssessmentQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentQuestions.
     */
    cursor?: AssessmentQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentQuestions.
     */
    distinct?: AssessmentQuestionScalarFieldEnum | AssessmentQuestionScalarFieldEnum[]
  }

  /**
   * AssessmentQuestion findFirstOrThrow
   */
  export type AssessmentQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestion to fetch.
     */
    where?: AssessmentQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionOrderByWithRelationInput | AssessmentQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentQuestions.
     */
    cursor?: AssessmentQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentQuestions.
     */
    distinct?: AssessmentQuestionScalarFieldEnum | AssessmentQuestionScalarFieldEnum[]
  }

  /**
   * AssessmentQuestion findMany
   */
  export type AssessmentQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentQuestions to fetch.
     */
    where?: AssessmentQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentQuestions to fetch.
     */
    orderBy?: AssessmentQuestionOrderByWithRelationInput | AssessmentQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssessmentQuestions.
     */
    cursor?: AssessmentQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentQuestions.
     */
    skip?: number
    distinct?: AssessmentQuestionScalarFieldEnum | AssessmentQuestionScalarFieldEnum[]
  }

  /**
   * AssessmentQuestion create
   */
  export type AssessmentQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a AssessmentQuestion.
     */
    data: XOR<AssessmentQuestionCreateInput, AssessmentQuestionUncheckedCreateInput>
  }

  /**
   * AssessmentQuestion createMany
   */
  export type AssessmentQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssessmentQuestions.
     */
    data: AssessmentQuestionCreateManyInput | AssessmentQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssessmentQuestion update
   */
  export type AssessmentQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a AssessmentQuestion.
     */
    data: XOR<AssessmentQuestionUpdateInput, AssessmentQuestionUncheckedUpdateInput>
    /**
     * Choose, which AssessmentQuestion to update.
     */
    where: AssessmentQuestionWhereUniqueInput
  }

  /**
   * AssessmentQuestion updateMany
   */
  export type AssessmentQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssessmentQuestions.
     */
    data: XOR<AssessmentQuestionUpdateManyMutationInput, AssessmentQuestionUncheckedUpdateManyInput>
    /**
     * Filter which AssessmentQuestions to update
     */
    where?: AssessmentQuestionWhereInput
  }

  /**
   * AssessmentQuestion upsert
   */
  export type AssessmentQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the AssessmentQuestion to update in case it exists.
     */
    where: AssessmentQuestionWhereUniqueInput
    /**
     * In case the AssessmentQuestion found by the `where` argument doesn't exist, create a new AssessmentQuestion with this data.
     */
    create: XOR<AssessmentQuestionCreateInput, AssessmentQuestionUncheckedCreateInput>
    /**
     * In case the AssessmentQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentQuestionUpdateInput, AssessmentQuestionUncheckedUpdateInput>
  }

  /**
   * AssessmentQuestion delete
   */
  export type AssessmentQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    /**
     * Filter which AssessmentQuestion to delete.
     */
    where: AssessmentQuestionWhereUniqueInput
  }

  /**
   * AssessmentQuestion deleteMany
   */
  export type AssessmentQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentQuestions to delete
     */
    where?: AssessmentQuestionWhereInput
  }

  /**
   * AssessmentQuestion.QuestionAnswer
   */
  export type AssessmentQuestion$QuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    where?: QuestionAnswerWhereInput
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    cursor?: QuestionAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * AssessmentQuestion without action
   */
  export type AssessmentQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
  }


  /**
   * Model AssessmentTeam
   */

  export type AggregateAssessmentTeam = {
    _count: AssessmentTeamCountAggregateOutputType | null
    _avg: AssessmentTeamAvgAggregateOutputType | null
    _sum: AssessmentTeamSumAggregateOutputType | null
    _min: AssessmentTeamMinAggregateOutputType | null
    _max: AssessmentTeamMaxAggregateOutputType | null
  }

  export type AssessmentTeamAvgAggregateOutputType = {
    id: number | null
    assessmentId: number | null
    organisationId: number | null
    teamId: number | null
  }

  export type AssessmentTeamSumAggregateOutputType = {
    id: number | null
    assessmentId: number | null
    organisationId: number | null
    teamId: number | null
  }

  export type AssessmentTeamMinAggregateOutputType = {
    id: number | null
    assessmentId: number | null
    organisationId: number | null
    teamId: number | null
    password: string | null
    rememberToken: string | null
    isActive: boolean | null
    secretToken: string | null
    tfaToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssessmentTeamMaxAggregateOutputType = {
    id: number | null
    assessmentId: number | null
    organisationId: number | null
    teamId: number | null
    password: string | null
    rememberToken: string | null
    isActive: boolean | null
    secretToken: string | null
    tfaToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssessmentTeamCountAggregateOutputType = {
    id: number
    assessmentId: number
    organisationId: number
    teamId: number
    password: number
    rememberToken: number
    isActive: number
    secretToken: number
    tfaToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssessmentTeamAvgAggregateInputType = {
    id?: true
    assessmentId?: true
    organisationId?: true
    teamId?: true
  }

  export type AssessmentTeamSumAggregateInputType = {
    id?: true
    assessmentId?: true
    organisationId?: true
    teamId?: true
  }

  export type AssessmentTeamMinAggregateInputType = {
    id?: true
    assessmentId?: true
    organisationId?: true
    teamId?: true
    password?: true
    rememberToken?: true
    isActive?: true
    secretToken?: true
    tfaToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssessmentTeamMaxAggregateInputType = {
    id?: true
    assessmentId?: true
    organisationId?: true
    teamId?: true
    password?: true
    rememberToken?: true
    isActive?: true
    secretToken?: true
    tfaToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssessmentTeamCountAggregateInputType = {
    id?: true
    assessmentId?: true
    organisationId?: true
    teamId?: true
    password?: true
    rememberToken?: true
    isActive?: true
    secretToken?: true
    tfaToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssessmentTeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentTeam to aggregate.
     */
    where?: AssessmentTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentTeams to fetch.
     */
    orderBy?: AssessmentTeamOrderByWithRelationInput | AssessmentTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssessmentTeams
    **/
    _count?: true | AssessmentTeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssessmentTeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssessmentTeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentTeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentTeamMaxAggregateInputType
  }

  export type GetAssessmentTeamAggregateType<T extends AssessmentTeamAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessmentTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessmentTeam[P]>
      : GetScalarType<T[P], AggregateAssessmentTeam[P]>
  }




  export type AssessmentTeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentTeamWhereInput
    orderBy?: AssessmentTeamOrderByWithAggregationInput | AssessmentTeamOrderByWithAggregationInput[]
    by: AssessmentTeamScalarFieldEnum[] | AssessmentTeamScalarFieldEnum
    having?: AssessmentTeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentTeamCountAggregateInputType | true
    _avg?: AssessmentTeamAvgAggregateInputType
    _sum?: AssessmentTeamSumAggregateInputType
    _min?: AssessmentTeamMinAggregateInputType
    _max?: AssessmentTeamMaxAggregateInputType
  }

  export type AssessmentTeamGroupByOutputType = {
    id: number
    assessmentId: number
    organisationId: number
    teamId: number
    password: string | null
    rememberToken: string | null
    isActive: boolean
    secretToken: string | null
    tfaToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: AssessmentTeamCountAggregateOutputType | null
    _avg: AssessmentTeamAvgAggregateOutputType | null
    _sum: AssessmentTeamSumAggregateOutputType | null
    _min: AssessmentTeamMinAggregateOutputType | null
    _max: AssessmentTeamMaxAggregateOutputType | null
  }

  type GetAssessmentTeamGroupByPayload<T extends AssessmentTeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentTeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentTeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentTeamGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentTeamGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentTeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assessmentId?: boolean
    organisationId?: boolean
    teamId?: boolean
    password?: boolean
    rememberToken?: boolean
    isActive?: boolean
    secretToken?: boolean
    tfaToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
    Organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    Team?: boolean | TeamDefaultArgs<ExtArgs>
    QuestionAnswer?: boolean | AssessmentTeam$QuestionAnswerArgs<ExtArgs>
    _count?: boolean | AssessmentTeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentTeam"]>


  export type AssessmentTeamSelectScalar = {
    id?: boolean
    assessmentId?: boolean
    organisationId?: boolean
    teamId?: boolean
    password?: boolean
    rememberToken?: boolean
    isActive?: boolean
    secretToken?: boolean
    tfaToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssessmentTeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Assessment?: boolean | AssessmentDefaultArgs<ExtArgs>
    Organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    Team?: boolean | TeamDefaultArgs<ExtArgs>
    QuestionAnswer?: boolean | AssessmentTeam$QuestionAnswerArgs<ExtArgs>
    _count?: boolean | AssessmentTeamCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AssessmentTeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssessmentTeam"
    objects: {
      Assessment: Prisma.$AssessmentPayload<ExtArgs>
      Organisation: Prisma.$OrganisationPayload<ExtArgs>
      Team: Prisma.$TeamPayload<ExtArgs>
      QuestionAnswer: Prisma.$QuestionAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assessmentId: number
      organisationId: number
      teamId: number
      password: string | null
      rememberToken: string | null
      isActive: boolean
      secretToken: string | null
      tfaToken: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assessmentTeam"]>
    composites: {}
  }

  type AssessmentTeamGetPayload<S extends boolean | null | undefined | AssessmentTeamDefaultArgs> = $Result.GetResult<Prisma.$AssessmentTeamPayload, S>

  type AssessmentTeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssessmentTeamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssessmentTeamCountAggregateInputType | true
    }

  export interface AssessmentTeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssessmentTeam'], meta: { name: 'AssessmentTeam' } }
    /**
     * Find zero or one AssessmentTeam that matches the filter.
     * @param {AssessmentTeamFindUniqueArgs} args - Arguments to find a AssessmentTeam
     * @example
     * // Get one AssessmentTeam
     * const assessmentTeam = await prisma.assessmentTeam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssessmentTeamFindUniqueArgs>(args: SelectSubset<T, AssessmentTeamFindUniqueArgs<ExtArgs>>): Prisma__AssessmentTeamClient<$Result.GetResult<Prisma.$AssessmentTeamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AssessmentTeam that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssessmentTeamFindUniqueOrThrowArgs} args - Arguments to find a AssessmentTeam
     * @example
     * // Get one AssessmentTeam
     * const assessmentTeam = await prisma.assessmentTeam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssessmentTeamFindUniqueOrThrowArgs>(args: SelectSubset<T, AssessmentTeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssessmentTeamClient<$Result.GetResult<Prisma.$AssessmentTeamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AssessmentTeam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentTeamFindFirstArgs} args - Arguments to find a AssessmentTeam
     * @example
     * // Get one AssessmentTeam
     * const assessmentTeam = await prisma.assessmentTeam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssessmentTeamFindFirstArgs>(args?: SelectSubset<T, AssessmentTeamFindFirstArgs<ExtArgs>>): Prisma__AssessmentTeamClient<$Result.GetResult<Prisma.$AssessmentTeamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AssessmentTeam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentTeamFindFirstOrThrowArgs} args - Arguments to find a AssessmentTeam
     * @example
     * // Get one AssessmentTeam
     * const assessmentTeam = await prisma.assessmentTeam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssessmentTeamFindFirstOrThrowArgs>(args?: SelectSubset<T, AssessmentTeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssessmentTeamClient<$Result.GetResult<Prisma.$AssessmentTeamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AssessmentTeams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentTeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssessmentTeams
     * const assessmentTeams = await prisma.assessmentTeam.findMany()
     * 
     * // Get first 10 AssessmentTeams
     * const assessmentTeams = await prisma.assessmentTeam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentTeamWithIdOnly = await prisma.assessmentTeam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssessmentTeamFindManyArgs>(args?: SelectSubset<T, AssessmentTeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentTeamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AssessmentTeam.
     * @param {AssessmentTeamCreateArgs} args - Arguments to create a AssessmentTeam.
     * @example
     * // Create one AssessmentTeam
     * const AssessmentTeam = await prisma.assessmentTeam.create({
     *   data: {
     *     // ... data to create a AssessmentTeam
     *   }
     * })
     * 
     */
    create<T extends AssessmentTeamCreateArgs>(args: SelectSubset<T, AssessmentTeamCreateArgs<ExtArgs>>): Prisma__AssessmentTeamClient<$Result.GetResult<Prisma.$AssessmentTeamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AssessmentTeams.
     * @param {AssessmentTeamCreateManyArgs} args - Arguments to create many AssessmentTeams.
     * @example
     * // Create many AssessmentTeams
     * const assessmentTeam = await prisma.assessmentTeam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssessmentTeamCreateManyArgs>(args?: SelectSubset<T, AssessmentTeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AssessmentTeam.
     * @param {AssessmentTeamDeleteArgs} args - Arguments to delete one AssessmentTeam.
     * @example
     * // Delete one AssessmentTeam
     * const AssessmentTeam = await prisma.assessmentTeam.delete({
     *   where: {
     *     // ... filter to delete one AssessmentTeam
     *   }
     * })
     * 
     */
    delete<T extends AssessmentTeamDeleteArgs>(args: SelectSubset<T, AssessmentTeamDeleteArgs<ExtArgs>>): Prisma__AssessmentTeamClient<$Result.GetResult<Prisma.$AssessmentTeamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AssessmentTeam.
     * @param {AssessmentTeamUpdateArgs} args - Arguments to update one AssessmentTeam.
     * @example
     * // Update one AssessmentTeam
     * const assessmentTeam = await prisma.assessmentTeam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssessmentTeamUpdateArgs>(args: SelectSubset<T, AssessmentTeamUpdateArgs<ExtArgs>>): Prisma__AssessmentTeamClient<$Result.GetResult<Prisma.$AssessmentTeamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AssessmentTeams.
     * @param {AssessmentTeamDeleteManyArgs} args - Arguments to filter AssessmentTeams to delete.
     * @example
     * // Delete a few AssessmentTeams
     * const { count } = await prisma.assessmentTeam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssessmentTeamDeleteManyArgs>(args?: SelectSubset<T, AssessmentTeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssessmentTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentTeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssessmentTeams
     * const assessmentTeam = await prisma.assessmentTeam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssessmentTeamUpdateManyArgs>(args: SelectSubset<T, AssessmentTeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssessmentTeam.
     * @param {AssessmentTeamUpsertArgs} args - Arguments to update or create a AssessmentTeam.
     * @example
     * // Update or create a AssessmentTeam
     * const assessmentTeam = await prisma.assessmentTeam.upsert({
     *   create: {
     *     // ... data to create a AssessmentTeam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssessmentTeam we want to update
     *   }
     * })
     */
    upsert<T extends AssessmentTeamUpsertArgs>(args: SelectSubset<T, AssessmentTeamUpsertArgs<ExtArgs>>): Prisma__AssessmentTeamClient<$Result.GetResult<Prisma.$AssessmentTeamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AssessmentTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentTeamCountArgs} args - Arguments to filter AssessmentTeams to count.
     * @example
     * // Count the number of AssessmentTeams
     * const count = await prisma.assessmentTeam.count({
     *   where: {
     *     // ... the filter for the AssessmentTeams we want to count
     *   }
     * })
    **/
    count<T extends AssessmentTeamCountArgs>(
      args?: Subset<T, AssessmentTeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentTeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssessmentTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentTeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentTeamAggregateArgs>(args: Subset<T, AssessmentTeamAggregateArgs>): Prisma.PrismaPromise<GetAssessmentTeamAggregateType<T>>

    /**
     * Group by AssessmentTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentTeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentTeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentTeamGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentTeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentTeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssessmentTeam model
   */
  readonly fields: AssessmentTeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssessmentTeam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentTeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Assessment<T extends AssessmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentDefaultArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    QuestionAnswer<T extends AssessmentTeam$QuestionAnswerArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentTeam$QuestionAnswerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssessmentTeam model
   */ 
  interface AssessmentTeamFieldRefs {
    readonly id: FieldRef<"AssessmentTeam", 'Int'>
    readonly assessmentId: FieldRef<"AssessmentTeam", 'Int'>
    readonly organisationId: FieldRef<"AssessmentTeam", 'Int'>
    readonly teamId: FieldRef<"AssessmentTeam", 'Int'>
    readonly password: FieldRef<"AssessmentTeam", 'String'>
    readonly rememberToken: FieldRef<"AssessmentTeam", 'String'>
    readonly isActive: FieldRef<"AssessmentTeam", 'Boolean'>
    readonly secretToken: FieldRef<"AssessmentTeam", 'String'>
    readonly tfaToken: FieldRef<"AssessmentTeam", 'String'>
    readonly createdAt: FieldRef<"AssessmentTeam", 'DateTime'>
    readonly updatedAt: FieldRef<"AssessmentTeam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssessmentTeam findUnique
   */
  export type AssessmentTeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTeam
     */
    select?: AssessmentTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTeamInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentTeam to fetch.
     */
    where: AssessmentTeamWhereUniqueInput
  }

  /**
   * AssessmentTeam findUniqueOrThrow
   */
  export type AssessmentTeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTeam
     */
    select?: AssessmentTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTeamInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentTeam to fetch.
     */
    where: AssessmentTeamWhereUniqueInput
  }

  /**
   * AssessmentTeam findFirst
   */
  export type AssessmentTeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTeam
     */
    select?: AssessmentTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTeamInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentTeam to fetch.
     */
    where?: AssessmentTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentTeams to fetch.
     */
    orderBy?: AssessmentTeamOrderByWithRelationInput | AssessmentTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentTeams.
     */
    cursor?: AssessmentTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentTeams.
     */
    distinct?: AssessmentTeamScalarFieldEnum | AssessmentTeamScalarFieldEnum[]
  }

  /**
   * AssessmentTeam findFirstOrThrow
   */
  export type AssessmentTeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTeam
     */
    select?: AssessmentTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTeamInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentTeam to fetch.
     */
    where?: AssessmentTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentTeams to fetch.
     */
    orderBy?: AssessmentTeamOrderByWithRelationInput | AssessmentTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentTeams.
     */
    cursor?: AssessmentTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentTeams.
     */
    distinct?: AssessmentTeamScalarFieldEnum | AssessmentTeamScalarFieldEnum[]
  }

  /**
   * AssessmentTeam findMany
   */
  export type AssessmentTeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTeam
     */
    select?: AssessmentTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTeamInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentTeams to fetch.
     */
    where?: AssessmentTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentTeams to fetch.
     */
    orderBy?: AssessmentTeamOrderByWithRelationInput | AssessmentTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssessmentTeams.
     */
    cursor?: AssessmentTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentTeams.
     */
    skip?: number
    distinct?: AssessmentTeamScalarFieldEnum | AssessmentTeamScalarFieldEnum[]
  }

  /**
   * AssessmentTeam create
   */
  export type AssessmentTeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTeam
     */
    select?: AssessmentTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTeamInclude<ExtArgs> | null
    /**
     * The data needed to create a AssessmentTeam.
     */
    data: XOR<AssessmentTeamCreateInput, AssessmentTeamUncheckedCreateInput>
  }

  /**
   * AssessmentTeam createMany
   */
  export type AssessmentTeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssessmentTeams.
     */
    data: AssessmentTeamCreateManyInput | AssessmentTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssessmentTeam update
   */
  export type AssessmentTeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTeam
     */
    select?: AssessmentTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTeamInclude<ExtArgs> | null
    /**
     * The data needed to update a AssessmentTeam.
     */
    data: XOR<AssessmentTeamUpdateInput, AssessmentTeamUncheckedUpdateInput>
    /**
     * Choose, which AssessmentTeam to update.
     */
    where: AssessmentTeamWhereUniqueInput
  }

  /**
   * AssessmentTeam updateMany
   */
  export type AssessmentTeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssessmentTeams.
     */
    data: XOR<AssessmentTeamUpdateManyMutationInput, AssessmentTeamUncheckedUpdateManyInput>
    /**
     * Filter which AssessmentTeams to update
     */
    where?: AssessmentTeamWhereInput
  }

  /**
   * AssessmentTeam upsert
   */
  export type AssessmentTeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTeam
     */
    select?: AssessmentTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTeamInclude<ExtArgs> | null
    /**
     * The filter to search for the AssessmentTeam to update in case it exists.
     */
    where: AssessmentTeamWhereUniqueInput
    /**
     * In case the AssessmentTeam found by the `where` argument doesn't exist, create a new AssessmentTeam with this data.
     */
    create: XOR<AssessmentTeamCreateInput, AssessmentTeamUncheckedCreateInput>
    /**
     * In case the AssessmentTeam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentTeamUpdateInput, AssessmentTeamUncheckedUpdateInput>
  }

  /**
   * AssessmentTeam delete
   */
  export type AssessmentTeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTeam
     */
    select?: AssessmentTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTeamInclude<ExtArgs> | null
    /**
     * Filter which AssessmentTeam to delete.
     */
    where: AssessmentTeamWhereUniqueInput
  }

  /**
   * AssessmentTeam deleteMany
   */
  export type AssessmentTeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentTeams to delete
     */
    where?: AssessmentTeamWhereInput
  }

  /**
   * AssessmentTeam.QuestionAnswer
   */
  export type AssessmentTeam$QuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    where?: QuestionAnswerWhereInput
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    cursor?: QuestionAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * AssessmentTeam without action
   */
  export type AssessmentTeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTeam
     */
    select?: AssessmentTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTeamInclude<ExtArgs> | null
  }


  /**
   * Model Organisation
   */

  export type AggregateOrganisation = {
    _count: OrganisationCountAggregateOutputType | null
    _avg: OrganisationAvgAggregateOutputType | null
    _sum: OrganisationSumAggregateOutputType | null
    _min: OrganisationMinAggregateOutputType | null
    _max: OrganisationMaxAggregateOutputType | null
  }

  export type OrganisationAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
  }

  export type OrganisationSumAggregateOutputType = {
    id: number | null
    ownerId: number | null
  }

  export type OrganisationMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    logo: string | null
    password: string | null
    rememberToken: string | null
    ownerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganisationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    logo: string | null
    password: string | null
    rememberToken: string | null
    ownerId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganisationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    logo: number
    password: number
    rememberToken: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganisationAvgAggregateInputType = {
    id?: true
    ownerId?: true
  }

  export type OrganisationSumAggregateInputType = {
    id?: true
    ownerId?: true
  }

  export type OrganisationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    logo?: true
    password?: true
    rememberToken?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganisationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    logo?: true
    password?: true
    rememberToken?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganisationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    logo?: true
    password?: true
    rememberToken?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganisationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organisation to aggregate.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organisations
    **/
    _count?: true | OrganisationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganisationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganisationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganisationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganisationMaxAggregateInputType
  }

  export type GetOrganisationAggregateType<T extends OrganisationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganisation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganisation[P]>
      : GetScalarType<T[P], AggregateOrganisation[P]>
  }




  export type OrganisationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationWhereInput
    orderBy?: OrganisationOrderByWithAggregationInput | OrganisationOrderByWithAggregationInput[]
    by: OrganisationScalarFieldEnum[] | OrganisationScalarFieldEnum
    having?: OrganisationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganisationCountAggregateInputType | true
    _avg?: OrganisationAvgAggregateInputType
    _sum?: OrganisationSumAggregateInputType
    _min?: OrganisationMinAggregateInputType
    _max?: OrganisationMaxAggregateInputType
  }

  export type OrganisationGroupByOutputType = {
    id: number
    name: string
    description: string | null
    isActive: boolean | null
    logo: string | null
    password: string | null
    rememberToken: string | null
    ownerId: number | null
    createdAt: Date
    updatedAt: Date
    _count: OrganisationCountAggregateOutputType | null
    _avg: OrganisationAvgAggregateOutputType | null
    _sum: OrganisationSumAggregateOutputType | null
    _min: OrganisationMinAggregateOutputType | null
    _max: OrganisationMaxAggregateOutputType | null
  }

  type GetOrganisationGroupByPayload<T extends OrganisationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganisationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganisationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganisationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganisationGroupByOutputType[P]>
        }
      >
    >


  export type OrganisationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    logo?: boolean
    password?: boolean
    rememberToken?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Owner?: boolean | Organisation$OwnerArgs<ExtArgs>
    Assessment?: boolean | Organisation$AssessmentArgs<ExtArgs>
    Team?: boolean | Organisation$TeamArgs<ExtArgs>
    OrganisationTemplate?: boolean | Organisation$OrganisationTemplateArgs<ExtArgs>
    QuestionAnswer?: boolean | Organisation$QuestionAnswerArgs<ExtArgs>
    AssessmentTeam?: boolean | Organisation$AssessmentTeamArgs<ExtArgs>
    _count?: boolean | OrganisationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organisation"]>


  export type OrganisationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    logo?: boolean
    password?: boolean
    rememberToken?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganisationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Owner?: boolean | Organisation$OwnerArgs<ExtArgs>
    Assessment?: boolean | Organisation$AssessmentArgs<ExtArgs>
    Team?: boolean | Organisation$TeamArgs<ExtArgs>
    OrganisationTemplate?: boolean | Organisation$OrganisationTemplateArgs<ExtArgs>
    QuestionAnswer?: boolean | Organisation$QuestionAnswerArgs<ExtArgs>
    AssessmentTeam?: boolean | Organisation$AssessmentTeamArgs<ExtArgs>
    _count?: boolean | OrganisationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrganisationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organisation"
    objects: {
      Owner: Prisma.$UserPayload<ExtArgs> | null
      Assessment: Prisma.$AssessmentPayload<ExtArgs>[]
      Team: Prisma.$TeamPayload<ExtArgs>[]
      OrganisationTemplate: Prisma.$OrganisationTemplatePayload<ExtArgs>[]
      QuestionAnswer: Prisma.$QuestionAnswerPayload<ExtArgs>[]
      AssessmentTeam: Prisma.$AssessmentTeamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      isActive: boolean | null
      logo: string | null
      password: string | null
      rememberToken: string | null
      ownerId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organisation"]>
    composites: {}
  }

  type OrganisationGetPayload<S extends boolean | null | undefined | OrganisationDefaultArgs> = $Result.GetResult<Prisma.$OrganisationPayload, S>

  type OrganisationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganisationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganisationCountAggregateInputType | true
    }

  export interface OrganisationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organisation'], meta: { name: 'Organisation' } }
    /**
     * Find zero or one Organisation that matches the filter.
     * @param {OrganisationFindUniqueArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganisationFindUniqueArgs>(args: SelectSubset<T, OrganisationFindUniqueArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organisation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganisationFindUniqueOrThrowArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganisationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganisationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organisation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationFindFirstArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganisationFindFirstArgs>(args?: SelectSubset<T, OrganisationFindFirstArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organisation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationFindFirstOrThrowArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganisationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganisationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organisations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organisations
     * const organisations = await prisma.organisation.findMany()
     * 
     * // Get first 10 Organisations
     * const organisations = await prisma.organisation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organisationWithIdOnly = await prisma.organisation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganisationFindManyArgs>(args?: SelectSubset<T, OrganisationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organisation.
     * @param {OrganisationCreateArgs} args - Arguments to create a Organisation.
     * @example
     * // Create one Organisation
     * const Organisation = await prisma.organisation.create({
     *   data: {
     *     // ... data to create a Organisation
     *   }
     * })
     * 
     */
    create<T extends OrganisationCreateArgs>(args: SelectSubset<T, OrganisationCreateArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organisations.
     * @param {OrganisationCreateManyArgs} args - Arguments to create many Organisations.
     * @example
     * // Create many Organisations
     * const organisation = await prisma.organisation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganisationCreateManyArgs>(args?: SelectSubset<T, OrganisationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organisation.
     * @param {OrganisationDeleteArgs} args - Arguments to delete one Organisation.
     * @example
     * // Delete one Organisation
     * const Organisation = await prisma.organisation.delete({
     *   where: {
     *     // ... filter to delete one Organisation
     *   }
     * })
     * 
     */
    delete<T extends OrganisationDeleteArgs>(args: SelectSubset<T, OrganisationDeleteArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organisation.
     * @param {OrganisationUpdateArgs} args - Arguments to update one Organisation.
     * @example
     * // Update one Organisation
     * const organisation = await prisma.organisation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganisationUpdateArgs>(args: SelectSubset<T, OrganisationUpdateArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organisations.
     * @param {OrganisationDeleteManyArgs} args - Arguments to filter Organisations to delete.
     * @example
     * // Delete a few Organisations
     * const { count } = await prisma.organisation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganisationDeleteManyArgs>(args?: SelectSubset<T, OrganisationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organisations
     * const organisation = await prisma.organisation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganisationUpdateManyArgs>(args: SelectSubset<T, OrganisationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organisation.
     * @param {OrganisationUpsertArgs} args - Arguments to update or create a Organisation.
     * @example
     * // Update or create a Organisation
     * const organisation = await prisma.organisation.upsert({
     *   create: {
     *     // ... data to create a Organisation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organisation we want to update
     *   }
     * })
     */
    upsert<T extends OrganisationUpsertArgs>(args: SelectSubset<T, OrganisationUpsertArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationCountArgs} args - Arguments to filter Organisations to count.
     * @example
     * // Count the number of Organisations
     * const count = await prisma.organisation.count({
     *   where: {
     *     // ... the filter for the Organisations we want to count
     *   }
     * })
    **/
    count<T extends OrganisationCountArgs>(
      args?: Subset<T, OrganisationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganisationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganisationAggregateArgs>(args: Subset<T, OrganisationAggregateArgs>): Prisma.PrismaPromise<GetOrganisationAggregateType<T>>

    /**
     * Group by Organisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganisationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganisationGroupByArgs['orderBy'] }
        : { orderBy?: OrganisationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganisationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganisationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organisation model
   */
  readonly fields: OrganisationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organisation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganisationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Owner<T extends Organisation$OwnerArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$OwnerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Assessment<T extends Organisation$AssessmentArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$AssessmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findMany"> | Null>
    Team<T extends Organisation$TeamArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$TeamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany"> | Null>
    OrganisationTemplate<T extends Organisation$OrganisationTemplateArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$OrganisationTemplateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    QuestionAnswer<T extends Organisation$QuestionAnswerArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$QuestionAnswerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    AssessmentTeam<T extends Organisation$AssessmentTeamArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$AssessmentTeamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentTeamPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organisation model
   */ 
  interface OrganisationFieldRefs {
    readonly id: FieldRef<"Organisation", 'Int'>
    readonly name: FieldRef<"Organisation", 'String'>
    readonly description: FieldRef<"Organisation", 'String'>
    readonly isActive: FieldRef<"Organisation", 'Boolean'>
    readonly logo: FieldRef<"Organisation", 'String'>
    readonly password: FieldRef<"Organisation", 'String'>
    readonly rememberToken: FieldRef<"Organisation", 'String'>
    readonly ownerId: FieldRef<"Organisation", 'Int'>
    readonly createdAt: FieldRef<"Organisation", 'DateTime'>
    readonly updatedAt: FieldRef<"Organisation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organisation findUnique
   */
  export type OrganisationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation findUniqueOrThrow
   */
  export type OrganisationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation findFirst
   */
  export type OrganisationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organisations.
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organisations.
     */
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * Organisation findFirstOrThrow
   */
  export type OrganisationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organisations.
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organisations.
     */
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * Organisation findMany
   */
  export type OrganisationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisations to fetch.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organisations.
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * Organisation create
   */
  export type OrganisationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organisation.
     */
    data: XOR<OrganisationCreateInput, OrganisationUncheckedCreateInput>
  }

  /**
   * Organisation createMany
   */
  export type OrganisationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organisations.
     */
    data: OrganisationCreateManyInput | OrganisationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organisation update
   */
  export type OrganisationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organisation.
     */
    data: XOR<OrganisationUpdateInput, OrganisationUncheckedUpdateInput>
    /**
     * Choose, which Organisation to update.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation updateMany
   */
  export type OrganisationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organisations.
     */
    data: XOR<OrganisationUpdateManyMutationInput, OrganisationUncheckedUpdateManyInput>
    /**
     * Filter which Organisations to update
     */
    where?: OrganisationWhereInput
  }

  /**
   * Organisation upsert
   */
  export type OrganisationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organisation to update in case it exists.
     */
    where: OrganisationWhereUniqueInput
    /**
     * In case the Organisation found by the `where` argument doesn't exist, create a new Organisation with this data.
     */
    create: XOR<OrganisationCreateInput, OrganisationUncheckedCreateInput>
    /**
     * In case the Organisation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganisationUpdateInput, OrganisationUncheckedUpdateInput>
  }

  /**
   * Organisation delete
   */
  export type OrganisationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter which Organisation to delete.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation deleteMany
   */
  export type OrganisationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organisations to delete
     */
    where?: OrganisationWhereInput
  }

  /**
   * Organisation.Owner
   */
  export type Organisation$OwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Organisation.Assessment
   */
  export type Organisation$AssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    where?: AssessmentWhereInput
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    cursor?: AssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * Organisation.Team
   */
  export type Organisation$TeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Organisation.OrganisationTemplate
   */
  export type Organisation$OrganisationTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationTemplate
     */
    select?: OrganisationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationTemplateInclude<ExtArgs> | null
    where?: OrganisationTemplateWhereInput
    orderBy?: OrganisationTemplateOrderByWithRelationInput | OrganisationTemplateOrderByWithRelationInput[]
    cursor?: OrganisationTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganisationTemplateScalarFieldEnum | OrganisationTemplateScalarFieldEnum[]
  }

  /**
   * Organisation.QuestionAnswer
   */
  export type Organisation$QuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    where?: QuestionAnswerWhereInput
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    cursor?: QuestionAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * Organisation.AssessmentTeam
   */
  export type Organisation$AssessmentTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTeam
     */
    select?: AssessmentTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTeamInclude<ExtArgs> | null
    where?: AssessmentTeamWhereInput
    orderBy?: AssessmentTeamOrderByWithRelationInput | AssessmentTeamOrderByWithRelationInput[]
    cursor?: AssessmentTeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentTeamScalarFieldEnum | AssessmentTeamScalarFieldEnum[]
  }

  /**
   * Organisation without action
   */
  export type OrganisationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
  }


  /**
   * Model OrganisationRole
   */

  export type AggregateOrganisationRole = {
    _count: OrganisationRoleCountAggregateOutputType | null
    _avg: OrganisationRoleAvgAggregateOutputType | null
    _sum: OrganisationRoleSumAggregateOutputType | null
    _min: OrganisationRoleMinAggregateOutputType | null
    _max: OrganisationRoleMaxAggregateOutputType | null
  }

  export type OrganisationRoleAvgAggregateOutputType = {
    id: number | null
    organisationStructureId: number | null
    roleId: number | null
  }

  export type OrganisationRoleSumAggregateOutputType = {
    id: number | null
    organisationStructureId: number | null
    roleId: number | null
  }

  export type OrganisationRoleMinAggregateOutputType = {
    id: number | null
    isActive: boolean | null
    organisationStructureId: number | null
    roleId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganisationRoleMaxAggregateOutputType = {
    id: number | null
    isActive: boolean | null
    organisationStructureId: number | null
    roleId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganisationRoleCountAggregateOutputType = {
    id: number
    isActive: number
    organisationStructureId: number
    roleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganisationRoleAvgAggregateInputType = {
    id?: true
    organisationStructureId?: true
    roleId?: true
  }

  export type OrganisationRoleSumAggregateInputType = {
    id?: true
    organisationStructureId?: true
    roleId?: true
  }

  export type OrganisationRoleMinAggregateInputType = {
    id?: true
    isActive?: true
    organisationStructureId?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganisationRoleMaxAggregateInputType = {
    id?: true
    isActive?: true
    organisationStructureId?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganisationRoleCountAggregateInputType = {
    id?: true
    isActive?: true
    organisationStructureId?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganisationRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganisationRole to aggregate.
     */
    where?: OrganisationRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationRoles to fetch.
     */
    orderBy?: OrganisationRoleOrderByWithRelationInput | OrganisationRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganisationRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganisationRoles
    **/
    _count?: true | OrganisationRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganisationRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganisationRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganisationRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganisationRoleMaxAggregateInputType
  }

  export type GetOrganisationRoleAggregateType<T extends OrganisationRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganisationRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganisationRole[P]>
      : GetScalarType<T[P], AggregateOrganisationRole[P]>
  }




  export type OrganisationRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationRoleWhereInput
    orderBy?: OrganisationRoleOrderByWithAggregationInput | OrganisationRoleOrderByWithAggregationInput[]
    by: OrganisationRoleScalarFieldEnum[] | OrganisationRoleScalarFieldEnum
    having?: OrganisationRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganisationRoleCountAggregateInputType | true
    _avg?: OrganisationRoleAvgAggregateInputType
    _sum?: OrganisationRoleSumAggregateInputType
    _min?: OrganisationRoleMinAggregateInputType
    _max?: OrganisationRoleMaxAggregateInputType
  }

  export type OrganisationRoleGroupByOutputType = {
    id: number
    isActive: boolean | null
    organisationStructureId: number
    roleId: number
    createdAt: Date
    updatedAt: Date
    _count: OrganisationRoleCountAggregateOutputType | null
    _avg: OrganisationRoleAvgAggregateOutputType | null
    _sum: OrganisationRoleSumAggregateOutputType | null
    _min: OrganisationRoleMinAggregateOutputType | null
    _max: OrganisationRoleMaxAggregateOutputType | null
  }

  type GetOrganisationRoleGroupByPayload<T extends OrganisationRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganisationRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganisationRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganisationRoleGroupByOutputType[P]>
            : GetScalarType<T[P], OrganisationRoleGroupByOutputType[P]>
        }
      >
    >


  export type OrganisationRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isActive?: boolean
    organisationStructureId?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    OrganisationStructure?: boolean | OrganisationStructureDefaultArgs<ExtArgs>
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organisationRole"]>


  export type OrganisationRoleSelectScalar = {
    id?: boolean
    isActive?: boolean
    organisationStructureId?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganisationRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrganisationStructure?: boolean | OrganisationStructureDefaultArgs<ExtArgs>
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $OrganisationRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganisationRole"
    objects: {
      OrganisationStructure: Prisma.$OrganisationStructurePayload<ExtArgs>
      Role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      isActive: boolean | null
      organisationStructureId: number
      roleId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organisationRole"]>
    composites: {}
  }

  type OrganisationRoleGetPayload<S extends boolean | null | undefined | OrganisationRoleDefaultArgs> = $Result.GetResult<Prisma.$OrganisationRolePayload, S>

  type OrganisationRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganisationRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganisationRoleCountAggregateInputType | true
    }

  export interface OrganisationRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganisationRole'], meta: { name: 'OrganisationRole' } }
    /**
     * Find zero or one OrganisationRole that matches the filter.
     * @param {OrganisationRoleFindUniqueArgs} args - Arguments to find a OrganisationRole
     * @example
     * // Get one OrganisationRole
     * const organisationRole = await prisma.organisationRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganisationRoleFindUniqueArgs>(args: SelectSubset<T, OrganisationRoleFindUniqueArgs<ExtArgs>>): Prisma__OrganisationRoleClient<$Result.GetResult<Prisma.$OrganisationRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrganisationRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganisationRoleFindUniqueOrThrowArgs} args - Arguments to find a OrganisationRole
     * @example
     * // Get one OrganisationRole
     * const organisationRole = await prisma.organisationRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganisationRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganisationRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganisationRoleClient<$Result.GetResult<Prisma.$OrganisationRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrganisationRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationRoleFindFirstArgs} args - Arguments to find a OrganisationRole
     * @example
     * // Get one OrganisationRole
     * const organisationRole = await prisma.organisationRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganisationRoleFindFirstArgs>(args?: SelectSubset<T, OrganisationRoleFindFirstArgs<ExtArgs>>): Prisma__OrganisationRoleClient<$Result.GetResult<Prisma.$OrganisationRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrganisationRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationRoleFindFirstOrThrowArgs} args - Arguments to find a OrganisationRole
     * @example
     * // Get one OrganisationRole
     * const organisationRole = await prisma.organisationRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganisationRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganisationRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganisationRoleClient<$Result.GetResult<Prisma.$OrganisationRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrganisationRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganisationRoles
     * const organisationRoles = await prisma.organisationRole.findMany()
     * 
     * // Get first 10 OrganisationRoles
     * const organisationRoles = await prisma.organisationRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organisationRoleWithIdOnly = await prisma.organisationRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganisationRoleFindManyArgs>(args?: SelectSubset<T, OrganisationRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrganisationRole.
     * @param {OrganisationRoleCreateArgs} args - Arguments to create a OrganisationRole.
     * @example
     * // Create one OrganisationRole
     * const OrganisationRole = await prisma.organisationRole.create({
     *   data: {
     *     // ... data to create a OrganisationRole
     *   }
     * })
     * 
     */
    create<T extends OrganisationRoleCreateArgs>(args: SelectSubset<T, OrganisationRoleCreateArgs<ExtArgs>>): Prisma__OrganisationRoleClient<$Result.GetResult<Prisma.$OrganisationRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrganisationRoles.
     * @param {OrganisationRoleCreateManyArgs} args - Arguments to create many OrganisationRoles.
     * @example
     * // Create many OrganisationRoles
     * const organisationRole = await prisma.organisationRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganisationRoleCreateManyArgs>(args?: SelectSubset<T, OrganisationRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrganisationRole.
     * @param {OrganisationRoleDeleteArgs} args - Arguments to delete one OrganisationRole.
     * @example
     * // Delete one OrganisationRole
     * const OrganisationRole = await prisma.organisationRole.delete({
     *   where: {
     *     // ... filter to delete one OrganisationRole
     *   }
     * })
     * 
     */
    delete<T extends OrganisationRoleDeleteArgs>(args: SelectSubset<T, OrganisationRoleDeleteArgs<ExtArgs>>): Prisma__OrganisationRoleClient<$Result.GetResult<Prisma.$OrganisationRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrganisationRole.
     * @param {OrganisationRoleUpdateArgs} args - Arguments to update one OrganisationRole.
     * @example
     * // Update one OrganisationRole
     * const organisationRole = await prisma.organisationRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganisationRoleUpdateArgs>(args: SelectSubset<T, OrganisationRoleUpdateArgs<ExtArgs>>): Prisma__OrganisationRoleClient<$Result.GetResult<Prisma.$OrganisationRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrganisationRoles.
     * @param {OrganisationRoleDeleteManyArgs} args - Arguments to filter OrganisationRoles to delete.
     * @example
     * // Delete a few OrganisationRoles
     * const { count } = await prisma.organisationRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganisationRoleDeleteManyArgs>(args?: SelectSubset<T, OrganisationRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganisationRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganisationRoles
     * const organisationRole = await prisma.organisationRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganisationRoleUpdateManyArgs>(args: SelectSubset<T, OrganisationRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrganisationRole.
     * @param {OrganisationRoleUpsertArgs} args - Arguments to update or create a OrganisationRole.
     * @example
     * // Update or create a OrganisationRole
     * const organisationRole = await prisma.organisationRole.upsert({
     *   create: {
     *     // ... data to create a OrganisationRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganisationRole we want to update
     *   }
     * })
     */
    upsert<T extends OrganisationRoleUpsertArgs>(args: SelectSubset<T, OrganisationRoleUpsertArgs<ExtArgs>>): Prisma__OrganisationRoleClient<$Result.GetResult<Prisma.$OrganisationRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrganisationRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationRoleCountArgs} args - Arguments to filter OrganisationRoles to count.
     * @example
     * // Count the number of OrganisationRoles
     * const count = await prisma.organisationRole.count({
     *   where: {
     *     // ... the filter for the OrganisationRoles we want to count
     *   }
     * })
    **/
    count<T extends OrganisationRoleCountArgs>(
      args?: Subset<T, OrganisationRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganisationRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganisationRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganisationRoleAggregateArgs>(args: Subset<T, OrganisationRoleAggregateArgs>): Prisma.PrismaPromise<GetOrganisationRoleAggregateType<T>>

    /**
     * Group by OrganisationRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganisationRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganisationRoleGroupByArgs['orderBy'] }
        : { orderBy?: OrganisationRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganisationRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganisationRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganisationRole model
   */
  readonly fields: OrganisationRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganisationRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganisationRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OrganisationStructure<T extends OrganisationStructureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationStructureDefaultArgs<ExtArgs>>): Prisma__OrganisationStructureClient<$Result.GetResult<Prisma.$OrganisationStructurePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganisationRole model
   */ 
  interface OrganisationRoleFieldRefs {
    readonly id: FieldRef<"OrganisationRole", 'Int'>
    readonly isActive: FieldRef<"OrganisationRole", 'Boolean'>
    readonly organisationStructureId: FieldRef<"OrganisationRole", 'Int'>
    readonly roleId: FieldRef<"OrganisationRole", 'Int'>
    readonly createdAt: FieldRef<"OrganisationRole", 'DateTime'>
    readonly updatedAt: FieldRef<"OrganisationRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrganisationRole findUnique
   */
  export type OrganisationRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationRole
     */
    select?: OrganisationRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationRoleInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationRole to fetch.
     */
    where: OrganisationRoleWhereUniqueInput
  }

  /**
   * OrganisationRole findUniqueOrThrow
   */
  export type OrganisationRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationRole
     */
    select?: OrganisationRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationRoleInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationRole to fetch.
     */
    where: OrganisationRoleWhereUniqueInput
  }

  /**
   * OrganisationRole findFirst
   */
  export type OrganisationRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationRole
     */
    select?: OrganisationRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationRoleInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationRole to fetch.
     */
    where?: OrganisationRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationRoles to fetch.
     */
    orderBy?: OrganisationRoleOrderByWithRelationInput | OrganisationRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganisationRoles.
     */
    cursor?: OrganisationRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganisationRoles.
     */
    distinct?: OrganisationRoleScalarFieldEnum | OrganisationRoleScalarFieldEnum[]
  }

  /**
   * OrganisationRole findFirstOrThrow
   */
  export type OrganisationRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationRole
     */
    select?: OrganisationRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationRoleInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationRole to fetch.
     */
    where?: OrganisationRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationRoles to fetch.
     */
    orderBy?: OrganisationRoleOrderByWithRelationInput | OrganisationRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganisationRoles.
     */
    cursor?: OrganisationRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganisationRoles.
     */
    distinct?: OrganisationRoleScalarFieldEnum | OrganisationRoleScalarFieldEnum[]
  }

  /**
   * OrganisationRole findMany
   */
  export type OrganisationRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationRole
     */
    select?: OrganisationRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationRoleInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationRoles to fetch.
     */
    where?: OrganisationRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationRoles to fetch.
     */
    orderBy?: OrganisationRoleOrderByWithRelationInput | OrganisationRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganisationRoles.
     */
    cursor?: OrganisationRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationRoles.
     */
    skip?: number
    distinct?: OrganisationRoleScalarFieldEnum | OrganisationRoleScalarFieldEnum[]
  }

  /**
   * OrganisationRole create
   */
  export type OrganisationRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationRole
     */
    select?: OrganisationRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganisationRole.
     */
    data: XOR<OrganisationRoleCreateInput, OrganisationRoleUncheckedCreateInput>
  }

  /**
   * OrganisationRole createMany
   */
  export type OrganisationRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganisationRoles.
     */
    data: OrganisationRoleCreateManyInput | OrganisationRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganisationRole update
   */
  export type OrganisationRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationRole
     */
    select?: OrganisationRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganisationRole.
     */
    data: XOR<OrganisationRoleUpdateInput, OrganisationRoleUncheckedUpdateInput>
    /**
     * Choose, which OrganisationRole to update.
     */
    where: OrganisationRoleWhereUniqueInput
  }

  /**
   * OrganisationRole updateMany
   */
  export type OrganisationRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganisationRoles.
     */
    data: XOR<OrganisationRoleUpdateManyMutationInput, OrganisationRoleUncheckedUpdateManyInput>
    /**
     * Filter which OrganisationRoles to update
     */
    where?: OrganisationRoleWhereInput
  }

  /**
   * OrganisationRole upsert
   */
  export type OrganisationRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationRole
     */
    select?: OrganisationRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganisationRole to update in case it exists.
     */
    where: OrganisationRoleWhereUniqueInput
    /**
     * In case the OrganisationRole found by the `where` argument doesn't exist, create a new OrganisationRole with this data.
     */
    create: XOR<OrganisationRoleCreateInput, OrganisationRoleUncheckedCreateInput>
    /**
     * In case the OrganisationRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganisationRoleUpdateInput, OrganisationRoleUncheckedUpdateInput>
  }

  /**
   * OrganisationRole delete
   */
  export type OrganisationRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationRole
     */
    select?: OrganisationRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationRoleInclude<ExtArgs> | null
    /**
     * Filter which OrganisationRole to delete.
     */
    where: OrganisationRoleWhereUniqueInput
  }

  /**
   * OrganisationRole deleteMany
   */
  export type OrganisationRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganisationRoles to delete
     */
    where?: OrganisationRoleWhereInput
  }

  /**
   * OrganisationRole without action
   */
  export type OrganisationRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationRole
     */
    select?: OrganisationRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationRoleInclude<ExtArgs> | null
  }


  /**
   * Model OrganisationStructure
   */

  export type AggregateOrganisationStructure = {
    _count: OrganisationStructureCountAggregateOutputType | null
    _avg: OrganisationStructureAvgAggregateOutputType | null
    _sum: OrganisationStructureSumAggregateOutputType | null
    _min: OrganisationStructureMinAggregateOutputType | null
    _max: OrganisationStructureMaxAggregateOutputType | null
  }

  export type OrganisationStructureAvgAggregateOutputType = {
    id: number | null
    organisationId: number | null
    teamId: number | null
    userId: number | null
  }

  export type OrganisationStructureSumAggregateOutputType = {
    id: number | null
    organisationId: number | null
    teamId: number | null
    userId: number | null
  }

  export type OrganisationStructureMinAggregateOutputType = {
    id: number | null
    organisationId: number | null
    teamId: number | null
    userId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganisationStructureMaxAggregateOutputType = {
    id: number | null
    organisationId: number | null
    teamId: number | null
    userId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganisationStructureCountAggregateOutputType = {
    id: number
    organisationId: number
    teamId: number
    userId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganisationStructureAvgAggregateInputType = {
    id?: true
    organisationId?: true
    teamId?: true
    userId?: true
  }

  export type OrganisationStructureSumAggregateInputType = {
    id?: true
    organisationId?: true
    teamId?: true
    userId?: true
  }

  export type OrganisationStructureMinAggregateInputType = {
    id?: true
    organisationId?: true
    teamId?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganisationStructureMaxAggregateInputType = {
    id?: true
    organisationId?: true
    teamId?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganisationStructureCountAggregateInputType = {
    id?: true
    organisationId?: true
    teamId?: true
    userId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganisationStructureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganisationStructure to aggregate.
     */
    where?: OrganisationStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationStructures to fetch.
     */
    orderBy?: OrganisationStructureOrderByWithRelationInput | OrganisationStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganisationStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganisationStructures
    **/
    _count?: true | OrganisationStructureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganisationStructureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganisationStructureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganisationStructureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganisationStructureMaxAggregateInputType
  }

  export type GetOrganisationStructureAggregateType<T extends OrganisationStructureAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganisationStructure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganisationStructure[P]>
      : GetScalarType<T[P], AggregateOrganisationStructure[P]>
  }




  export type OrganisationStructureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationStructureWhereInput
    orderBy?: OrganisationStructureOrderByWithAggregationInput | OrganisationStructureOrderByWithAggregationInput[]
    by: OrganisationStructureScalarFieldEnum[] | OrganisationStructureScalarFieldEnum
    having?: OrganisationStructureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganisationStructureCountAggregateInputType | true
    _avg?: OrganisationStructureAvgAggregateInputType
    _sum?: OrganisationStructureSumAggregateInputType
    _min?: OrganisationStructureMinAggregateInputType
    _max?: OrganisationStructureMaxAggregateInputType
  }

  export type OrganisationStructureGroupByOutputType = {
    id: number
    organisationId: number
    teamId: number | null
    userId: number
    isActive: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: OrganisationStructureCountAggregateOutputType | null
    _avg: OrganisationStructureAvgAggregateOutputType | null
    _sum: OrganisationStructureSumAggregateOutputType | null
    _min: OrganisationStructureMinAggregateOutputType | null
    _max: OrganisationStructureMaxAggregateOutputType | null
  }

  type GetOrganisationStructureGroupByPayload<T extends OrganisationStructureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganisationStructureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganisationStructureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganisationStructureGroupByOutputType[P]>
            : GetScalarType<T[P], OrganisationStructureGroupByOutputType[P]>
        }
      >
    >


  export type OrganisationStructureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organisationId?: boolean
    teamId?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Team?: boolean | OrganisationStructure$TeamArgs<ExtArgs>
    OrganisationRole?: boolean | OrganisationStructure$OrganisationRoleArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    QuestionAnswer?: boolean | OrganisationStructure$QuestionAnswerArgs<ExtArgs>
    _count?: boolean | OrganisationStructureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organisationStructure"]>


  export type OrganisationStructureSelectScalar = {
    id?: boolean
    organisationId?: boolean
    teamId?: boolean
    userId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganisationStructureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Team?: boolean | OrganisationStructure$TeamArgs<ExtArgs>
    OrganisationRole?: boolean | OrganisationStructure$OrganisationRoleArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    QuestionAnswer?: boolean | OrganisationStructure$QuestionAnswerArgs<ExtArgs>
    _count?: boolean | OrganisationStructureCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrganisationStructurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganisationStructure"
    objects: {
      Team: Prisma.$TeamPayload<ExtArgs> | null
      OrganisationRole: Prisma.$OrganisationRolePayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>
      QuestionAnswer: Prisma.$QuestionAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      organisationId: number
      teamId: number | null
      userId: number
      isActive: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organisationStructure"]>
    composites: {}
  }

  type OrganisationStructureGetPayload<S extends boolean | null | undefined | OrganisationStructureDefaultArgs> = $Result.GetResult<Prisma.$OrganisationStructurePayload, S>

  type OrganisationStructureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganisationStructureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganisationStructureCountAggregateInputType | true
    }

  export interface OrganisationStructureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganisationStructure'], meta: { name: 'OrganisationStructure' } }
    /**
     * Find zero or one OrganisationStructure that matches the filter.
     * @param {OrganisationStructureFindUniqueArgs} args - Arguments to find a OrganisationStructure
     * @example
     * // Get one OrganisationStructure
     * const organisationStructure = await prisma.organisationStructure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganisationStructureFindUniqueArgs>(args: SelectSubset<T, OrganisationStructureFindUniqueArgs<ExtArgs>>): Prisma__OrganisationStructureClient<$Result.GetResult<Prisma.$OrganisationStructurePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrganisationStructure that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganisationStructureFindUniqueOrThrowArgs} args - Arguments to find a OrganisationStructure
     * @example
     * // Get one OrganisationStructure
     * const organisationStructure = await prisma.organisationStructure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganisationStructureFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganisationStructureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganisationStructureClient<$Result.GetResult<Prisma.$OrganisationStructurePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrganisationStructure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationStructureFindFirstArgs} args - Arguments to find a OrganisationStructure
     * @example
     * // Get one OrganisationStructure
     * const organisationStructure = await prisma.organisationStructure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganisationStructureFindFirstArgs>(args?: SelectSubset<T, OrganisationStructureFindFirstArgs<ExtArgs>>): Prisma__OrganisationStructureClient<$Result.GetResult<Prisma.$OrganisationStructurePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrganisationStructure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationStructureFindFirstOrThrowArgs} args - Arguments to find a OrganisationStructure
     * @example
     * // Get one OrganisationStructure
     * const organisationStructure = await prisma.organisationStructure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganisationStructureFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganisationStructureFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganisationStructureClient<$Result.GetResult<Prisma.$OrganisationStructurePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrganisationStructures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationStructureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganisationStructures
     * const organisationStructures = await prisma.organisationStructure.findMany()
     * 
     * // Get first 10 OrganisationStructures
     * const organisationStructures = await prisma.organisationStructure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organisationStructureWithIdOnly = await prisma.organisationStructure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganisationStructureFindManyArgs>(args?: SelectSubset<T, OrganisationStructureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationStructurePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrganisationStructure.
     * @param {OrganisationStructureCreateArgs} args - Arguments to create a OrganisationStructure.
     * @example
     * // Create one OrganisationStructure
     * const OrganisationStructure = await prisma.organisationStructure.create({
     *   data: {
     *     // ... data to create a OrganisationStructure
     *   }
     * })
     * 
     */
    create<T extends OrganisationStructureCreateArgs>(args: SelectSubset<T, OrganisationStructureCreateArgs<ExtArgs>>): Prisma__OrganisationStructureClient<$Result.GetResult<Prisma.$OrganisationStructurePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrganisationStructures.
     * @param {OrganisationStructureCreateManyArgs} args - Arguments to create many OrganisationStructures.
     * @example
     * // Create many OrganisationStructures
     * const organisationStructure = await prisma.organisationStructure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganisationStructureCreateManyArgs>(args?: SelectSubset<T, OrganisationStructureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrganisationStructure.
     * @param {OrganisationStructureDeleteArgs} args - Arguments to delete one OrganisationStructure.
     * @example
     * // Delete one OrganisationStructure
     * const OrganisationStructure = await prisma.organisationStructure.delete({
     *   where: {
     *     // ... filter to delete one OrganisationStructure
     *   }
     * })
     * 
     */
    delete<T extends OrganisationStructureDeleteArgs>(args: SelectSubset<T, OrganisationStructureDeleteArgs<ExtArgs>>): Prisma__OrganisationStructureClient<$Result.GetResult<Prisma.$OrganisationStructurePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrganisationStructure.
     * @param {OrganisationStructureUpdateArgs} args - Arguments to update one OrganisationStructure.
     * @example
     * // Update one OrganisationStructure
     * const organisationStructure = await prisma.organisationStructure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganisationStructureUpdateArgs>(args: SelectSubset<T, OrganisationStructureUpdateArgs<ExtArgs>>): Prisma__OrganisationStructureClient<$Result.GetResult<Prisma.$OrganisationStructurePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrganisationStructures.
     * @param {OrganisationStructureDeleteManyArgs} args - Arguments to filter OrganisationStructures to delete.
     * @example
     * // Delete a few OrganisationStructures
     * const { count } = await prisma.organisationStructure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganisationStructureDeleteManyArgs>(args?: SelectSubset<T, OrganisationStructureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganisationStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationStructureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganisationStructures
     * const organisationStructure = await prisma.organisationStructure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganisationStructureUpdateManyArgs>(args: SelectSubset<T, OrganisationStructureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrganisationStructure.
     * @param {OrganisationStructureUpsertArgs} args - Arguments to update or create a OrganisationStructure.
     * @example
     * // Update or create a OrganisationStructure
     * const organisationStructure = await prisma.organisationStructure.upsert({
     *   create: {
     *     // ... data to create a OrganisationStructure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganisationStructure we want to update
     *   }
     * })
     */
    upsert<T extends OrganisationStructureUpsertArgs>(args: SelectSubset<T, OrganisationStructureUpsertArgs<ExtArgs>>): Prisma__OrganisationStructureClient<$Result.GetResult<Prisma.$OrganisationStructurePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrganisationStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationStructureCountArgs} args - Arguments to filter OrganisationStructures to count.
     * @example
     * // Count the number of OrganisationStructures
     * const count = await prisma.organisationStructure.count({
     *   where: {
     *     // ... the filter for the OrganisationStructures we want to count
     *   }
     * })
    **/
    count<T extends OrganisationStructureCountArgs>(
      args?: Subset<T, OrganisationStructureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganisationStructureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganisationStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationStructureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganisationStructureAggregateArgs>(args: Subset<T, OrganisationStructureAggregateArgs>): Prisma.PrismaPromise<GetOrganisationStructureAggregateType<T>>

    /**
     * Group by OrganisationStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationStructureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganisationStructureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganisationStructureGroupByArgs['orderBy'] }
        : { orderBy?: OrganisationStructureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganisationStructureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganisationStructureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganisationStructure model
   */
  readonly fields: OrganisationStructureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganisationStructure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganisationStructureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Team<T extends OrganisationStructure$TeamArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationStructure$TeamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    OrganisationRole<T extends OrganisationStructure$OrganisationRoleArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationStructure$OrganisationRoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationRolePayload<ExtArgs>, T, "findMany"> | Null>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    QuestionAnswer<T extends OrganisationStructure$QuestionAnswerArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationStructure$QuestionAnswerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganisationStructure model
   */ 
  interface OrganisationStructureFieldRefs {
    readonly id: FieldRef<"OrganisationStructure", 'Int'>
    readonly organisationId: FieldRef<"OrganisationStructure", 'Int'>
    readonly teamId: FieldRef<"OrganisationStructure", 'Int'>
    readonly userId: FieldRef<"OrganisationStructure", 'Int'>
    readonly isActive: FieldRef<"OrganisationStructure", 'Boolean'>
    readonly createdAt: FieldRef<"OrganisationStructure", 'DateTime'>
    readonly updatedAt: FieldRef<"OrganisationStructure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrganisationStructure findUnique
   */
  export type OrganisationStructureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationStructure
     */
    select?: OrganisationStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationStructureInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationStructure to fetch.
     */
    where: OrganisationStructureWhereUniqueInput
  }

  /**
   * OrganisationStructure findUniqueOrThrow
   */
  export type OrganisationStructureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationStructure
     */
    select?: OrganisationStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationStructureInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationStructure to fetch.
     */
    where: OrganisationStructureWhereUniqueInput
  }

  /**
   * OrganisationStructure findFirst
   */
  export type OrganisationStructureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationStructure
     */
    select?: OrganisationStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationStructureInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationStructure to fetch.
     */
    where?: OrganisationStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationStructures to fetch.
     */
    orderBy?: OrganisationStructureOrderByWithRelationInput | OrganisationStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganisationStructures.
     */
    cursor?: OrganisationStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganisationStructures.
     */
    distinct?: OrganisationStructureScalarFieldEnum | OrganisationStructureScalarFieldEnum[]
  }

  /**
   * OrganisationStructure findFirstOrThrow
   */
  export type OrganisationStructureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationStructure
     */
    select?: OrganisationStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationStructureInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationStructure to fetch.
     */
    where?: OrganisationStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationStructures to fetch.
     */
    orderBy?: OrganisationStructureOrderByWithRelationInput | OrganisationStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganisationStructures.
     */
    cursor?: OrganisationStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganisationStructures.
     */
    distinct?: OrganisationStructureScalarFieldEnum | OrganisationStructureScalarFieldEnum[]
  }

  /**
   * OrganisationStructure findMany
   */
  export type OrganisationStructureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationStructure
     */
    select?: OrganisationStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationStructureInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationStructures to fetch.
     */
    where?: OrganisationStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationStructures to fetch.
     */
    orderBy?: OrganisationStructureOrderByWithRelationInput | OrganisationStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganisationStructures.
     */
    cursor?: OrganisationStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationStructures.
     */
    skip?: number
    distinct?: OrganisationStructureScalarFieldEnum | OrganisationStructureScalarFieldEnum[]
  }

  /**
   * OrganisationStructure create
   */
  export type OrganisationStructureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationStructure
     */
    select?: OrganisationStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationStructureInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganisationStructure.
     */
    data: XOR<OrganisationStructureCreateInput, OrganisationStructureUncheckedCreateInput>
  }

  /**
   * OrganisationStructure createMany
   */
  export type OrganisationStructureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganisationStructures.
     */
    data: OrganisationStructureCreateManyInput | OrganisationStructureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganisationStructure update
   */
  export type OrganisationStructureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationStructure
     */
    select?: OrganisationStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationStructureInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganisationStructure.
     */
    data: XOR<OrganisationStructureUpdateInput, OrganisationStructureUncheckedUpdateInput>
    /**
     * Choose, which OrganisationStructure to update.
     */
    where: OrganisationStructureWhereUniqueInput
  }

  /**
   * OrganisationStructure updateMany
   */
  export type OrganisationStructureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganisationStructures.
     */
    data: XOR<OrganisationStructureUpdateManyMutationInput, OrganisationStructureUncheckedUpdateManyInput>
    /**
     * Filter which OrganisationStructures to update
     */
    where?: OrganisationStructureWhereInput
  }

  /**
   * OrganisationStructure upsert
   */
  export type OrganisationStructureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationStructure
     */
    select?: OrganisationStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationStructureInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganisationStructure to update in case it exists.
     */
    where: OrganisationStructureWhereUniqueInput
    /**
     * In case the OrganisationStructure found by the `where` argument doesn't exist, create a new OrganisationStructure with this data.
     */
    create: XOR<OrganisationStructureCreateInput, OrganisationStructureUncheckedCreateInput>
    /**
     * In case the OrganisationStructure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganisationStructureUpdateInput, OrganisationStructureUncheckedUpdateInput>
  }

  /**
   * OrganisationStructure delete
   */
  export type OrganisationStructureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationStructure
     */
    select?: OrganisationStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationStructureInclude<ExtArgs> | null
    /**
     * Filter which OrganisationStructure to delete.
     */
    where: OrganisationStructureWhereUniqueInput
  }

  /**
   * OrganisationStructure deleteMany
   */
  export type OrganisationStructureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganisationStructures to delete
     */
    where?: OrganisationStructureWhereInput
  }

  /**
   * OrganisationStructure.Team
   */
  export type OrganisationStructure$TeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * OrganisationStructure.OrganisationRole
   */
  export type OrganisationStructure$OrganisationRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationRole
     */
    select?: OrganisationRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationRoleInclude<ExtArgs> | null
    where?: OrganisationRoleWhereInput
    orderBy?: OrganisationRoleOrderByWithRelationInput | OrganisationRoleOrderByWithRelationInput[]
    cursor?: OrganisationRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganisationRoleScalarFieldEnum | OrganisationRoleScalarFieldEnum[]
  }

  /**
   * OrganisationStructure.QuestionAnswer
   */
  export type OrganisationStructure$QuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    where?: QuestionAnswerWhereInput
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    cursor?: QuestionAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * OrganisationStructure without action
   */
  export type OrganisationStructureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationStructure
     */
    select?: OrganisationStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationStructureInclude<ExtArgs> | null
  }


  /**
   * Model OrganisationTemplate
   */

  export type AggregateOrganisationTemplate = {
    _count: OrganisationTemplateCountAggregateOutputType | null
    _avg: OrganisationTemplateAvgAggregateOutputType | null
    _sum: OrganisationTemplateSumAggregateOutputType | null
    _min: OrganisationTemplateMinAggregateOutputType | null
    _max: OrganisationTemplateMaxAggregateOutputType | null
  }

  export type OrganisationTemplateAvgAggregateOutputType = {
    id: number | null
    organisationId: number | null
    templateId: number | null
  }

  export type OrganisationTemplateSumAggregateOutputType = {
    id: number | null
    organisationId: number | null
    templateId: number | null
  }

  export type OrganisationTemplateMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    logo: string | null
    organisationId: number | null
    password: string | null
    rememberToken: string | null
    isActive: boolean | null
    secretToken: string | null
    tfaToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    templateId: number | null
  }

  export type OrganisationTemplateMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    logo: string | null
    organisationId: number | null
    password: string | null
    rememberToken: string | null
    isActive: boolean | null
    secretToken: string | null
    tfaToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    templateId: number | null
  }

  export type OrganisationTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    logo: number
    organisationId: number
    password: number
    rememberToken: number
    isActive: number
    secretToken: number
    tfaToken: number
    createdAt: number
    updatedAt: number
    templateId: number
    _all: number
  }


  export type OrganisationTemplateAvgAggregateInputType = {
    id?: true
    organisationId?: true
    templateId?: true
  }

  export type OrganisationTemplateSumAggregateInputType = {
    id?: true
    organisationId?: true
    templateId?: true
  }

  export type OrganisationTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logo?: true
    organisationId?: true
    password?: true
    rememberToken?: true
    isActive?: true
    secretToken?: true
    tfaToken?: true
    createdAt?: true
    updatedAt?: true
    templateId?: true
  }

  export type OrganisationTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logo?: true
    organisationId?: true
    password?: true
    rememberToken?: true
    isActive?: true
    secretToken?: true
    tfaToken?: true
    createdAt?: true
    updatedAt?: true
    templateId?: true
  }

  export type OrganisationTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logo?: true
    organisationId?: true
    password?: true
    rememberToken?: true
    isActive?: true
    secretToken?: true
    tfaToken?: true
    createdAt?: true
    updatedAt?: true
    templateId?: true
    _all?: true
  }

  export type OrganisationTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganisationTemplate to aggregate.
     */
    where?: OrganisationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationTemplates to fetch.
     */
    orderBy?: OrganisationTemplateOrderByWithRelationInput | OrganisationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganisationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganisationTemplates
    **/
    _count?: true | OrganisationTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganisationTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganisationTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganisationTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganisationTemplateMaxAggregateInputType
  }

  export type GetOrganisationTemplateAggregateType<T extends OrganisationTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganisationTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganisationTemplate[P]>
      : GetScalarType<T[P], AggregateOrganisationTemplate[P]>
  }




  export type OrganisationTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationTemplateWhereInput
    orderBy?: OrganisationTemplateOrderByWithAggregationInput | OrganisationTemplateOrderByWithAggregationInput[]
    by: OrganisationTemplateScalarFieldEnum[] | OrganisationTemplateScalarFieldEnum
    having?: OrganisationTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganisationTemplateCountAggregateInputType | true
    _avg?: OrganisationTemplateAvgAggregateInputType
    _sum?: OrganisationTemplateSumAggregateInputType
    _min?: OrganisationTemplateMinAggregateInputType
    _max?: OrganisationTemplateMaxAggregateInputType
  }

  export type OrganisationTemplateGroupByOutputType = {
    id: number
    name: string
    description: string | null
    logo: string | null
    organisationId: number
    password: string | null
    rememberToken: string | null
    isActive: boolean
    secretToken: string | null
    tfaToken: string | null
    createdAt: Date
    updatedAt: Date
    templateId: number
    _count: OrganisationTemplateCountAggregateOutputType | null
    _avg: OrganisationTemplateAvgAggregateOutputType | null
    _sum: OrganisationTemplateSumAggregateOutputType | null
    _min: OrganisationTemplateMinAggregateOutputType | null
    _max: OrganisationTemplateMaxAggregateOutputType | null
  }

  type GetOrganisationTemplateGroupByPayload<T extends OrganisationTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganisationTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganisationTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganisationTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], OrganisationTemplateGroupByOutputType[P]>
        }
      >
    >


  export type OrganisationTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    logo?: boolean
    organisationId?: boolean
    password?: boolean
    rememberToken?: boolean
    isActive?: boolean
    secretToken?: boolean
    tfaToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    templateId?: boolean
    Organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    Template?: boolean | OrganisationTemplate$TemplateArgs<ExtArgs>
    Assessment?: boolean | OrganisationTemplate$AssessmentArgs<ExtArgs>
    _count?: boolean | OrganisationTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organisationTemplate"]>


  export type OrganisationTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    logo?: boolean
    organisationId?: boolean
    password?: boolean
    rememberToken?: boolean
    isActive?: boolean
    secretToken?: boolean
    tfaToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    templateId?: boolean
  }

  export type OrganisationTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    Template?: boolean | OrganisationTemplate$TemplateArgs<ExtArgs>
    Assessment?: boolean | OrganisationTemplate$AssessmentArgs<ExtArgs>
    _count?: boolean | OrganisationTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrganisationTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganisationTemplate"
    objects: {
      Organisation: Prisma.$OrganisationPayload<ExtArgs>
      Template: Prisma.$TemplatePayload<ExtArgs> | null
      Assessment: Prisma.$AssessmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      logo: string | null
      organisationId: number
      password: string | null
      rememberToken: string | null
      isActive: boolean
      secretToken: string | null
      tfaToken: string | null
      createdAt: Date
      updatedAt: Date
      templateId: number
    }, ExtArgs["result"]["organisationTemplate"]>
    composites: {}
  }

  type OrganisationTemplateGetPayload<S extends boolean | null | undefined | OrganisationTemplateDefaultArgs> = $Result.GetResult<Prisma.$OrganisationTemplatePayload, S>

  type OrganisationTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganisationTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganisationTemplateCountAggregateInputType | true
    }

  export interface OrganisationTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganisationTemplate'], meta: { name: 'OrganisationTemplate' } }
    /**
     * Find zero or one OrganisationTemplate that matches the filter.
     * @param {OrganisationTemplateFindUniqueArgs} args - Arguments to find a OrganisationTemplate
     * @example
     * // Get one OrganisationTemplate
     * const organisationTemplate = await prisma.organisationTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganisationTemplateFindUniqueArgs>(args: SelectSubset<T, OrganisationTemplateFindUniqueArgs<ExtArgs>>): Prisma__OrganisationTemplateClient<$Result.GetResult<Prisma.$OrganisationTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrganisationTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganisationTemplateFindUniqueOrThrowArgs} args - Arguments to find a OrganisationTemplate
     * @example
     * // Get one OrganisationTemplate
     * const organisationTemplate = await prisma.organisationTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganisationTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganisationTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganisationTemplateClient<$Result.GetResult<Prisma.$OrganisationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrganisationTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationTemplateFindFirstArgs} args - Arguments to find a OrganisationTemplate
     * @example
     * // Get one OrganisationTemplate
     * const organisationTemplate = await prisma.organisationTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganisationTemplateFindFirstArgs>(args?: SelectSubset<T, OrganisationTemplateFindFirstArgs<ExtArgs>>): Prisma__OrganisationTemplateClient<$Result.GetResult<Prisma.$OrganisationTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrganisationTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationTemplateFindFirstOrThrowArgs} args - Arguments to find a OrganisationTemplate
     * @example
     * // Get one OrganisationTemplate
     * const organisationTemplate = await prisma.organisationTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganisationTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganisationTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganisationTemplateClient<$Result.GetResult<Prisma.$OrganisationTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrganisationTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganisationTemplates
     * const organisationTemplates = await prisma.organisationTemplate.findMany()
     * 
     * // Get first 10 OrganisationTemplates
     * const organisationTemplates = await prisma.organisationTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organisationTemplateWithIdOnly = await prisma.organisationTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganisationTemplateFindManyArgs>(args?: SelectSubset<T, OrganisationTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrganisationTemplate.
     * @param {OrganisationTemplateCreateArgs} args - Arguments to create a OrganisationTemplate.
     * @example
     * // Create one OrganisationTemplate
     * const OrganisationTemplate = await prisma.organisationTemplate.create({
     *   data: {
     *     // ... data to create a OrganisationTemplate
     *   }
     * })
     * 
     */
    create<T extends OrganisationTemplateCreateArgs>(args: SelectSubset<T, OrganisationTemplateCreateArgs<ExtArgs>>): Prisma__OrganisationTemplateClient<$Result.GetResult<Prisma.$OrganisationTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrganisationTemplates.
     * @param {OrganisationTemplateCreateManyArgs} args - Arguments to create many OrganisationTemplates.
     * @example
     * // Create many OrganisationTemplates
     * const organisationTemplate = await prisma.organisationTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganisationTemplateCreateManyArgs>(args?: SelectSubset<T, OrganisationTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrganisationTemplate.
     * @param {OrganisationTemplateDeleteArgs} args - Arguments to delete one OrganisationTemplate.
     * @example
     * // Delete one OrganisationTemplate
     * const OrganisationTemplate = await prisma.organisationTemplate.delete({
     *   where: {
     *     // ... filter to delete one OrganisationTemplate
     *   }
     * })
     * 
     */
    delete<T extends OrganisationTemplateDeleteArgs>(args: SelectSubset<T, OrganisationTemplateDeleteArgs<ExtArgs>>): Prisma__OrganisationTemplateClient<$Result.GetResult<Prisma.$OrganisationTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrganisationTemplate.
     * @param {OrganisationTemplateUpdateArgs} args - Arguments to update one OrganisationTemplate.
     * @example
     * // Update one OrganisationTemplate
     * const organisationTemplate = await prisma.organisationTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganisationTemplateUpdateArgs>(args: SelectSubset<T, OrganisationTemplateUpdateArgs<ExtArgs>>): Prisma__OrganisationTemplateClient<$Result.GetResult<Prisma.$OrganisationTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrganisationTemplates.
     * @param {OrganisationTemplateDeleteManyArgs} args - Arguments to filter OrganisationTemplates to delete.
     * @example
     * // Delete a few OrganisationTemplates
     * const { count } = await prisma.organisationTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganisationTemplateDeleteManyArgs>(args?: SelectSubset<T, OrganisationTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganisationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganisationTemplates
     * const organisationTemplate = await prisma.organisationTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganisationTemplateUpdateManyArgs>(args: SelectSubset<T, OrganisationTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrganisationTemplate.
     * @param {OrganisationTemplateUpsertArgs} args - Arguments to update or create a OrganisationTemplate.
     * @example
     * // Update or create a OrganisationTemplate
     * const organisationTemplate = await prisma.organisationTemplate.upsert({
     *   create: {
     *     // ... data to create a OrganisationTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganisationTemplate we want to update
     *   }
     * })
     */
    upsert<T extends OrganisationTemplateUpsertArgs>(args: SelectSubset<T, OrganisationTemplateUpsertArgs<ExtArgs>>): Prisma__OrganisationTemplateClient<$Result.GetResult<Prisma.$OrganisationTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrganisationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationTemplateCountArgs} args - Arguments to filter OrganisationTemplates to count.
     * @example
     * // Count the number of OrganisationTemplates
     * const count = await prisma.organisationTemplate.count({
     *   where: {
     *     // ... the filter for the OrganisationTemplates we want to count
     *   }
     * })
    **/
    count<T extends OrganisationTemplateCountArgs>(
      args?: Subset<T, OrganisationTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganisationTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganisationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganisationTemplateAggregateArgs>(args: Subset<T, OrganisationTemplateAggregateArgs>): Prisma.PrismaPromise<GetOrganisationTemplateAggregateType<T>>

    /**
     * Group by OrganisationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganisationTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganisationTemplateGroupByArgs['orderBy'] }
        : { orderBy?: OrganisationTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganisationTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganisationTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganisationTemplate model
   */
  readonly fields: OrganisationTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganisationTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganisationTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Template<T extends OrganisationTemplate$TemplateArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationTemplate$TemplateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Assessment<T extends OrganisationTemplate$AssessmentArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationTemplate$AssessmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganisationTemplate model
   */ 
  interface OrganisationTemplateFieldRefs {
    readonly id: FieldRef<"OrganisationTemplate", 'Int'>
    readonly name: FieldRef<"OrganisationTemplate", 'String'>
    readonly description: FieldRef<"OrganisationTemplate", 'String'>
    readonly logo: FieldRef<"OrganisationTemplate", 'String'>
    readonly organisationId: FieldRef<"OrganisationTemplate", 'Int'>
    readonly password: FieldRef<"OrganisationTemplate", 'String'>
    readonly rememberToken: FieldRef<"OrganisationTemplate", 'String'>
    readonly isActive: FieldRef<"OrganisationTemplate", 'Boolean'>
    readonly secretToken: FieldRef<"OrganisationTemplate", 'String'>
    readonly tfaToken: FieldRef<"OrganisationTemplate", 'String'>
    readonly createdAt: FieldRef<"OrganisationTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"OrganisationTemplate", 'DateTime'>
    readonly templateId: FieldRef<"OrganisationTemplate", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrganisationTemplate findUnique
   */
  export type OrganisationTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationTemplate
     */
    select?: OrganisationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationTemplate to fetch.
     */
    where: OrganisationTemplateWhereUniqueInput
  }

  /**
   * OrganisationTemplate findUniqueOrThrow
   */
  export type OrganisationTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationTemplate
     */
    select?: OrganisationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationTemplate to fetch.
     */
    where: OrganisationTemplateWhereUniqueInput
  }

  /**
   * OrganisationTemplate findFirst
   */
  export type OrganisationTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationTemplate
     */
    select?: OrganisationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationTemplate to fetch.
     */
    where?: OrganisationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationTemplates to fetch.
     */
    orderBy?: OrganisationTemplateOrderByWithRelationInput | OrganisationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganisationTemplates.
     */
    cursor?: OrganisationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganisationTemplates.
     */
    distinct?: OrganisationTemplateScalarFieldEnum | OrganisationTemplateScalarFieldEnum[]
  }

  /**
   * OrganisationTemplate findFirstOrThrow
   */
  export type OrganisationTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationTemplate
     */
    select?: OrganisationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationTemplate to fetch.
     */
    where?: OrganisationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationTemplates to fetch.
     */
    orderBy?: OrganisationTemplateOrderByWithRelationInput | OrganisationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganisationTemplates.
     */
    cursor?: OrganisationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganisationTemplates.
     */
    distinct?: OrganisationTemplateScalarFieldEnum | OrganisationTemplateScalarFieldEnum[]
  }

  /**
   * OrganisationTemplate findMany
   */
  export type OrganisationTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationTemplate
     */
    select?: OrganisationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationTemplates to fetch.
     */
    where?: OrganisationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationTemplates to fetch.
     */
    orderBy?: OrganisationTemplateOrderByWithRelationInput | OrganisationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganisationTemplates.
     */
    cursor?: OrganisationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationTemplates.
     */
    skip?: number
    distinct?: OrganisationTemplateScalarFieldEnum | OrganisationTemplateScalarFieldEnum[]
  }

  /**
   * OrganisationTemplate create
   */
  export type OrganisationTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationTemplate
     */
    select?: OrganisationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganisationTemplate.
     */
    data: XOR<OrganisationTemplateCreateInput, OrganisationTemplateUncheckedCreateInput>
  }

  /**
   * OrganisationTemplate createMany
   */
  export type OrganisationTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganisationTemplates.
     */
    data: OrganisationTemplateCreateManyInput | OrganisationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganisationTemplate update
   */
  export type OrganisationTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationTemplate
     */
    select?: OrganisationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganisationTemplate.
     */
    data: XOR<OrganisationTemplateUpdateInput, OrganisationTemplateUncheckedUpdateInput>
    /**
     * Choose, which OrganisationTemplate to update.
     */
    where: OrganisationTemplateWhereUniqueInput
  }

  /**
   * OrganisationTemplate updateMany
   */
  export type OrganisationTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganisationTemplates.
     */
    data: XOR<OrganisationTemplateUpdateManyMutationInput, OrganisationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which OrganisationTemplates to update
     */
    where?: OrganisationTemplateWhereInput
  }

  /**
   * OrganisationTemplate upsert
   */
  export type OrganisationTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationTemplate
     */
    select?: OrganisationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganisationTemplate to update in case it exists.
     */
    where: OrganisationTemplateWhereUniqueInput
    /**
     * In case the OrganisationTemplate found by the `where` argument doesn't exist, create a new OrganisationTemplate with this data.
     */
    create: XOR<OrganisationTemplateCreateInput, OrganisationTemplateUncheckedCreateInput>
    /**
     * In case the OrganisationTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganisationTemplateUpdateInput, OrganisationTemplateUncheckedUpdateInput>
  }

  /**
   * OrganisationTemplate delete
   */
  export type OrganisationTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationTemplate
     */
    select?: OrganisationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationTemplateInclude<ExtArgs> | null
    /**
     * Filter which OrganisationTemplate to delete.
     */
    where: OrganisationTemplateWhereUniqueInput
  }

  /**
   * OrganisationTemplate deleteMany
   */
  export type OrganisationTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganisationTemplates to delete
     */
    where?: OrganisationTemplateWhereInput
  }

  /**
   * OrganisationTemplate.Template
   */
  export type OrganisationTemplate$TemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    where?: TemplateWhereInput
  }

  /**
   * OrganisationTemplate.Assessment
   */
  export type OrganisationTemplate$AssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    where?: AssessmentWhereInput
    orderBy?: AssessmentOrderByWithRelationInput | AssessmentOrderByWithRelationInput[]
    cursor?: AssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * OrganisationTemplate without action
   */
  export type OrganisationTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationTemplate
     */
    select?: OrganisationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationTemplateInclude<ExtArgs> | null
  }


  /**
   * Model QuestionAnswer
   */

  export type AggregateQuestionAnswer = {
    _count: QuestionAnswerCountAggregateOutputType | null
    _avg: QuestionAnswerAvgAggregateOutputType | null
    _sum: QuestionAnswerSumAggregateOutputType | null
    _min: QuestionAnswerMinAggregateOutputType | null
    _max: QuestionAnswerMaxAggregateOutputType | null
  }

  export type QuestionAnswerAvgAggregateOutputType = {
    id: number | null
    organisationId: number | null
    organisationStructureId: number | null
    teamId: number | null
    userId: number | null
    assessmentTeamId: number | null
    assessmentId: number | null
    assessmentQuestionId: number | null
  }

  export type QuestionAnswerSumAggregateOutputType = {
    id: number | null
    organisationId: number | null
    organisationStructureId: number | null
    teamId: number | null
    userId: number | null
    assessmentTeamId: number | null
    assessmentId: number | null
    assessmentQuestionId: number | null
  }

  export type QuestionAnswerMinAggregateOutputType = {
    id: number | null
    organisationId: number | null
    organisationStructureId: number | null
    teamId: number | null
    userId: number | null
    assessmentTeamId: number | null
    assessmentId: number | null
    assessmentStage: string | null
    questionMongoId: string | null
    assessmentQuestionId: number | null
    password: string | null
    rememberToken: string | null
    notes: string | null
    isActive: boolean | null
    secretToken: string | null
    tfaToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionAnswerMaxAggregateOutputType = {
    id: number | null
    organisationId: number | null
    organisationStructureId: number | null
    teamId: number | null
    userId: number | null
    assessmentTeamId: number | null
    assessmentId: number | null
    assessmentStage: string | null
    questionMongoId: string | null
    assessmentQuestionId: number | null
    password: string | null
    rememberToken: string | null
    notes: string | null
    isActive: boolean | null
    secretToken: string | null
    tfaToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionAnswerCountAggregateOutputType = {
    id: number
    organisationId: number
    organisationStructureId: number
    teamId: number
    userId: number
    assessmentTeamId: number
    assessmentId: number
    assessmentStage: number
    questionMongoId: number
    assessmentQuestionId: number
    password: number
    rememberToken: number
    notes: number
    isActive: number
    secretToken: number
    tfaToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionAnswerAvgAggregateInputType = {
    id?: true
    organisationId?: true
    organisationStructureId?: true
    teamId?: true
    userId?: true
    assessmentTeamId?: true
    assessmentId?: true
    assessmentQuestionId?: true
  }

  export type QuestionAnswerSumAggregateInputType = {
    id?: true
    organisationId?: true
    organisationStructureId?: true
    teamId?: true
    userId?: true
    assessmentTeamId?: true
    assessmentId?: true
    assessmentQuestionId?: true
  }

  export type QuestionAnswerMinAggregateInputType = {
    id?: true
    organisationId?: true
    organisationStructureId?: true
    teamId?: true
    userId?: true
    assessmentTeamId?: true
    assessmentId?: true
    assessmentStage?: true
    questionMongoId?: true
    assessmentQuestionId?: true
    password?: true
    rememberToken?: true
    notes?: true
    isActive?: true
    secretToken?: true
    tfaToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionAnswerMaxAggregateInputType = {
    id?: true
    organisationId?: true
    organisationStructureId?: true
    teamId?: true
    userId?: true
    assessmentTeamId?: true
    assessmentId?: true
    assessmentStage?: true
    questionMongoId?: true
    assessmentQuestionId?: true
    password?: true
    rememberToken?: true
    notes?: true
    isActive?: true
    secretToken?: true
    tfaToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionAnswerCountAggregateInputType = {
    id?: true
    organisationId?: true
    organisationStructureId?: true
    teamId?: true
    userId?: true
    assessmentTeamId?: true
    assessmentId?: true
    assessmentStage?: true
    questionMongoId?: true
    assessmentQuestionId?: true
    password?: true
    rememberToken?: true
    notes?: true
    isActive?: true
    secretToken?: true
    tfaToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionAnswer to aggregate.
     */
    where?: QuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnswers to fetch.
     */
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionAnswers
    **/
    _count?: true | QuestionAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionAnswerMaxAggregateInputType
  }

  export type GetQuestionAnswerAggregateType<T extends QuestionAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionAnswer[P]>
      : GetScalarType<T[P], AggregateQuestionAnswer[P]>
  }




  export type QuestionAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAnswerWhereInput
    orderBy?: QuestionAnswerOrderByWithAggregationInput | QuestionAnswerOrderByWithAggregationInput[]
    by: QuestionAnswerScalarFieldEnum[] | QuestionAnswerScalarFieldEnum
    having?: QuestionAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionAnswerCountAggregateInputType | true
    _avg?: QuestionAnswerAvgAggregateInputType
    _sum?: QuestionAnswerSumAggregateInputType
    _min?: QuestionAnswerMinAggregateInputType
    _max?: QuestionAnswerMaxAggregateInputType
  }

  export type QuestionAnswerGroupByOutputType = {
    id: number
    organisationId: number | null
    organisationStructureId: number | null
    teamId: number | null
    userId: number | null
    assessmentTeamId: number | null
    assessmentId: number | null
    assessmentStage: string
    questionMongoId: string
    assessmentQuestionId: number | null
    password: string | null
    rememberToken: string | null
    notes: string | null
    isActive: boolean
    secretToken: string | null
    tfaToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: QuestionAnswerCountAggregateOutputType | null
    _avg: QuestionAnswerAvgAggregateOutputType | null
    _sum: QuestionAnswerSumAggregateOutputType | null
    _min: QuestionAnswerMinAggregateOutputType | null
    _max: QuestionAnswerMaxAggregateOutputType | null
  }

  type GetQuestionAnswerGroupByPayload<T extends QuestionAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionAnswerGroupByOutputType[P]>
        }
      >
    >


  export type QuestionAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organisationId?: boolean
    organisationStructureId?: boolean
    teamId?: boolean
    userId?: boolean
    assessmentTeamId?: boolean
    assessmentId?: boolean
    assessmentStage?: boolean
    questionMongoId?: boolean
    assessmentQuestionId?: boolean
    password?: boolean
    rememberToken?: boolean
    notes?: boolean
    isActive?: boolean
    secretToken?: boolean
    tfaToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Organisation?: boolean | QuestionAnswer$OrganisationArgs<ExtArgs>
    OrganisationStructure?: boolean | QuestionAnswer$OrganisationStructureArgs<ExtArgs>
    Team?: boolean | QuestionAnswer$TeamArgs<ExtArgs>
    User?: boolean | QuestionAnswer$UserArgs<ExtArgs>
    AssessmentTeam?: boolean | QuestionAnswer$AssessmentTeamArgs<ExtArgs>
    Assessment?: boolean | QuestionAnswer$AssessmentArgs<ExtArgs>
    AssessmentQuestion?: boolean | QuestionAnswer$AssessmentQuestionArgs<ExtArgs>
  }, ExtArgs["result"]["questionAnswer"]>


  export type QuestionAnswerSelectScalar = {
    id?: boolean
    organisationId?: boolean
    organisationStructureId?: boolean
    teamId?: boolean
    userId?: boolean
    assessmentTeamId?: boolean
    assessmentId?: boolean
    assessmentStage?: boolean
    questionMongoId?: boolean
    assessmentQuestionId?: boolean
    password?: boolean
    rememberToken?: boolean
    notes?: boolean
    isActive?: boolean
    secretToken?: boolean
    tfaToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuestionAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organisation?: boolean | QuestionAnswer$OrganisationArgs<ExtArgs>
    OrganisationStructure?: boolean | QuestionAnswer$OrganisationStructureArgs<ExtArgs>
    Team?: boolean | QuestionAnswer$TeamArgs<ExtArgs>
    User?: boolean | QuestionAnswer$UserArgs<ExtArgs>
    AssessmentTeam?: boolean | QuestionAnswer$AssessmentTeamArgs<ExtArgs>
    Assessment?: boolean | QuestionAnswer$AssessmentArgs<ExtArgs>
    AssessmentQuestion?: boolean | QuestionAnswer$AssessmentQuestionArgs<ExtArgs>
  }

  export type $QuestionAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionAnswer"
    objects: {
      Organisation: Prisma.$OrganisationPayload<ExtArgs> | null
      OrganisationStructure: Prisma.$OrganisationStructurePayload<ExtArgs> | null
      Team: Prisma.$TeamPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs> | null
      AssessmentTeam: Prisma.$AssessmentTeamPayload<ExtArgs> | null
      Assessment: Prisma.$AssessmentPayload<ExtArgs> | null
      AssessmentQuestion: Prisma.$AssessmentQuestionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      organisationId: number | null
      organisationStructureId: number | null
      teamId: number | null
      userId: number | null
      assessmentTeamId: number | null
      assessmentId: number | null
      assessmentStage: string
      questionMongoId: string
      assessmentQuestionId: number | null
      password: string | null
      rememberToken: string | null
      notes: string | null
      isActive: boolean
      secretToken: string | null
      tfaToken: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["questionAnswer"]>
    composites: {}
  }

  type QuestionAnswerGetPayload<S extends boolean | null | undefined | QuestionAnswerDefaultArgs> = $Result.GetResult<Prisma.$QuestionAnswerPayload, S>

  type QuestionAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionAnswerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionAnswerCountAggregateInputType | true
    }

  export interface QuestionAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionAnswer'], meta: { name: 'QuestionAnswer' } }
    /**
     * Find zero or one QuestionAnswer that matches the filter.
     * @param {QuestionAnswerFindUniqueArgs} args - Arguments to find a QuestionAnswer
     * @example
     * // Get one QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionAnswerFindUniqueArgs>(args: SelectSubset<T, QuestionAnswerFindUniqueArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuestionAnswer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionAnswerFindUniqueOrThrowArgs} args - Arguments to find a QuestionAnswer
     * @example
     * // Get one QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuestionAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerFindFirstArgs} args - Arguments to find a QuestionAnswer
     * @example
     * // Get one QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionAnswerFindFirstArgs>(args?: SelectSubset<T, QuestionAnswerFindFirstArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuestionAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerFindFirstOrThrowArgs} args - Arguments to find a QuestionAnswer
     * @example
     * // Get one QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuestionAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionAnswers
     * const questionAnswers = await prisma.questionAnswer.findMany()
     * 
     * // Get first 10 QuestionAnswers
     * const questionAnswers = await prisma.questionAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionAnswerWithIdOnly = await prisma.questionAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionAnswerFindManyArgs>(args?: SelectSubset<T, QuestionAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuestionAnswer.
     * @param {QuestionAnswerCreateArgs} args - Arguments to create a QuestionAnswer.
     * @example
     * // Create one QuestionAnswer
     * const QuestionAnswer = await prisma.questionAnswer.create({
     *   data: {
     *     // ... data to create a QuestionAnswer
     *   }
     * })
     * 
     */
    create<T extends QuestionAnswerCreateArgs>(args: SelectSubset<T, QuestionAnswerCreateArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuestionAnswers.
     * @param {QuestionAnswerCreateManyArgs} args - Arguments to create many QuestionAnswers.
     * @example
     * // Create many QuestionAnswers
     * const questionAnswer = await prisma.questionAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionAnswerCreateManyArgs>(args?: SelectSubset<T, QuestionAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionAnswer.
     * @param {QuestionAnswerDeleteArgs} args - Arguments to delete one QuestionAnswer.
     * @example
     * // Delete one QuestionAnswer
     * const QuestionAnswer = await prisma.questionAnswer.delete({
     *   where: {
     *     // ... filter to delete one QuestionAnswer
     *   }
     * })
     * 
     */
    delete<T extends QuestionAnswerDeleteArgs>(args: SelectSubset<T, QuestionAnswerDeleteArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuestionAnswer.
     * @param {QuestionAnswerUpdateArgs} args - Arguments to update one QuestionAnswer.
     * @example
     * // Update one QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionAnswerUpdateArgs>(args: SelectSubset<T, QuestionAnswerUpdateArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuestionAnswers.
     * @param {QuestionAnswerDeleteManyArgs} args - Arguments to filter QuestionAnswers to delete.
     * @example
     * // Delete a few QuestionAnswers
     * const { count } = await prisma.questionAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionAnswerDeleteManyArgs>(args?: SelectSubset<T, QuestionAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionAnswers
     * const questionAnswer = await prisma.questionAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionAnswerUpdateManyArgs>(args: SelectSubset<T, QuestionAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionAnswer.
     * @param {QuestionAnswerUpsertArgs} args - Arguments to update or create a QuestionAnswer.
     * @example
     * // Update or create a QuestionAnswer
     * const questionAnswer = await prisma.questionAnswer.upsert({
     *   create: {
     *     // ... data to create a QuestionAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionAnswer we want to update
     *   }
     * })
     */
    upsert<T extends QuestionAnswerUpsertArgs>(args: SelectSubset<T, QuestionAnswerUpsertArgs<ExtArgs>>): Prisma__QuestionAnswerClient<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuestionAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerCountArgs} args - Arguments to filter QuestionAnswers to count.
     * @example
     * // Count the number of QuestionAnswers
     * const count = await prisma.questionAnswer.count({
     *   where: {
     *     // ... the filter for the QuestionAnswers we want to count
     *   }
     * })
    **/
    count<T extends QuestionAnswerCountArgs>(
      args?: Subset<T, QuestionAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAnswerAggregateArgs>(args: Subset<T, QuestionAnswerAggregateArgs>): Prisma.PrismaPromise<GetQuestionAnswerAggregateType<T>>

    /**
     * Group by QuestionAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionAnswerGroupByArgs['orderBy'] }
        : { orderBy?: QuestionAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionAnswer model
   */
  readonly fields: QuestionAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organisation<T extends QuestionAnswer$OrganisationArgs<ExtArgs> = {}>(args?: Subset<T, QuestionAnswer$OrganisationArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    OrganisationStructure<T extends QuestionAnswer$OrganisationStructureArgs<ExtArgs> = {}>(args?: Subset<T, QuestionAnswer$OrganisationStructureArgs<ExtArgs>>): Prisma__OrganisationStructureClient<$Result.GetResult<Prisma.$OrganisationStructurePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Team<T extends QuestionAnswer$TeamArgs<ExtArgs> = {}>(args?: Subset<T, QuestionAnswer$TeamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    User<T extends QuestionAnswer$UserArgs<ExtArgs> = {}>(args?: Subset<T, QuestionAnswer$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    AssessmentTeam<T extends QuestionAnswer$AssessmentTeamArgs<ExtArgs> = {}>(args?: Subset<T, QuestionAnswer$AssessmentTeamArgs<ExtArgs>>): Prisma__AssessmentTeamClient<$Result.GetResult<Prisma.$AssessmentTeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Assessment<T extends QuestionAnswer$AssessmentArgs<ExtArgs> = {}>(args?: Subset<T, QuestionAnswer$AssessmentArgs<ExtArgs>>): Prisma__AssessmentClient<$Result.GetResult<Prisma.$AssessmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    AssessmentQuestion<T extends QuestionAnswer$AssessmentQuestionArgs<ExtArgs> = {}>(args?: Subset<T, QuestionAnswer$AssessmentQuestionArgs<ExtArgs>>): Prisma__AssessmentQuestionClient<$Result.GetResult<Prisma.$AssessmentQuestionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionAnswer model
   */ 
  interface QuestionAnswerFieldRefs {
    readonly id: FieldRef<"QuestionAnswer", 'Int'>
    readonly organisationId: FieldRef<"QuestionAnswer", 'Int'>
    readonly organisationStructureId: FieldRef<"QuestionAnswer", 'Int'>
    readonly teamId: FieldRef<"QuestionAnswer", 'Int'>
    readonly userId: FieldRef<"QuestionAnswer", 'Int'>
    readonly assessmentTeamId: FieldRef<"QuestionAnswer", 'Int'>
    readonly assessmentId: FieldRef<"QuestionAnswer", 'Int'>
    readonly assessmentStage: FieldRef<"QuestionAnswer", 'String'>
    readonly questionMongoId: FieldRef<"QuestionAnswer", 'String'>
    readonly assessmentQuestionId: FieldRef<"QuestionAnswer", 'Int'>
    readonly password: FieldRef<"QuestionAnswer", 'String'>
    readonly rememberToken: FieldRef<"QuestionAnswer", 'String'>
    readonly notes: FieldRef<"QuestionAnswer", 'String'>
    readonly isActive: FieldRef<"QuestionAnswer", 'Boolean'>
    readonly secretToken: FieldRef<"QuestionAnswer", 'String'>
    readonly tfaToken: FieldRef<"QuestionAnswer", 'String'>
    readonly createdAt: FieldRef<"QuestionAnswer", 'DateTime'>
    readonly updatedAt: FieldRef<"QuestionAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuestionAnswer findUnique
   */
  export type QuestionAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAnswer to fetch.
     */
    where: QuestionAnswerWhereUniqueInput
  }

  /**
   * QuestionAnswer findUniqueOrThrow
   */
  export type QuestionAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAnswer to fetch.
     */
    where: QuestionAnswerWhereUniqueInput
  }

  /**
   * QuestionAnswer findFirst
   */
  export type QuestionAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAnswer to fetch.
     */
    where?: QuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnswers to fetch.
     */
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionAnswers.
     */
    cursor?: QuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionAnswers.
     */
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * QuestionAnswer findFirstOrThrow
   */
  export type QuestionAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAnswer to fetch.
     */
    where?: QuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnswers to fetch.
     */
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionAnswers.
     */
    cursor?: QuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionAnswers.
     */
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * QuestionAnswer findMany
   */
  export type QuestionAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAnswers to fetch.
     */
    where?: QuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnswers to fetch.
     */
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionAnswers.
     */
    cursor?: QuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnswers.
     */
    skip?: number
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * QuestionAnswer create
   */
  export type QuestionAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionAnswer.
     */
    data: XOR<QuestionAnswerCreateInput, QuestionAnswerUncheckedCreateInput>
  }

  /**
   * QuestionAnswer createMany
   */
  export type QuestionAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionAnswers.
     */
    data: QuestionAnswerCreateManyInput | QuestionAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionAnswer update
   */
  export type QuestionAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionAnswer.
     */
    data: XOR<QuestionAnswerUpdateInput, QuestionAnswerUncheckedUpdateInput>
    /**
     * Choose, which QuestionAnswer to update.
     */
    where: QuestionAnswerWhereUniqueInput
  }

  /**
   * QuestionAnswer updateMany
   */
  export type QuestionAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionAnswers.
     */
    data: XOR<QuestionAnswerUpdateManyMutationInput, QuestionAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuestionAnswers to update
     */
    where?: QuestionAnswerWhereInput
  }

  /**
   * QuestionAnswer upsert
   */
  export type QuestionAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionAnswer to update in case it exists.
     */
    where: QuestionAnswerWhereUniqueInput
    /**
     * In case the QuestionAnswer found by the `where` argument doesn't exist, create a new QuestionAnswer with this data.
     */
    create: XOR<QuestionAnswerCreateInput, QuestionAnswerUncheckedCreateInput>
    /**
     * In case the QuestionAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionAnswerUpdateInput, QuestionAnswerUncheckedUpdateInput>
  }

  /**
   * QuestionAnswer delete
   */
  export type QuestionAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter which QuestionAnswer to delete.
     */
    where: QuestionAnswerWhereUniqueInput
  }

  /**
   * QuestionAnswer deleteMany
   */
  export type QuestionAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionAnswers to delete
     */
    where?: QuestionAnswerWhereInput
  }

  /**
   * QuestionAnswer.Organisation
   */
  export type QuestionAnswer$OrganisationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    where?: OrganisationWhereInput
  }

  /**
   * QuestionAnswer.OrganisationStructure
   */
  export type QuestionAnswer$OrganisationStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationStructure
     */
    select?: OrganisationStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationStructureInclude<ExtArgs> | null
    where?: OrganisationStructureWhereInput
  }

  /**
   * QuestionAnswer.Team
   */
  export type QuestionAnswer$TeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * QuestionAnswer.User
   */
  export type QuestionAnswer$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * QuestionAnswer.AssessmentTeam
   */
  export type QuestionAnswer$AssessmentTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTeam
     */
    select?: AssessmentTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTeamInclude<ExtArgs> | null
    where?: AssessmentTeamWhereInput
  }

  /**
   * QuestionAnswer.Assessment
   */
  export type QuestionAnswer$AssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assessment
     */
    select?: AssessmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentInclude<ExtArgs> | null
    where?: AssessmentWhereInput
  }

  /**
   * QuestionAnswer.AssessmentQuestion
   */
  export type QuestionAnswer$AssessmentQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentQuestion
     */
    select?: AssessmentQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentQuestionInclude<ExtArgs> | null
    where?: AssessmentQuestionWhereInput
  }

  /**
   * QuestionAnswer without action
   */
  export type QuestionAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    description: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    UserRole?: boolean | Role$UserRoleArgs<ExtArgs>
    OrganisationRole?: boolean | Role$OrganisationRoleArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>


  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserRole?: boolean | Role$UserRoleArgs<ExtArgs>
    OrganisationRole?: boolean | Role$OrganisationRoleArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      UserRole: Prisma.$UserRolePayload<ExtArgs>[]
      OrganisationRole: Prisma.$OrganisationRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UserRole<T extends Role$UserRoleArgs<ExtArgs> = {}>(args?: Subset<T, Role$UserRoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    OrganisationRole<T extends Role$OrganisationRoleArgs<ExtArgs> = {}>(args?: Subset<T, Role$OrganisationRoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly isActive: FieldRef<"Role", 'Boolean'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.UserRole
   */
  export type Role$UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role.OrganisationRole
   */
  export type Role$OrganisationRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationRole
     */
    select?: OrganisationRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationRoleInclude<ExtArgs> | null
    where?: OrganisationRoleWhereInput
    orderBy?: OrganisationRoleOrderByWithRelationInput | OrganisationRoleOrderByWithRelationInput[]
    cursor?: OrganisationRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganisationRoleScalarFieldEnum | OrganisationRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    id: number | null
    organisationId: number | null
  }

  export type TeamSumAggregateOutputType = {
    id: number | null
    organisationId: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    logo: string | null
    organisationId: number | null
    password: string | null
    rememberToken: string | null
    isActive: boolean | null
    secretToken: string | null
    tfaToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    logo: string | null
    organisationId: number | null
    password: string | null
    rememberToken: string | null
    isActive: boolean | null
    secretToken: string | null
    tfaToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    description: number
    logo: number
    organisationId: number
    password: number
    rememberToken: number
    isActive: number
    secretToken: number
    tfaToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    id?: true
    organisationId?: true
  }

  export type TeamSumAggregateInputType = {
    id?: true
    organisationId?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logo?: true
    organisationId?: true
    password?: true
    rememberToken?: true
    isActive?: true
    secretToken?: true
    tfaToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logo?: true
    organisationId?: true
    password?: true
    rememberToken?: true
    isActive?: true
    secretToken?: true
    tfaToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logo?: true
    organisationId?: true
    password?: true
    rememberToken?: true
    isActive?: true
    secretToken?: true
    tfaToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: number
    name: string
    description: string | null
    logo: string | null
    organisationId: number
    password: string | null
    rememberToken: string | null
    isActive: boolean
    secretToken: string | null
    tfaToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    logo?: boolean
    organisationId?: boolean
    password?: boolean
    rememberToken?: boolean
    isActive?: boolean
    secretToken?: boolean
    tfaToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    OrganisationStructure?: boolean | Team$OrganisationStructureArgs<ExtArgs>
    AssessmentTeam?: boolean | Team$AssessmentTeamArgs<ExtArgs>
    QuestionAnswer?: boolean | Team$QuestionAnswerArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>


  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    logo?: boolean
    organisationId?: boolean
    password?: boolean
    rememberToken?: boolean
    isActive?: boolean
    secretToken?: boolean
    tfaToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    OrganisationStructure?: boolean | Team$OrganisationStructureArgs<ExtArgs>
    AssessmentTeam?: boolean | Team$AssessmentTeamArgs<ExtArgs>
    QuestionAnswer?: boolean | Team$QuestionAnswerArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      Organisation: Prisma.$OrganisationPayload<ExtArgs>
      OrganisationStructure: Prisma.$OrganisationStructurePayload<ExtArgs>[]
      AssessmentTeam: Prisma.$AssessmentTeamPayload<ExtArgs>[]
      QuestionAnswer: Prisma.$QuestionAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      logo: string | null
      organisationId: number
      password: string | null
      rememberToken: string | null
      isActive: boolean
      secretToken: string | null
      tfaToken: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    OrganisationStructure<T extends Team$OrganisationStructureArgs<ExtArgs> = {}>(args?: Subset<T, Team$OrganisationStructureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationStructurePayload<ExtArgs>, T, "findMany"> | Null>
    AssessmentTeam<T extends Team$AssessmentTeamArgs<ExtArgs> = {}>(args?: Subset<T, Team$AssessmentTeamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentTeamPayload<ExtArgs>, T, "findMany"> | Null>
    QuestionAnswer<T extends Team$QuestionAnswerArgs<ExtArgs> = {}>(args?: Subset<T, Team$QuestionAnswerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */ 
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'Int'>
    readonly name: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly logo: FieldRef<"Team", 'String'>
    readonly organisationId: FieldRef<"Team", 'Int'>
    readonly password: FieldRef<"Team", 'String'>
    readonly rememberToken: FieldRef<"Team", 'String'>
    readonly isActive: FieldRef<"Team", 'Boolean'>
    readonly secretToken: FieldRef<"Team", 'String'>
    readonly tfaToken: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
  }

  /**
   * Team.OrganisationStructure
   */
  export type Team$OrganisationStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationStructure
     */
    select?: OrganisationStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationStructureInclude<ExtArgs> | null
    where?: OrganisationStructureWhereInput
    orderBy?: OrganisationStructureOrderByWithRelationInput | OrganisationStructureOrderByWithRelationInput[]
    cursor?: OrganisationStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganisationStructureScalarFieldEnum | OrganisationStructureScalarFieldEnum[]
  }

  /**
   * Team.AssessmentTeam
   */
  export type Team$AssessmentTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTeam
     */
    select?: AssessmentTeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTeamInclude<ExtArgs> | null
    where?: AssessmentTeamWhereInput
    orderBy?: AssessmentTeamOrderByWithRelationInput | AssessmentTeamOrderByWithRelationInput[]
    cursor?: AssessmentTeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentTeamScalarFieldEnum | AssessmentTeamScalarFieldEnum[]
  }

  /**
   * Team.QuestionAnswer
   */
  export type Team$QuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    where?: QuestionAnswerWhereInput
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    cursor?: QuestionAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Template
   */

  export type AggregateTemplate = {
    _count: TemplateCountAggregateOutputType | null
    _avg: TemplateAvgAggregateOutputType | null
    _sum: TemplateSumAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  export type TemplateAvgAggregateOutputType = {
    id: number | null
  }

  export type TemplateSumAggregateOutputType = {
    id: number | null
  }

  export type TemplateMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemplateAvgAggregateInputType = {
    id?: true
  }

  export type TemplateSumAggregateInputType = {
    id?: true
  }

  export type TemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Template to aggregate.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Templates
    **/
    _count?: true | TemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateMaxAggregateInputType
  }

  export type GetTemplateAggregateType<T extends TemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplate[P]>
      : GetScalarType<T[P], AggregateTemplate[P]>
  }




  export type TemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithAggregationInput | TemplateOrderByWithAggregationInput[]
    by: TemplateScalarFieldEnum[] | TemplateScalarFieldEnum
    having?: TemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateCountAggregateInputType | true
    _avg?: TemplateAvgAggregateInputType
    _sum?: TemplateSumAggregateInputType
    _min?: TemplateMinAggregateInputType
    _max?: TemplateMaxAggregateInputType
  }

  export type TemplateGroupByOutputType = {
    id: number
    name: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TemplateCountAggregateOutputType | null
    _avg: TemplateAvgAggregateOutputType | null
    _sum: TemplateSumAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  type GetTemplateGroupByPayload<T extends TemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    TemplateStage?: boolean | Template$TemplateStageArgs<ExtArgs>
    OrganisationTemplate?: boolean | Template$OrganisationTemplateArgs<ExtArgs>
    _count?: boolean | TemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["template"]>


  export type TemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TemplateStage?: boolean | Template$TemplateStageArgs<ExtArgs>
    OrganisationTemplate?: boolean | Template$OrganisationTemplateArgs<ExtArgs>
    _count?: boolean | TemplateCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Template"
    objects: {
      TemplateStage: Prisma.$TemplateStagePayload<ExtArgs>[]
      OrganisationTemplate: Prisma.$OrganisationTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["template"]>
    composites: {}
  }

  type TemplateGetPayload<S extends boolean | null | undefined | TemplateDefaultArgs> = $Result.GetResult<Prisma.$TemplatePayload, S>

  type TemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplateCountAggregateInputType | true
    }

  export interface TemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Template'], meta: { name: 'Template' } }
    /**
     * Find zero or one Template that matches the filter.
     * @param {TemplateFindUniqueArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateFindUniqueArgs>(args: SelectSubset<T, TemplateFindUniqueArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Template that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TemplateFindUniqueOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Template that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateFindFirstArgs>(args?: SelectSubset<T, TemplateFindFirstArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Template that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Templates
     * const templates = await prisma.template.findMany()
     * 
     * // Get first 10 Templates
     * const templates = await prisma.template.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateWithIdOnly = await prisma.template.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateFindManyArgs>(args?: SelectSubset<T, TemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Template.
     * @param {TemplateCreateArgs} args - Arguments to create a Template.
     * @example
     * // Create one Template
     * const Template = await prisma.template.create({
     *   data: {
     *     // ... data to create a Template
     *   }
     * })
     * 
     */
    create<T extends TemplateCreateArgs>(args: SelectSubset<T, TemplateCreateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Templates.
     * @param {TemplateCreateManyArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const template = await prisma.template.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateCreateManyArgs>(args?: SelectSubset<T, TemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Template.
     * @param {TemplateDeleteArgs} args - Arguments to delete one Template.
     * @example
     * // Delete one Template
     * const Template = await prisma.template.delete({
     *   where: {
     *     // ... filter to delete one Template
     *   }
     * })
     * 
     */
    delete<T extends TemplateDeleteArgs>(args: SelectSubset<T, TemplateDeleteArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Template.
     * @param {TemplateUpdateArgs} args - Arguments to update one Template.
     * @example
     * // Update one Template
     * const template = await prisma.template.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateUpdateArgs>(args: SelectSubset<T, TemplateUpdateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Templates.
     * @param {TemplateDeleteManyArgs} args - Arguments to filter Templates to delete.
     * @example
     * // Delete a few Templates
     * const { count } = await prisma.template.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateDeleteManyArgs>(args?: SelectSubset<T, TemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateUpdateManyArgs>(args: SelectSubset<T, TemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Template.
     * @param {TemplateUpsertArgs} args - Arguments to update or create a Template.
     * @example
     * // Update or create a Template
     * const template = await prisma.template.upsert({
     *   create: {
     *     // ... data to create a Template
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Template we want to update
     *   }
     * })
     */
    upsert<T extends TemplateUpsertArgs>(args: SelectSubset<T, TemplateUpsertArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCountArgs} args - Arguments to filter Templates to count.
     * @example
     * // Count the number of Templates
     * const count = await prisma.template.count({
     *   where: {
     *     // ... the filter for the Templates we want to count
     *   }
     * })
    **/
    count<T extends TemplateCountArgs>(
      args?: Subset<T, TemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateAggregateArgs>(args: Subset<T, TemplateAggregateArgs>): Prisma.PrismaPromise<GetTemplateAggregateType<T>>

    /**
     * Group by Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateGroupByArgs['orderBy'] }
        : { orderBy?: TemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Template model
   */
  readonly fields: TemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Template.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TemplateStage<T extends Template$TemplateStageArgs<ExtArgs> = {}>(args?: Subset<T, Template$TemplateStageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateStagePayload<ExtArgs>, T, "findMany"> | Null>
    OrganisationTemplate<T extends Template$OrganisationTemplateArgs<ExtArgs> = {}>(args?: Subset<T, Template$OrganisationTemplateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Template model
   */ 
  interface TemplateFieldRefs {
    readonly id: FieldRef<"Template", 'Int'>
    readonly name: FieldRef<"Template", 'String'>
    readonly description: FieldRef<"Template", 'String'>
    readonly isActive: FieldRef<"Template", 'Boolean'>
    readonly createdAt: FieldRef<"Template", 'DateTime'>
    readonly updatedAt: FieldRef<"Template", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Template findUnique
   */
  export type TemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findUniqueOrThrow
   */
  export type TemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findFirst
   */
  export type TemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findFirstOrThrow
   */
  export type TemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findMany
   */
  export type TemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Templates to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template create
   */
  export type TemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a Template.
     */
    data: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
  }

  /**
   * Template createMany
   */
  export type TemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Template update
   */
  export type TemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a Template.
     */
    data: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
    /**
     * Choose, which Template to update.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template updateMany
   */
  export type TemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
  }

  /**
   * Template upsert
   */
  export type TemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the Template to update in case it exists.
     */
    where: TemplateWhereUniqueInput
    /**
     * In case the Template found by the `where` argument doesn't exist, create a new Template with this data.
     */
    create: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
    /**
     * In case the Template was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
  }

  /**
   * Template delete
   */
  export type TemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter which Template to delete.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template deleteMany
   */
  export type TemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Templates to delete
     */
    where?: TemplateWhereInput
  }

  /**
   * Template.TemplateStage
   */
  export type Template$TemplateStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateStage
     */
    select?: TemplateStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateStageInclude<ExtArgs> | null
    where?: TemplateStageWhereInput
    orderBy?: TemplateStageOrderByWithRelationInput | TemplateStageOrderByWithRelationInput[]
    cursor?: TemplateStageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateStageScalarFieldEnum | TemplateStageScalarFieldEnum[]
  }

  /**
   * Template.OrganisationTemplate
   */
  export type Template$OrganisationTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationTemplate
     */
    select?: OrganisationTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationTemplateInclude<ExtArgs> | null
    where?: OrganisationTemplateWhereInput
    orderBy?: OrganisationTemplateOrderByWithRelationInput | OrganisationTemplateOrderByWithRelationInput[]
    cursor?: OrganisationTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganisationTemplateScalarFieldEnum | OrganisationTemplateScalarFieldEnum[]
  }

  /**
   * Template without action
   */
  export type TemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
  }


  /**
   * Model TemplateStage
   */

  export type AggregateTemplateStage = {
    _count: TemplateStageCountAggregateOutputType | null
    _avg: TemplateStageAvgAggregateOutputType | null
    _sum: TemplateStageSumAggregateOutputType | null
    _min: TemplateStageMinAggregateOutputType | null
    _max: TemplateStageMaxAggregateOutputType | null
  }

  export type TemplateStageAvgAggregateOutputType = {
    id: number | null
    templateId: number | null
  }

  export type TemplateStageSumAggregateOutputType = {
    id: number | null
    templateId: number | null
  }

  export type TemplateStageMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    templateId: number | null
  }

  export type TemplateStageMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    templateId: number | null
  }

  export type TemplateStageCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    templateId: number
    _all: number
  }


  export type TemplateStageAvgAggregateInputType = {
    id?: true
    templateId?: true
  }

  export type TemplateStageSumAggregateInputType = {
    id?: true
    templateId?: true
  }

  export type TemplateStageMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    templateId?: true
  }

  export type TemplateStageMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    templateId?: true
  }

  export type TemplateStageCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    templateId?: true
    _all?: true
  }

  export type TemplateStageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateStage to aggregate.
     */
    where?: TemplateStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateStages to fetch.
     */
    orderBy?: TemplateStageOrderByWithRelationInput | TemplateStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateStages
    **/
    _count?: true | TemplateStageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateStageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateStageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateStageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateStageMaxAggregateInputType
  }

  export type GetTemplateStageAggregateType<T extends TemplateStageAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateStage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateStage[P]>
      : GetScalarType<T[P], AggregateTemplateStage[P]>
  }




  export type TemplateStageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateStageWhereInput
    orderBy?: TemplateStageOrderByWithAggregationInput | TemplateStageOrderByWithAggregationInput[]
    by: TemplateStageScalarFieldEnum[] | TemplateStageScalarFieldEnum
    having?: TemplateStageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateStageCountAggregateInputType | true
    _avg?: TemplateStageAvgAggregateInputType
    _sum?: TemplateStageSumAggregateInputType
    _min?: TemplateStageMinAggregateInputType
    _max?: TemplateStageMaxAggregateInputType
  }

  export type TemplateStageGroupByOutputType = {
    id: number
    name: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    templateId: number
    _count: TemplateStageCountAggregateOutputType | null
    _avg: TemplateStageAvgAggregateOutputType | null
    _sum: TemplateStageSumAggregateOutputType | null
    _min: TemplateStageMinAggregateOutputType | null
    _max: TemplateStageMaxAggregateOutputType | null
  }

  type GetTemplateStageGroupByPayload<T extends TemplateStageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateStageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateStageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateStageGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateStageGroupByOutputType[P]>
        }
      >
    >


  export type TemplateStageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    templateId?: boolean
    Template?: boolean | TemplateDefaultArgs<ExtArgs>
    TemplateQuestion?: boolean | TemplateStage$TemplateQuestionArgs<ExtArgs>
    _count?: boolean | TemplateStageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateStage"]>


  export type TemplateStageSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    templateId?: boolean
  }

  export type TemplateStageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Template?: boolean | TemplateDefaultArgs<ExtArgs>
    TemplateQuestion?: boolean | TemplateStage$TemplateQuestionArgs<ExtArgs>
    _count?: boolean | TemplateStageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TemplateStagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateStage"
    objects: {
      Template: Prisma.$TemplatePayload<ExtArgs>
      TemplateQuestion: Prisma.$TemplateQuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      templateId: number
    }, ExtArgs["result"]["templateStage"]>
    composites: {}
  }

  type TemplateStageGetPayload<S extends boolean | null | undefined | TemplateStageDefaultArgs> = $Result.GetResult<Prisma.$TemplateStagePayload, S>

  type TemplateStageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplateStageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplateStageCountAggregateInputType | true
    }

  export interface TemplateStageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateStage'], meta: { name: 'TemplateStage' } }
    /**
     * Find zero or one TemplateStage that matches the filter.
     * @param {TemplateStageFindUniqueArgs} args - Arguments to find a TemplateStage
     * @example
     * // Get one TemplateStage
     * const templateStage = await prisma.templateStage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateStageFindUniqueArgs>(args: SelectSubset<T, TemplateStageFindUniqueArgs<ExtArgs>>): Prisma__TemplateStageClient<$Result.GetResult<Prisma.$TemplateStagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TemplateStage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TemplateStageFindUniqueOrThrowArgs} args - Arguments to find a TemplateStage
     * @example
     * // Get one TemplateStage
     * const templateStage = await prisma.templateStage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateStageFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateStageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateStageClient<$Result.GetResult<Prisma.$TemplateStagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TemplateStage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateStageFindFirstArgs} args - Arguments to find a TemplateStage
     * @example
     * // Get one TemplateStage
     * const templateStage = await prisma.templateStage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateStageFindFirstArgs>(args?: SelectSubset<T, TemplateStageFindFirstArgs<ExtArgs>>): Prisma__TemplateStageClient<$Result.GetResult<Prisma.$TemplateStagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TemplateStage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateStageFindFirstOrThrowArgs} args - Arguments to find a TemplateStage
     * @example
     * // Get one TemplateStage
     * const templateStage = await prisma.templateStage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateStageFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateStageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateStageClient<$Result.GetResult<Prisma.$TemplateStagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TemplateStages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateStageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateStages
     * const templateStages = await prisma.templateStage.findMany()
     * 
     * // Get first 10 TemplateStages
     * const templateStages = await prisma.templateStage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateStageWithIdOnly = await prisma.templateStage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateStageFindManyArgs>(args?: SelectSubset<T, TemplateStageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateStagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TemplateStage.
     * @param {TemplateStageCreateArgs} args - Arguments to create a TemplateStage.
     * @example
     * // Create one TemplateStage
     * const TemplateStage = await prisma.templateStage.create({
     *   data: {
     *     // ... data to create a TemplateStage
     *   }
     * })
     * 
     */
    create<T extends TemplateStageCreateArgs>(args: SelectSubset<T, TemplateStageCreateArgs<ExtArgs>>): Prisma__TemplateStageClient<$Result.GetResult<Prisma.$TemplateStagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TemplateStages.
     * @param {TemplateStageCreateManyArgs} args - Arguments to create many TemplateStages.
     * @example
     * // Create many TemplateStages
     * const templateStage = await prisma.templateStage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateStageCreateManyArgs>(args?: SelectSubset<T, TemplateStageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TemplateStage.
     * @param {TemplateStageDeleteArgs} args - Arguments to delete one TemplateStage.
     * @example
     * // Delete one TemplateStage
     * const TemplateStage = await prisma.templateStage.delete({
     *   where: {
     *     // ... filter to delete one TemplateStage
     *   }
     * })
     * 
     */
    delete<T extends TemplateStageDeleteArgs>(args: SelectSubset<T, TemplateStageDeleteArgs<ExtArgs>>): Prisma__TemplateStageClient<$Result.GetResult<Prisma.$TemplateStagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TemplateStage.
     * @param {TemplateStageUpdateArgs} args - Arguments to update one TemplateStage.
     * @example
     * // Update one TemplateStage
     * const templateStage = await prisma.templateStage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateStageUpdateArgs>(args: SelectSubset<T, TemplateStageUpdateArgs<ExtArgs>>): Prisma__TemplateStageClient<$Result.GetResult<Prisma.$TemplateStagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TemplateStages.
     * @param {TemplateStageDeleteManyArgs} args - Arguments to filter TemplateStages to delete.
     * @example
     * // Delete a few TemplateStages
     * const { count } = await prisma.templateStage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateStageDeleteManyArgs>(args?: SelectSubset<T, TemplateStageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateStageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateStages
     * const templateStage = await prisma.templateStage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateStageUpdateManyArgs>(args: SelectSubset<T, TemplateStageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplateStage.
     * @param {TemplateStageUpsertArgs} args - Arguments to update or create a TemplateStage.
     * @example
     * // Update or create a TemplateStage
     * const templateStage = await prisma.templateStage.upsert({
     *   create: {
     *     // ... data to create a TemplateStage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateStage we want to update
     *   }
     * })
     */
    upsert<T extends TemplateStageUpsertArgs>(args: SelectSubset<T, TemplateStageUpsertArgs<ExtArgs>>): Prisma__TemplateStageClient<$Result.GetResult<Prisma.$TemplateStagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TemplateStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateStageCountArgs} args - Arguments to filter TemplateStages to count.
     * @example
     * // Count the number of TemplateStages
     * const count = await prisma.templateStage.count({
     *   where: {
     *     // ... the filter for the TemplateStages we want to count
     *   }
     * })
    **/
    count<T extends TemplateStageCountArgs>(
      args?: Subset<T, TemplateStageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateStageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateStageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateStageAggregateArgs>(args: Subset<T, TemplateStageAggregateArgs>): Prisma.PrismaPromise<GetTemplateStageAggregateType<T>>

    /**
     * Group by TemplateStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateStageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateStageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateStageGroupByArgs['orderBy'] }
        : { orderBy?: TemplateStageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateStageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateStageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateStage model
   */
  readonly fields: TemplateStageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateStage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateStageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Template<T extends TemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TemplateDefaultArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    TemplateQuestion<T extends TemplateStage$TemplateQuestionArgs<ExtArgs> = {}>(args?: Subset<T, TemplateStage$TemplateQuestionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateQuestionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateStage model
   */ 
  interface TemplateStageFieldRefs {
    readonly id: FieldRef<"TemplateStage", 'Int'>
    readonly name: FieldRef<"TemplateStage", 'String'>
    readonly description: FieldRef<"TemplateStage", 'String'>
    readonly isActive: FieldRef<"TemplateStage", 'Boolean'>
    readonly createdAt: FieldRef<"TemplateStage", 'DateTime'>
    readonly updatedAt: FieldRef<"TemplateStage", 'DateTime'>
    readonly templateId: FieldRef<"TemplateStage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TemplateStage findUnique
   */
  export type TemplateStageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateStage
     */
    select?: TemplateStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateStageInclude<ExtArgs> | null
    /**
     * Filter, which TemplateStage to fetch.
     */
    where: TemplateStageWhereUniqueInput
  }

  /**
   * TemplateStage findUniqueOrThrow
   */
  export type TemplateStageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateStage
     */
    select?: TemplateStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateStageInclude<ExtArgs> | null
    /**
     * Filter, which TemplateStage to fetch.
     */
    where: TemplateStageWhereUniqueInput
  }

  /**
   * TemplateStage findFirst
   */
  export type TemplateStageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateStage
     */
    select?: TemplateStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateStageInclude<ExtArgs> | null
    /**
     * Filter, which TemplateStage to fetch.
     */
    where?: TemplateStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateStages to fetch.
     */
    orderBy?: TemplateStageOrderByWithRelationInput | TemplateStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateStages.
     */
    cursor?: TemplateStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateStages.
     */
    distinct?: TemplateStageScalarFieldEnum | TemplateStageScalarFieldEnum[]
  }

  /**
   * TemplateStage findFirstOrThrow
   */
  export type TemplateStageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateStage
     */
    select?: TemplateStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateStageInclude<ExtArgs> | null
    /**
     * Filter, which TemplateStage to fetch.
     */
    where?: TemplateStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateStages to fetch.
     */
    orderBy?: TemplateStageOrderByWithRelationInput | TemplateStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateStages.
     */
    cursor?: TemplateStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateStages.
     */
    distinct?: TemplateStageScalarFieldEnum | TemplateStageScalarFieldEnum[]
  }

  /**
   * TemplateStage findMany
   */
  export type TemplateStageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateStage
     */
    select?: TemplateStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateStageInclude<ExtArgs> | null
    /**
     * Filter, which TemplateStages to fetch.
     */
    where?: TemplateStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateStages to fetch.
     */
    orderBy?: TemplateStageOrderByWithRelationInput | TemplateStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateStages.
     */
    cursor?: TemplateStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateStages.
     */
    skip?: number
    distinct?: TemplateStageScalarFieldEnum | TemplateStageScalarFieldEnum[]
  }

  /**
   * TemplateStage create
   */
  export type TemplateStageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateStage
     */
    select?: TemplateStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateStageInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplateStage.
     */
    data: XOR<TemplateStageCreateInput, TemplateStageUncheckedCreateInput>
  }

  /**
   * TemplateStage createMany
   */
  export type TemplateStageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateStages.
     */
    data: TemplateStageCreateManyInput | TemplateStageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateStage update
   */
  export type TemplateStageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateStage
     */
    select?: TemplateStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateStageInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplateStage.
     */
    data: XOR<TemplateStageUpdateInput, TemplateStageUncheckedUpdateInput>
    /**
     * Choose, which TemplateStage to update.
     */
    where: TemplateStageWhereUniqueInput
  }

  /**
   * TemplateStage updateMany
   */
  export type TemplateStageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateStages.
     */
    data: XOR<TemplateStageUpdateManyMutationInput, TemplateStageUncheckedUpdateManyInput>
    /**
     * Filter which TemplateStages to update
     */
    where?: TemplateStageWhereInput
  }

  /**
   * TemplateStage upsert
   */
  export type TemplateStageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateStage
     */
    select?: TemplateStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateStageInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplateStage to update in case it exists.
     */
    where: TemplateStageWhereUniqueInput
    /**
     * In case the TemplateStage found by the `where` argument doesn't exist, create a new TemplateStage with this data.
     */
    create: XOR<TemplateStageCreateInput, TemplateStageUncheckedCreateInput>
    /**
     * In case the TemplateStage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateStageUpdateInput, TemplateStageUncheckedUpdateInput>
  }

  /**
   * TemplateStage delete
   */
  export type TemplateStageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateStage
     */
    select?: TemplateStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateStageInclude<ExtArgs> | null
    /**
     * Filter which TemplateStage to delete.
     */
    where: TemplateStageWhereUniqueInput
  }

  /**
   * TemplateStage deleteMany
   */
  export type TemplateStageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateStages to delete
     */
    where?: TemplateStageWhereInput
  }

  /**
   * TemplateStage.TemplateQuestion
   */
  export type TemplateStage$TemplateQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestion
     */
    select?: TemplateQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionInclude<ExtArgs> | null
    where?: TemplateQuestionWhereInput
    orderBy?: TemplateQuestionOrderByWithRelationInput | TemplateQuestionOrderByWithRelationInput[]
    cursor?: TemplateQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateQuestionScalarFieldEnum | TemplateQuestionScalarFieldEnum[]
  }

  /**
   * TemplateStage without action
   */
  export type TemplateStageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateStage
     */
    select?: TemplateStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateStageInclude<ExtArgs> | null
  }


  /**
   * Model TemplateQuestion
   */

  export type AggregateTemplateQuestion = {
    _count: TemplateQuestionCountAggregateOutputType | null
    _avg: TemplateQuestionAvgAggregateOutputType | null
    _sum: TemplateQuestionSumAggregateOutputType | null
    _min: TemplateQuestionMinAggregateOutputType | null
    _max: TemplateQuestionMaxAggregateOutputType | null
  }

  export type TemplateQuestionAvgAggregateOutputType = {
    id: number | null
    templateStageId: number | null
    templateId: number | null
  }

  export type TemplateQuestionSumAggregateOutputType = {
    id: number | null
    templateStageId: number | null
    templateId: number | null
  }

  export type TemplateQuestionMinAggregateOutputType = {
    id: number | null
    question: string | null
    description: string | null
    isActive: boolean | null
    templateStageId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    templateId: number | null
  }

  export type TemplateQuestionMaxAggregateOutputType = {
    id: number | null
    question: string | null
    description: string | null
    isActive: boolean | null
    templateStageId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    templateId: number | null
  }

  export type TemplateQuestionCountAggregateOutputType = {
    id: number
    question: number
    description: number
    isActive: number
    templateStageId: number
    createdAt: number
    updatedAt: number
    templateId: number
    _all: number
  }


  export type TemplateQuestionAvgAggregateInputType = {
    id?: true
    templateStageId?: true
    templateId?: true
  }

  export type TemplateQuestionSumAggregateInputType = {
    id?: true
    templateStageId?: true
    templateId?: true
  }

  export type TemplateQuestionMinAggregateInputType = {
    id?: true
    question?: true
    description?: true
    isActive?: true
    templateStageId?: true
    createdAt?: true
    updatedAt?: true
    templateId?: true
  }

  export type TemplateQuestionMaxAggregateInputType = {
    id?: true
    question?: true
    description?: true
    isActive?: true
    templateStageId?: true
    createdAt?: true
    updatedAt?: true
    templateId?: true
  }

  export type TemplateQuestionCountAggregateInputType = {
    id?: true
    question?: true
    description?: true
    isActive?: true
    templateStageId?: true
    createdAt?: true
    updatedAt?: true
    templateId?: true
    _all?: true
  }

  export type TemplateQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateQuestion to aggregate.
     */
    where?: TemplateQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateQuestions to fetch.
     */
    orderBy?: TemplateQuestionOrderByWithRelationInput | TemplateQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateQuestions
    **/
    _count?: true | TemplateQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateQuestionMaxAggregateInputType
  }

  export type GetTemplateQuestionAggregateType<T extends TemplateQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateQuestion[P]>
      : GetScalarType<T[P], AggregateTemplateQuestion[P]>
  }




  export type TemplateQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateQuestionWhereInput
    orderBy?: TemplateQuestionOrderByWithAggregationInput | TemplateQuestionOrderByWithAggregationInput[]
    by: TemplateQuestionScalarFieldEnum[] | TemplateQuestionScalarFieldEnum
    having?: TemplateQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateQuestionCountAggregateInputType | true
    _avg?: TemplateQuestionAvgAggregateInputType
    _sum?: TemplateQuestionSumAggregateInputType
    _min?: TemplateQuestionMinAggregateInputType
    _max?: TemplateQuestionMaxAggregateInputType
  }

  export type TemplateQuestionGroupByOutputType = {
    id: number
    question: string
    description: string | null
    isActive: boolean
    templateStageId: number
    createdAt: Date
    updatedAt: Date
    templateId: number | null
    _count: TemplateQuestionCountAggregateOutputType | null
    _avg: TemplateQuestionAvgAggregateOutputType | null
    _sum: TemplateQuestionSumAggregateOutputType | null
    _min: TemplateQuestionMinAggregateOutputType | null
    _max: TemplateQuestionMaxAggregateOutputType | null
  }

  type GetTemplateQuestionGroupByPayload<T extends TemplateQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateQuestionGroupByOutputType[P]>
        }
      >
    >


  export type TemplateQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    description?: boolean
    isActive?: boolean
    templateStageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    templateId?: boolean
    TemplateStage?: boolean | TemplateStageDefaultArgs<ExtArgs>
    TemplateQuestionAnswer?: boolean | TemplateQuestion$TemplateQuestionAnswerArgs<ExtArgs>
    _count?: boolean | TemplateQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateQuestion"]>


  export type TemplateQuestionSelectScalar = {
    id?: boolean
    question?: boolean
    description?: boolean
    isActive?: boolean
    templateStageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    templateId?: boolean
  }

  export type TemplateQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TemplateStage?: boolean | TemplateStageDefaultArgs<ExtArgs>
    TemplateQuestionAnswer?: boolean | TemplateQuestion$TemplateQuestionAnswerArgs<ExtArgs>
    _count?: boolean | TemplateQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TemplateQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateQuestion"
    objects: {
      TemplateStage: Prisma.$TemplateStagePayload<ExtArgs>
      TemplateQuestionAnswer: Prisma.$TemplateQuestionAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      question: string
      description: string | null
      isActive: boolean
      templateStageId: number
      createdAt: Date
      updatedAt: Date
      templateId: number | null
    }, ExtArgs["result"]["templateQuestion"]>
    composites: {}
  }

  type TemplateQuestionGetPayload<S extends boolean | null | undefined | TemplateQuestionDefaultArgs> = $Result.GetResult<Prisma.$TemplateQuestionPayload, S>

  type TemplateQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplateQuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplateQuestionCountAggregateInputType | true
    }

  export interface TemplateQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateQuestion'], meta: { name: 'TemplateQuestion' } }
    /**
     * Find zero or one TemplateQuestion that matches the filter.
     * @param {TemplateQuestionFindUniqueArgs} args - Arguments to find a TemplateQuestion
     * @example
     * // Get one TemplateQuestion
     * const templateQuestion = await prisma.templateQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateQuestionFindUniqueArgs>(args: SelectSubset<T, TemplateQuestionFindUniqueArgs<ExtArgs>>): Prisma__TemplateQuestionClient<$Result.GetResult<Prisma.$TemplateQuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TemplateQuestion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TemplateQuestionFindUniqueOrThrowArgs} args - Arguments to find a TemplateQuestion
     * @example
     * // Get one TemplateQuestion
     * const templateQuestion = await prisma.templateQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateQuestionClient<$Result.GetResult<Prisma.$TemplateQuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TemplateQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateQuestionFindFirstArgs} args - Arguments to find a TemplateQuestion
     * @example
     * // Get one TemplateQuestion
     * const templateQuestion = await prisma.templateQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateQuestionFindFirstArgs>(args?: SelectSubset<T, TemplateQuestionFindFirstArgs<ExtArgs>>): Prisma__TemplateQuestionClient<$Result.GetResult<Prisma.$TemplateQuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TemplateQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateQuestionFindFirstOrThrowArgs} args - Arguments to find a TemplateQuestion
     * @example
     * // Get one TemplateQuestion
     * const templateQuestion = await prisma.templateQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateQuestionClient<$Result.GetResult<Prisma.$TemplateQuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TemplateQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateQuestions
     * const templateQuestions = await prisma.templateQuestion.findMany()
     * 
     * // Get first 10 TemplateQuestions
     * const templateQuestions = await prisma.templateQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateQuestionWithIdOnly = await prisma.templateQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateQuestionFindManyArgs>(args?: SelectSubset<T, TemplateQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateQuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TemplateQuestion.
     * @param {TemplateQuestionCreateArgs} args - Arguments to create a TemplateQuestion.
     * @example
     * // Create one TemplateQuestion
     * const TemplateQuestion = await prisma.templateQuestion.create({
     *   data: {
     *     // ... data to create a TemplateQuestion
     *   }
     * })
     * 
     */
    create<T extends TemplateQuestionCreateArgs>(args: SelectSubset<T, TemplateQuestionCreateArgs<ExtArgs>>): Prisma__TemplateQuestionClient<$Result.GetResult<Prisma.$TemplateQuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TemplateQuestions.
     * @param {TemplateQuestionCreateManyArgs} args - Arguments to create many TemplateQuestions.
     * @example
     * // Create many TemplateQuestions
     * const templateQuestion = await prisma.templateQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateQuestionCreateManyArgs>(args?: SelectSubset<T, TemplateQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TemplateQuestion.
     * @param {TemplateQuestionDeleteArgs} args - Arguments to delete one TemplateQuestion.
     * @example
     * // Delete one TemplateQuestion
     * const TemplateQuestion = await prisma.templateQuestion.delete({
     *   where: {
     *     // ... filter to delete one TemplateQuestion
     *   }
     * })
     * 
     */
    delete<T extends TemplateQuestionDeleteArgs>(args: SelectSubset<T, TemplateQuestionDeleteArgs<ExtArgs>>): Prisma__TemplateQuestionClient<$Result.GetResult<Prisma.$TemplateQuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TemplateQuestion.
     * @param {TemplateQuestionUpdateArgs} args - Arguments to update one TemplateQuestion.
     * @example
     * // Update one TemplateQuestion
     * const templateQuestion = await prisma.templateQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateQuestionUpdateArgs>(args: SelectSubset<T, TemplateQuestionUpdateArgs<ExtArgs>>): Prisma__TemplateQuestionClient<$Result.GetResult<Prisma.$TemplateQuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TemplateQuestions.
     * @param {TemplateQuestionDeleteManyArgs} args - Arguments to filter TemplateQuestions to delete.
     * @example
     * // Delete a few TemplateQuestions
     * const { count } = await prisma.templateQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateQuestionDeleteManyArgs>(args?: SelectSubset<T, TemplateQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateQuestions
     * const templateQuestion = await prisma.templateQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateQuestionUpdateManyArgs>(args: SelectSubset<T, TemplateQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplateQuestion.
     * @param {TemplateQuestionUpsertArgs} args - Arguments to update or create a TemplateQuestion.
     * @example
     * // Update or create a TemplateQuestion
     * const templateQuestion = await prisma.templateQuestion.upsert({
     *   create: {
     *     // ... data to create a TemplateQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateQuestion we want to update
     *   }
     * })
     */
    upsert<T extends TemplateQuestionUpsertArgs>(args: SelectSubset<T, TemplateQuestionUpsertArgs<ExtArgs>>): Prisma__TemplateQuestionClient<$Result.GetResult<Prisma.$TemplateQuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TemplateQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateQuestionCountArgs} args - Arguments to filter TemplateQuestions to count.
     * @example
     * // Count the number of TemplateQuestions
     * const count = await prisma.templateQuestion.count({
     *   where: {
     *     // ... the filter for the TemplateQuestions we want to count
     *   }
     * })
    **/
    count<T extends TemplateQuestionCountArgs>(
      args?: Subset<T, TemplateQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateQuestionAggregateArgs>(args: Subset<T, TemplateQuestionAggregateArgs>): Prisma.PrismaPromise<GetTemplateQuestionAggregateType<T>>

    /**
     * Group by TemplateQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateQuestionGroupByArgs['orderBy'] }
        : { orderBy?: TemplateQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateQuestion model
   */
  readonly fields: TemplateQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TemplateStage<T extends TemplateStageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TemplateStageDefaultArgs<ExtArgs>>): Prisma__TemplateStageClient<$Result.GetResult<Prisma.$TemplateStagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    TemplateQuestionAnswer<T extends TemplateQuestion$TemplateQuestionAnswerArgs<ExtArgs> = {}>(args?: Subset<T, TemplateQuestion$TemplateQuestionAnswerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateQuestionAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateQuestion model
   */ 
  interface TemplateQuestionFieldRefs {
    readonly id: FieldRef<"TemplateQuestion", 'Int'>
    readonly question: FieldRef<"TemplateQuestion", 'String'>
    readonly description: FieldRef<"TemplateQuestion", 'String'>
    readonly isActive: FieldRef<"TemplateQuestion", 'Boolean'>
    readonly templateStageId: FieldRef<"TemplateQuestion", 'Int'>
    readonly createdAt: FieldRef<"TemplateQuestion", 'DateTime'>
    readonly updatedAt: FieldRef<"TemplateQuestion", 'DateTime'>
    readonly templateId: FieldRef<"TemplateQuestion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TemplateQuestion findUnique
   */
  export type TemplateQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestion
     */
    select?: TemplateQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionInclude<ExtArgs> | null
    /**
     * Filter, which TemplateQuestion to fetch.
     */
    where: TemplateQuestionWhereUniqueInput
  }

  /**
   * TemplateQuestion findUniqueOrThrow
   */
  export type TemplateQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestion
     */
    select?: TemplateQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionInclude<ExtArgs> | null
    /**
     * Filter, which TemplateQuestion to fetch.
     */
    where: TemplateQuestionWhereUniqueInput
  }

  /**
   * TemplateQuestion findFirst
   */
  export type TemplateQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestion
     */
    select?: TemplateQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionInclude<ExtArgs> | null
    /**
     * Filter, which TemplateQuestion to fetch.
     */
    where?: TemplateQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateQuestions to fetch.
     */
    orderBy?: TemplateQuestionOrderByWithRelationInput | TemplateQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateQuestions.
     */
    cursor?: TemplateQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateQuestions.
     */
    distinct?: TemplateQuestionScalarFieldEnum | TemplateQuestionScalarFieldEnum[]
  }

  /**
   * TemplateQuestion findFirstOrThrow
   */
  export type TemplateQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestion
     */
    select?: TemplateQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionInclude<ExtArgs> | null
    /**
     * Filter, which TemplateQuestion to fetch.
     */
    where?: TemplateQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateQuestions to fetch.
     */
    orderBy?: TemplateQuestionOrderByWithRelationInput | TemplateQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateQuestions.
     */
    cursor?: TemplateQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateQuestions.
     */
    distinct?: TemplateQuestionScalarFieldEnum | TemplateQuestionScalarFieldEnum[]
  }

  /**
   * TemplateQuestion findMany
   */
  export type TemplateQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestion
     */
    select?: TemplateQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionInclude<ExtArgs> | null
    /**
     * Filter, which TemplateQuestions to fetch.
     */
    where?: TemplateQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateQuestions to fetch.
     */
    orderBy?: TemplateQuestionOrderByWithRelationInput | TemplateQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateQuestions.
     */
    cursor?: TemplateQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateQuestions.
     */
    skip?: number
    distinct?: TemplateQuestionScalarFieldEnum | TemplateQuestionScalarFieldEnum[]
  }

  /**
   * TemplateQuestion create
   */
  export type TemplateQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestion
     */
    select?: TemplateQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplateQuestion.
     */
    data: XOR<TemplateQuestionCreateInput, TemplateQuestionUncheckedCreateInput>
  }

  /**
   * TemplateQuestion createMany
   */
  export type TemplateQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateQuestions.
     */
    data: TemplateQuestionCreateManyInput | TemplateQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateQuestion update
   */
  export type TemplateQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestion
     */
    select?: TemplateQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplateQuestion.
     */
    data: XOR<TemplateQuestionUpdateInput, TemplateQuestionUncheckedUpdateInput>
    /**
     * Choose, which TemplateQuestion to update.
     */
    where: TemplateQuestionWhereUniqueInput
  }

  /**
   * TemplateQuestion updateMany
   */
  export type TemplateQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateQuestions.
     */
    data: XOR<TemplateQuestionUpdateManyMutationInput, TemplateQuestionUncheckedUpdateManyInput>
    /**
     * Filter which TemplateQuestions to update
     */
    where?: TemplateQuestionWhereInput
  }

  /**
   * TemplateQuestion upsert
   */
  export type TemplateQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestion
     */
    select?: TemplateQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplateQuestion to update in case it exists.
     */
    where: TemplateQuestionWhereUniqueInput
    /**
     * In case the TemplateQuestion found by the `where` argument doesn't exist, create a new TemplateQuestion with this data.
     */
    create: XOR<TemplateQuestionCreateInput, TemplateQuestionUncheckedCreateInput>
    /**
     * In case the TemplateQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateQuestionUpdateInput, TemplateQuestionUncheckedUpdateInput>
  }

  /**
   * TemplateQuestion delete
   */
  export type TemplateQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestion
     */
    select?: TemplateQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionInclude<ExtArgs> | null
    /**
     * Filter which TemplateQuestion to delete.
     */
    where: TemplateQuestionWhereUniqueInput
  }

  /**
   * TemplateQuestion deleteMany
   */
  export type TemplateQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateQuestions to delete
     */
    where?: TemplateQuestionWhereInput
  }

  /**
   * TemplateQuestion.TemplateQuestionAnswer
   */
  export type TemplateQuestion$TemplateQuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestionAnswer
     */
    select?: TemplateQuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionAnswerInclude<ExtArgs> | null
    where?: TemplateQuestionAnswerWhereInput
    orderBy?: TemplateQuestionAnswerOrderByWithRelationInput | TemplateQuestionAnswerOrderByWithRelationInput[]
    cursor?: TemplateQuestionAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateQuestionAnswerScalarFieldEnum | TemplateQuestionAnswerScalarFieldEnum[]
  }

  /**
   * TemplateQuestion without action
   */
  export type TemplateQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestion
     */
    select?: TemplateQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionInclude<ExtArgs> | null
  }


  /**
   * Model TemplateQuestionAnswer
   */

  export type AggregateTemplateQuestionAnswer = {
    _count: TemplateQuestionAnswerCountAggregateOutputType | null
    _avg: TemplateQuestionAnswerAvgAggregateOutputType | null
    _sum: TemplateQuestionAnswerSumAggregateOutputType | null
    _min: TemplateQuestionAnswerMinAggregateOutputType | null
    _max: TemplateQuestionAnswerMaxAggregateOutputType | null
  }

  export type TemplateQuestionAnswerAvgAggregateOutputType = {
    id: number | null
    templateQuestionId: number | null
  }

  export type TemplateQuestionAnswerSumAggregateOutputType = {
    id: number | null
    templateQuestionId: number | null
  }

  export type TemplateQuestionAnswerMinAggregateOutputType = {
    id: number | null
    answer: string | null
    description: string | null
    isActive: boolean | null
    templateQuestionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateQuestionAnswerMaxAggregateOutputType = {
    id: number | null
    answer: string | null
    description: string | null
    isActive: boolean | null
    templateQuestionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateQuestionAnswerCountAggregateOutputType = {
    id: number
    answer: number
    description: number
    isActive: number
    templateQuestionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemplateQuestionAnswerAvgAggregateInputType = {
    id?: true
    templateQuestionId?: true
  }

  export type TemplateQuestionAnswerSumAggregateInputType = {
    id?: true
    templateQuestionId?: true
  }

  export type TemplateQuestionAnswerMinAggregateInputType = {
    id?: true
    answer?: true
    description?: true
    isActive?: true
    templateQuestionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateQuestionAnswerMaxAggregateInputType = {
    id?: true
    answer?: true
    description?: true
    isActive?: true
    templateQuestionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateQuestionAnswerCountAggregateInputType = {
    id?: true
    answer?: true
    description?: true
    isActive?: true
    templateQuestionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemplateQuestionAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateQuestionAnswer to aggregate.
     */
    where?: TemplateQuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateQuestionAnswers to fetch.
     */
    orderBy?: TemplateQuestionAnswerOrderByWithRelationInput | TemplateQuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateQuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateQuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateQuestionAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateQuestionAnswers
    **/
    _count?: true | TemplateQuestionAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateQuestionAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateQuestionAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateQuestionAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateQuestionAnswerMaxAggregateInputType
  }

  export type GetTemplateQuestionAnswerAggregateType<T extends TemplateQuestionAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateQuestionAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateQuestionAnswer[P]>
      : GetScalarType<T[P], AggregateTemplateQuestionAnswer[P]>
  }




  export type TemplateQuestionAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateQuestionAnswerWhereInput
    orderBy?: TemplateQuestionAnswerOrderByWithAggregationInput | TemplateQuestionAnswerOrderByWithAggregationInput[]
    by: TemplateQuestionAnswerScalarFieldEnum[] | TemplateQuestionAnswerScalarFieldEnum
    having?: TemplateQuestionAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateQuestionAnswerCountAggregateInputType | true
    _avg?: TemplateQuestionAnswerAvgAggregateInputType
    _sum?: TemplateQuestionAnswerSumAggregateInputType
    _min?: TemplateQuestionAnswerMinAggregateInputType
    _max?: TemplateQuestionAnswerMaxAggregateInputType
  }

  export type TemplateQuestionAnswerGroupByOutputType = {
    id: number
    answer: string
    description: string | null
    isActive: boolean
    templateQuestionId: number
    createdAt: Date
    updatedAt: Date
    _count: TemplateQuestionAnswerCountAggregateOutputType | null
    _avg: TemplateQuestionAnswerAvgAggregateOutputType | null
    _sum: TemplateQuestionAnswerSumAggregateOutputType | null
    _min: TemplateQuestionAnswerMinAggregateOutputType | null
    _max: TemplateQuestionAnswerMaxAggregateOutputType | null
  }

  type GetTemplateQuestionAnswerGroupByPayload<T extends TemplateQuestionAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateQuestionAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateQuestionAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateQuestionAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateQuestionAnswerGroupByOutputType[P]>
        }
      >
    >


  export type TemplateQuestionAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    answer?: boolean
    description?: boolean
    isActive?: boolean
    templateQuestionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    TemplateQuestion?: boolean | TemplateQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateQuestionAnswer"]>


  export type TemplateQuestionAnswerSelectScalar = {
    id?: boolean
    answer?: boolean
    description?: boolean
    isActive?: boolean
    templateQuestionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TemplateQuestionAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TemplateQuestion?: boolean | TemplateQuestionDefaultArgs<ExtArgs>
  }

  export type $TemplateQuestionAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateQuestionAnswer"
    objects: {
      TemplateQuestion: Prisma.$TemplateQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      answer: string
      description: string | null
      isActive: boolean
      templateQuestionId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["templateQuestionAnswer"]>
    composites: {}
  }

  type TemplateQuestionAnswerGetPayload<S extends boolean | null | undefined | TemplateQuestionAnswerDefaultArgs> = $Result.GetResult<Prisma.$TemplateQuestionAnswerPayload, S>

  type TemplateQuestionAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplateQuestionAnswerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplateQuestionAnswerCountAggregateInputType | true
    }

  export interface TemplateQuestionAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateQuestionAnswer'], meta: { name: 'TemplateQuestionAnswer' } }
    /**
     * Find zero or one TemplateQuestionAnswer that matches the filter.
     * @param {TemplateQuestionAnswerFindUniqueArgs} args - Arguments to find a TemplateQuestionAnswer
     * @example
     * // Get one TemplateQuestionAnswer
     * const templateQuestionAnswer = await prisma.templateQuestionAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateQuestionAnswerFindUniqueArgs>(args: SelectSubset<T, TemplateQuestionAnswerFindUniqueArgs<ExtArgs>>): Prisma__TemplateQuestionAnswerClient<$Result.GetResult<Prisma.$TemplateQuestionAnswerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TemplateQuestionAnswer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TemplateQuestionAnswerFindUniqueOrThrowArgs} args - Arguments to find a TemplateQuestionAnswer
     * @example
     * // Get one TemplateQuestionAnswer
     * const templateQuestionAnswer = await prisma.templateQuestionAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateQuestionAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateQuestionAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateQuestionAnswerClient<$Result.GetResult<Prisma.$TemplateQuestionAnswerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TemplateQuestionAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateQuestionAnswerFindFirstArgs} args - Arguments to find a TemplateQuestionAnswer
     * @example
     * // Get one TemplateQuestionAnswer
     * const templateQuestionAnswer = await prisma.templateQuestionAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateQuestionAnswerFindFirstArgs>(args?: SelectSubset<T, TemplateQuestionAnswerFindFirstArgs<ExtArgs>>): Prisma__TemplateQuestionAnswerClient<$Result.GetResult<Prisma.$TemplateQuestionAnswerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TemplateQuestionAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateQuestionAnswerFindFirstOrThrowArgs} args - Arguments to find a TemplateQuestionAnswer
     * @example
     * // Get one TemplateQuestionAnswer
     * const templateQuestionAnswer = await prisma.templateQuestionAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateQuestionAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateQuestionAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateQuestionAnswerClient<$Result.GetResult<Prisma.$TemplateQuestionAnswerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TemplateQuestionAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateQuestionAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateQuestionAnswers
     * const templateQuestionAnswers = await prisma.templateQuestionAnswer.findMany()
     * 
     * // Get first 10 TemplateQuestionAnswers
     * const templateQuestionAnswers = await prisma.templateQuestionAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateQuestionAnswerWithIdOnly = await prisma.templateQuestionAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateQuestionAnswerFindManyArgs>(args?: SelectSubset<T, TemplateQuestionAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateQuestionAnswerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TemplateQuestionAnswer.
     * @param {TemplateQuestionAnswerCreateArgs} args - Arguments to create a TemplateQuestionAnswer.
     * @example
     * // Create one TemplateQuestionAnswer
     * const TemplateQuestionAnswer = await prisma.templateQuestionAnswer.create({
     *   data: {
     *     // ... data to create a TemplateQuestionAnswer
     *   }
     * })
     * 
     */
    create<T extends TemplateQuestionAnswerCreateArgs>(args: SelectSubset<T, TemplateQuestionAnswerCreateArgs<ExtArgs>>): Prisma__TemplateQuestionAnswerClient<$Result.GetResult<Prisma.$TemplateQuestionAnswerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TemplateQuestionAnswers.
     * @param {TemplateQuestionAnswerCreateManyArgs} args - Arguments to create many TemplateQuestionAnswers.
     * @example
     * // Create many TemplateQuestionAnswers
     * const templateQuestionAnswer = await prisma.templateQuestionAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateQuestionAnswerCreateManyArgs>(args?: SelectSubset<T, TemplateQuestionAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TemplateQuestionAnswer.
     * @param {TemplateQuestionAnswerDeleteArgs} args - Arguments to delete one TemplateQuestionAnswer.
     * @example
     * // Delete one TemplateQuestionAnswer
     * const TemplateQuestionAnswer = await prisma.templateQuestionAnswer.delete({
     *   where: {
     *     // ... filter to delete one TemplateQuestionAnswer
     *   }
     * })
     * 
     */
    delete<T extends TemplateQuestionAnswerDeleteArgs>(args: SelectSubset<T, TemplateQuestionAnswerDeleteArgs<ExtArgs>>): Prisma__TemplateQuestionAnswerClient<$Result.GetResult<Prisma.$TemplateQuestionAnswerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TemplateQuestionAnswer.
     * @param {TemplateQuestionAnswerUpdateArgs} args - Arguments to update one TemplateQuestionAnswer.
     * @example
     * // Update one TemplateQuestionAnswer
     * const templateQuestionAnswer = await prisma.templateQuestionAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateQuestionAnswerUpdateArgs>(args: SelectSubset<T, TemplateQuestionAnswerUpdateArgs<ExtArgs>>): Prisma__TemplateQuestionAnswerClient<$Result.GetResult<Prisma.$TemplateQuestionAnswerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TemplateQuestionAnswers.
     * @param {TemplateQuestionAnswerDeleteManyArgs} args - Arguments to filter TemplateQuestionAnswers to delete.
     * @example
     * // Delete a few TemplateQuestionAnswers
     * const { count } = await prisma.templateQuestionAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateQuestionAnswerDeleteManyArgs>(args?: SelectSubset<T, TemplateQuestionAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateQuestionAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateQuestionAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateQuestionAnswers
     * const templateQuestionAnswer = await prisma.templateQuestionAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateQuestionAnswerUpdateManyArgs>(args: SelectSubset<T, TemplateQuestionAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplateQuestionAnswer.
     * @param {TemplateQuestionAnswerUpsertArgs} args - Arguments to update or create a TemplateQuestionAnswer.
     * @example
     * // Update or create a TemplateQuestionAnswer
     * const templateQuestionAnswer = await prisma.templateQuestionAnswer.upsert({
     *   create: {
     *     // ... data to create a TemplateQuestionAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateQuestionAnswer we want to update
     *   }
     * })
     */
    upsert<T extends TemplateQuestionAnswerUpsertArgs>(args: SelectSubset<T, TemplateQuestionAnswerUpsertArgs<ExtArgs>>): Prisma__TemplateQuestionAnswerClient<$Result.GetResult<Prisma.$TemplateQuestionAnswerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TemplateQuestionAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateQuestionAnswerCountArgs} args - Arguments to filter TemplateQuestionAnswers to count.
     * @example
     * // Count the number of TemplateQuestionAnswers
     * const count = await prisma.templateQuestionAnswer.count({
     *   where: {
     *     // ... the filter for the TemplateQuestionAnswers we want to count
     *   }
     * })
    **/
    count<T extends TemplateQuestionAnswerCountArgs>(
      args?: Subset<T, TemplateQuestionAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateQuestionAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateQuestionAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateQuestionAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateQuestionAnswerAggregateArgs>(args: Subset<T, TemplateQuestionAnswerAggregateArgs>): Prisma.PrismaPromise<GetTemplateQuestionAnswerAggregateType<T>>

    /**
     * Group by TemplateQuestionAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateQuestionAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateQuestionAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateQuestionAnswerGroupByArgs['orderBy'] }
        : { orderBy?: TemplateQuestionAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateQuestionAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateQuestionAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateQuestionAnswer model
   */
  readonly fields: TemplateQuestionAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateQuestionAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateQuestionAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TemplateQuestion<T extends TemplateQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TemplateQuestionDefaultArgs<ExtArgs>>): Prisma__TemplateQuestionClient<$Result.GetResult<Prisma.$TemplateQuestionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateQuestionAnswer model
   */ 
  interface TemplateQuestionAnswerFieldRefs {
    readonly id: FieldRef<"TemplateQuestionAnswer", 'Int'>
    readonly answer: FieldRef<"TemplateQuestionAnswer", 'String'>
    readonly description: FieldRef<"TemplateQuestionAnswer", 'String'>
    readonly isActive: FieldRef<"TemplateQuestionAnswer", 'Boolean'>
    readonly templateQuestionId: FieldRef<"TemplateQuestionAnswer", 'Int'>
    readonly createdAt: FieldRef<"TemplateQuestionAnswer", 'DateTime'>
    readonly updatedAt: FieldRef<"TemplateQuestionAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TemplateQuestionAnswer findUnique
   */
  export type TemplateQuestionAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestionAnswer
     */
    select?: TemplateQuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which TemplateQuestionAnswer to fetch.
     */
    where: TemplateQuestionAnswerWhereUniqueInput
  }

  /**
   * TemplateQuestionAnswer findUniqueOrThrow
   */
  export type TemplateQuestionAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestionAnswer
     */
    select?: TemplateQuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which TemplateQuestionAnswer to fetch.
     */
    where: TemplateQuestionAnswerWhereUniqueInput
  }

  /**
   * TemplateQuestionAnswer findFirst
   */
  export type TemplateQuestionAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestionAnswer
     */
    select?: TemplateQuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which TemplateQuestionAnswer to fetch.
     */
    where?: TemplateQuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateQuestionAnswers to fetch.
     */
    orderBy?: TemplateQuestionAnswerOrderByWithRelationInput | TemplateQuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateQuestionAnswers.
     */
    cursor?: TemplateQuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateQuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateQuestionAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateQuestionAnswers.
     */
    distinct?: TemplateQuestionAnswerScalarFieldEnum | TemplateQuestionAnswerScalarFieldEnum[]
  }

  /**
   * TemplateQuestionAnswer findFirstOrThrow
   */
  export type TemplateQuestionAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestionAnswer
     */
    select?: TemplateQuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which TemplateQuestionAnswer to fetch.
     */
    where?: TemplateQuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateQuestionAnswers to fetch.
     */
    orderBy?: TemplateQuestionAnswerOrderByWithRelationInput | TemplateQuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateQuestionAnswers.
     */
    cursor?: TemplateQuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateQuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateQuestionAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateQuestionAnswers.
     */
    distinct?: TemplateQuestionAnswerScalarFieldEnum | TemplateQuestionAnswerScalarFieldEnum[]
  }

  /**
   * TemplateQuestionAnswer findMany
   */
  export type TemplateQuestionAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestionAnswer
     */
    select?: TemplateQuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter, which TemplateQuestionAnswers to fetch.
     */
    where?: TemplateQuestionAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateQuestionAnswers to fetch.
     */
    orderBy?: TemplateQuestionAnswerOrderByWithRelationInput | TemplateQuestionAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateQuestionAnswers.
     */
    cursor?: TemplateQuestionAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateQuestionAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateQuestionAnswers.
     */
    skip?: number
    distinct?: TemplateQuestionAnswerScalarFieldEnum | TemplateQuestionAnswerScalarFieldEnum[]
  }

  /**
   * TemplateQuestionAnswer create
   */
  export type TemplateQuestionAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestionAnswer
     */
    select?: TemplateQuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplateQuestionAnswer.
     */
    data: XOR<TemplateQuestionAnswerCreateInput, TemplateQuestionAnswerUncheckedCreateInput>
  }

  /**
   * TemplateQuestionAnswer createMany
   */
  export type TemplateQuestionAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateQuestionAnswers.
     */
    data: TemplateQuestionAnswerCreateManyInput | TemplateQuestionAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateQuestionAnswer update
   */
  export type TemplateQuestionAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestionAnswer
     */
    select?: TemplateQuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplateQuestionAnswer.
     */
    data: XOR<TemplateQuestionAnswerUpdateInput, TemplateQuestionAnswerUncheckedUpdateInput>
    /**
     * Choose, which TemplateQuestionAnswer to update.
     */
    where: TemplateQuestionAnswerWhereUniqueInput
  }

  /**
   * TemplateQuestionAnswer updateMany
   */
  export type TemplateQuestionAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateQuestionAnswers.
     */
    data: XOR<TemplateQuestionAnswerUpdateManyMutationInput, TemplateQuestionAnswerUncheckedUpdateManyInput>
    /**
     * Filter which TemplateQuestionAnswers to update
     */
    where?: TemplateQuestionAnswerWhereInput
  }

  /**
   * TemplateQuestionAnswer upsert
   */
  export type TemplateQuestionAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestionAnswer
     */
    select?: TemplateQuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplateQuestionAnswer to update in case it exists.
     */
    where: TemplateQuestionAnswerWhereUniqueInput
    /**
     * In case the TemplateQuestionAnswer found by the `where` argument doesn't exist, create a new TemplateQuestionAnswer with this data.
     */
    create: XOR<TemplateQuestionAnswerCreateInput, TemplateQuestionAnswerUncheckedCreateInput>
    /**
     * In case the TemplateQuestionAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateQuestionAnswerUpdateInput, TemplateQuestionAnswerUncheckedUpdateInput>
  }

  /**
   * TemplateQuestionAnswer delete
   */
  export type TemplateQuestionAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestionAnswer
     */
    select?: TemplateQuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionAnswerInclude<ExtArgs> | null
    /**
     * Filter which TemplateQuestionAnswer to delete.
     */
    where: TemplateQuestionAnswerWhereUniqueInput
  }

  /**
   * TemplateQuestionAnswer deleteMany
   */
  export type TemplateQuestionAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateQuestionAnswers to delete
     */
    where?: TemplateQuestionAnswerWhereInput
  }

  /**
   * TemplateQuestionAnswer without action
   */
  export type TemplateQuestionAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateQuestionAnswer
     */
    select?: TemplateQuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateQuestionAnswerInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    company: string | null
    password: string | null
    rememberToken: string | null
    logo: string | null
    isActive: boolean | null
    disabled: boolean | null
    tfaSecret: string | null
    fpwToken: string | null
    qrCodeVisibility: boolean | null
    isDureation: boolean | null
    tfaStatus: boolean | null
    emailVerifiedAt: Date | null
    startDate: Date | null
    endDate: Date | null
    deletedAt: Date | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    company: string | null
    password: string | null
    rememberToken: string | null
    logo: string | null
    isActive: boolean | null
    disabled: boolean | null
    tfaSecret: string | null
    fpwToken: string | null
    qrCodeVisibility: boolean | null
    isDureation: boolean | null
    tfaStatus: boolean | null
    emailVerifiedAt: Date | null
    startDate: Date | null
    endDate: Date | null
    deletedAt: Date | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    firstName: number
    lastName: number
    email: number
    company: number
    password: number
    rememberToken: number
    logo: number
    isActive: number
    disabled: number
    tfaSecret: number
    fpwToken: number
    qrCodeVisibility: number
    isDureation: number
    tfaStatus: number
    emailVerifiedAt: number
    startDate: number
    endDate: number
    deletedAt: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    lastName?: true
    email?: true
    company?: true
    password?: true
    rememberToken?: true
    logo?: true
    isActive?: true
    disabled?: true
    tfaSecret?: true
    fpwToken?: true
    qrCodeVisibility?: true
    isDureation?: true
    tfaStatus?: true
    emailVerifiedAt?: true
    startDate?: true
    endDate?: true
    deletedAt?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    lastName?: true
    email?: true
    company?: true
    password?: true
    rememberToken?: true
    logo?: true
    isActive?: true
    disabled?: true
    tfaSecret?: true
    fpwToken?: true
    qrCodeVisibility?: true
    isDureation?: true
    tfaStatus?: true
    emailVerifiedAt?: true
    startDate?: true
    endDate?: true
    deletedAt?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    lastName?: true
    email?: true
    company?: true
    password?: true
    rememberToken?: true
    logo?: true
    isActive?: true
    disabled?: true
    tfaSecret?: true
    fpwToken?: true
    qrCodeVisibility?: true
    isDureation?: true
    tfaStatus?: true
    emailVerifiedAt?: true
    startDate?: true
    endDate?: true
    deletedAt?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    firstName: string | null
    lastName: string | null
    email: string
    company: string | null
    password: string
    rememberToken: string | null
    logo: string | null
    isActive: boolean
    disabled: boolean
    tfaSecret: string | null
    fpwToken: string | null
    qrCodeVisibility: boolean
    isDureation: boolean
    tfaStatus: boolean
    emailVerifiedAt: Date | null
    startDate: Date | null
    endDate: Date | null
    deletedAt: Date | null
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    company?: boolean
    password?: boolean
    rememberToken?: boolean
    logo?: boolean
    isActive?: boolean
    disabled?: boolean
    tfaSecret?: boolean
    fpwToken?: boolean
    qrCodeVisibility?: boolean
    isDureation?: boolean
    tfaStatus?: boolean
    emailVerifiedAt?: boolean
    startDate?: boolean
    endDate?: boolean
    deletedAt?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Organisation?: boolean | User$OrganisationArgs<ExtArgs>
    UserRole?: boolean | User$UserRoleArgs<ExtArgs>
    OrganisationStructure?: boolean | User$OrganisationStructureArgs<ExtArgs>
    QuestionAnswer?: boolean | User$QuestionAnswerArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    company?: boolean
    password?: boolean
    rememberToken?: boolean
    logo?: boolean
    isActive?: boolean
    disabled?: boolean
    tfaSecret?: boolean
    fpwToken?: boolean
    qrCodeVisibility?: boolean
    isDureation?: boolean
    tfaStatus?: boolean
    emailVerifiedAt?: boolean
    startDate?: boolean
    endDate?: boolean
    deletedAt?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Organisation?: boolean | User$OrganisationArgs<ExtArgs>
    UserRole?: boolean | User$UserRoleArgs<ExtArgs>
    OrganisationStructure?: boolean | User$OrganisationStructureArgs<ExtArgs>
    QuestionAnswer?: boolean | User$QuestionAnswerArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Organisation: Prisma.$OrganisationPayload<ExtArgs> | null
      UserRole: Prisma.$UserRolePayload<ExtArgs>[]
      OrganisationStructure: Prisma.$OrganisationStructurePayload<ExtArgs>[]
      QuestionAnswer: Prisma.$QuestionAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      firstName: string | null
      lastName: string | null
      email: string
      company: string | null
      password: string
      rememberToken: string | null
      logo: string | null
      isActive: boolean
      disabled: boolean
      tfaSecret: string | null
      fpwToken: string | null
      qrCodeVisibility: boolean
      isDureation: boolean
      tfaStatus: boolean
      emailVerifiedAt: Date | null
      startDate: Date | null
      endDate: Date | null
      deletedAt: Date | null
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Organisation<T extends User$OrganisationArgs<ExtArgs> = {}>(args?: Subset<T, User$OrganisationArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    UserRole<T extends User$UserRoleArgs<ExtArgs> = {}>(args?: Subset<T, User$UserRoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    OrganisationStructure<T extends User$OrganisationStructureArgs<ExtArgs> = {}>(args?: Subset<T, User$OrganisationStructureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationStructurePayload<ExtArgs>, T, "findMany"> | Null>
    QuestionAnswer<T extends User$QuestionAnswerArgs<ExtArgs> = {}>(args?: Subset<T, User$QuestionAnswerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly company: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly rememberToken: FieldRef<"User", 'String'>
    readonly logo: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly disabled: FieldRef<"User", 'Boolean'>
    readonly tfaSecret: FieldRef<"User", 'String'>
    readonly fpwToken: FieldRef<"User", 'String'>
    readonly qrCodeVisibility: FieldRef<"User", 'Boolean'>
    readonly isDureation: FieldRef<"User", 'Boolean'>
    readonly tfaStatus: FieldRef<"User", 'Boolean'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly startDate: FieldRef<"User", 'DateTime'>
    readonly endDate: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.Organisation
   */
  export type User$OrganisationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    where?: OrganisationWhereInput
  }

  /**
   * User.UserRole
   */
  export type User$UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.OrganisationStructure
   */
  export type User$OrganisationStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationStructure
     */
    select?: OrganisationStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationStructureInclude<ExtArgs> | null
    where?: OrganisationStructureWhereInput
    orderBy?: OrganisationStructureOrderByWithRelationInput | OrganisationStructureOrderByWithRelationInput[]
    cursor?: OrganisationStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganisationStructureScalarFieldEnum | OrganisationStructureScalarFieldEnum[]
  }

  /**
   * User.QuestionAnswer
   */
  export type User$QuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnswer
     */
    select?: QuestionAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAnswerInclude<ExtArgs> | null
    where?: QuestionAnswerWhereInput
    orderBy?: QuestionAnswerOrderByWithRelationInput | QuestionAnswerOrderByWithRelationInput[]
    cursor?: QuestionAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAnswerScalarFieldEnum | QuestionAnswerScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
  }

  export type UserRoleSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    roleId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserRoleAvgAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserRoleSumAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _avg?: UserRoleAvgAggregateInputType
    _sum?: UserRoleSumAggregateInputType
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: number
    userId: number
    roleId: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>


  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      roleId: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */ 
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'Int'>
    readonly userId: FieldRef<"UserRole", 'Int'>
    readonly roleId: FieldRef<"UserRole", 'Int'>
    readonly isActive: FieldRef<"UserRole", 'Boolean'>
    readonly createdAt: FieldRef<"UserRole", 'DateTime'>
    readonly updatedAt: FieldRef<"UserRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AssessmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    logo: 'logo',
    organisationId: 'organisationId',
    password: 'password',
    rememberToken: 'rememberToken',
    isActive: 'isActive',
    secretToken: 'secretToken',
    tfaToken: 'tfaToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    organisationTemplateId: 'organisationTemplateId'
  };

  export type AssessmentScalarFieldEnum = (typeof AssessmentScalarFieldEnum)[keyof typeof AssessmentScalarFieldEnum]


  export const AssessmentQuestionScalarFieldEnum: {
    id: 'id',
    assessmentId: 'assessmentId',
    assessmentStage: 'assessmentStage',
    questionMongoId: 'questionMongoId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssessmentQuestionScalarFieldEnum = (typeof AssessmentQuestionScalarFieldEnum)[keyof typeof AssessmentQuestionScalarFieldEnum]


  export const AssessmentTeamScalarFieldEnum: {
    id: 'id',
    assessmentId: 'assessmentId',
    organisationId: 'organisationId',
    teamId: 'teamId',
    password: 'password',
    rememberToken: 'rememberToken',
    isActive: 'isActive',
    secretToken: 'secretToken',
    tfaToken: 'tfaToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssessmentTeamScalarFieldEnum = (typeof AssessmentTeamScalarFieldEnum)[keyof typeof AssessmentTeamScalarFieldEnum]


  export const OrganisationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    logo: 'logo',
    password: 'password',
    rememberToken: 'rememberToken',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganisationScalarFieldEnum = (typeof OrganisationScalarFieldEnum)[keyof typeof OrganisationScalarFieldEnum]


  export const OrganisationRoleScalarFieldEnum: {
    id: 'id',
    isActive: 'isActive',
    organisationStructureId: 'organisationStructureId',
    roleId: 'roleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganisationRoleScalarFieldEnum = (typeof OrganisationRoleScalarFieldEnum)[keyof typeof OrganisationRoleScalarFieldEnum]


  export const OrganisationStructureScalarFieldEnum: {
    id: 'id',
    organisationId: 'organisationId',
    teamId: 'teamId',
    userId: 'userId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganisationStructureScalarFieldEnum = (typeof OrganisationStructureScalarFieldEnum)[keyof typeof OrganisationStructureScalarFieldEnum]


  export const OrganisationTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    logo: 'logo',
    organisationId: 'organisationId',
    password: 'password',
    rememberToken: 'rememberToken',
    isActive: 'isActive',
    secretToken: 'secretToken',
    tfaToken: 'tfaToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    templateId: 'templateId'
  };

  export type OrganisationTemplateScalarFieldEnum = (typeof OrganisationTemplateScalarFieldEnum)[keyof typeof OrganisationTemplateScalarFieldEnum]


  export const QuestionAnswerScalarFieldEnum: {
    id: 'id',
    organisationId: 'organisationId',
    organisationStructureId: 'organisationStructureId',
    teamId: 'teamId',
    userId: 'userId',
    assessmentTeamId: 'assessmentTeamId',
    assessmentId: 'assessmentId',
    assessmentStage: 'assessmentStage',
    questionMongoId: 'questionMongoId',
    assessmentQuestionId: 'assessmentQuestionId',
    password: 'password',
    rememberToken: 'rememberToken',
    notes: 'notes',
    isActive: 'isActive',
    secretToken: 'secretToken',
    tfaToken: 'tfaToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionAnswerScalarFieldEnum = (typeof QuestionAnswerScalarFieldEnum)[keyof typeof QuestionAnswerScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    logo: 'logo',
    organisationId: 'organisationId',
    password: 'password',
    rememberToken: 'rememberToken',
    isActive: 'isActive',
    secretToken: 'secretToken',
    tfaToken: 'tfaToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemplateScalarFieldEnum = (typeof TemplateScalarFieldEnum)[keyof typeof TemplateScalarFieldEnum]


  export const TemplateStageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    templateId: 'templateId'
  };

  export type TemplateStageScalarFieldEnum = (typeof TemplateStageScalarFieldEnum)[keyof typeof TemplateStageScalarFieldEnum]


  export const TemplateQuestionScalarFieldEnum: {
    id: 'id',
    question: 'question',
    description: 'description',
    isActive: 'isActive',
    templateStageId: 'templateStageId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    templateId: 'templateId'
  };

  export type TemplateQuestionScalarFieldEnum = (typeof TemplateQuestionScalarFieldEnum)[keyof typeof TemplateQuestionScalarFieldEnum]


  export const TemplateQuestionAnswerScalarFieldEnum: {
    id: 'id',
    answer: 'answer',
    description: 'description',
    isActive: 'isActive',
    templateQuestionId: 'templateQuestionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemplateQuestionAnswerScalarFieldEnum = (typeof TemplateQuestionAnswerScalarFieldEnum)[keyof typeof TemplateQuestionAnswerScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    company: 'company',
    password: 'password',
    rememberToken: 'rememberToken',
    logo: 'logo',
    isActive: 'isActive',
    disabled: 'disabled',
    tfaSecret: 'tfaSecret',
    fpwToken: 'fpwToken',
    qrCodeVisibility: 'qrCodeVisibility',
    isDureation: 'isDureation',
    tfaStatus: 'tfaStatus',
    emailVerifiedAt: 'emailVerifiedAt',
    startDate: 'startDate',
    endDate: 'endDate',
    deletedAt: 'deletedAt',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type AssessmentWhereInput = {
    AND?: AssessmentWhereInput | AssessmentWhereInput[]
    OR?: AssessmentWhereInput[]
    NOT?: AssessmentWhereInput | AssessmentWhereInput[]
    id?: IntFilter<"Assessment"> | number
    name?: StringFilter<"Assessment"> | string
    description?: StringNullableFilter<"Assessment"> | string | null
    logo?: StringNullableFilter<"Assessment"> | string | null
    organisationId?: IntFilter<"Assessment"> | number
    password?: StringNullableFilter<"Assessment"> | string | null
    rememberToken?: StringNullableFilter<"Assessment"> | string | null
    isActive?: BoolFilter<"Assessment"> | boolean
    secretToken?: StringNullableFilter<"Assessment"> | string | null
    tfaToken?: StringNullableFilter<"Assessment"> | string | null
    createdAt?: DateTimeFilter<"Assessment"> | Date | string
    updatedAt?: DateTimeFilter<"Assessment"> | Date | string
    organisationTemplateId?: IntNullableFilter<"Assessment"> | number | null
    Organisation?: XOR<OrganisationRelationFilter, OrganisationWhereInput>
    AssessmentQuestion?: AssessmentQuestionListRelationFilter
    OrganisationTemplate?: XOR<OrganisationTemplateNullableRelationFilter, OrganisationTemplateWhereInput> | null
    AssessmentTeam?: AssessmentTeamListRelationFilter
    QuestionAnswer?: QuestionAnswerListRelationFilter
  }

  export type AssessmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    organisationId?: SortOrder
    password?: SortOrderInput | SortOrder
    rememberToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    secretToken?: SortOrderInput | SortOrder
    tfaToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organisationTemplateId?: SortOrderInput | SortOrder
    Organisation?: OrganisationOrderByWithRelationInput
    AssessmentQuestion?: AssessmentQuestionOrderByRelationAggregateInput
    OrganisationTemplate?: OrganisationTemplateOrderByWithRelationInput
    AssessmentTeam?: AssessmentTeamOrderByRelationAggregateInput
    QuestionAnswer?: QuestionAnswerOrderByRelationAggregateInput
  }

  export type AssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssessmentWhereInput | AssessmentWhereInput[]
    OR?: AssessmentWhereInput[]
    NOT?: AssessmentWhereInput | AssessmentWhereInput[]
    name?: StringFilter<"Assessment"> | string
    description?: StringNullableFilter<"Assessment"> | string | null
    logo?: StringNullableFilter<"Assessment"> | string | null
    organisationId?: IntFilter<"Assessment"> | number
    password?: StringNullableFilter<"Assessment"> | string | null
    rememberToken?: StringNullableFilter<"Assessment"> | string | null
    isActive?: BoolFilter<"Assessment"> | boolean
    secretToken?: StringNullableFilter<"Assessment"> | string | null
    tfaToken?: StringNullableFilter<"Assessment"> | string | null
    createdAt?: DateTimeFilter<"Assessment"> | Date | string
    updatedAt?: DateTimeFilter<"Assessment"> | Date | string
    organisationTemplateId?: IntNullableFilter<"Assessment"> | number | null
    Organisation?: XOR<OrganisationRelationFilter, OrganisationWhereInput>
    AssessmentQuestion?: AssessmentQuestionListRelationFilter
    OrganisationTemplate?: XOR<OrganisationTemplateNullableRelationFilter, OrganisationTemplateWhereInput> | null
    AssessmentTeam?: AssessmentTeamListRelationFilter
    QuestionAnswer?: QuestionAnswerListRelationFilter
  }, "id" | "id">

  export type AssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    organisationId?: SortOrder
    password?: SortOrderInput | SortOrder
    rememberToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    secretToken?: SortOrderInput | SortOrder
    tfaToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organisationTemplateId?: SortOrderInput | SortOrder
    _count?: AssessmentCountOrderByAggregateInput
    _avg?: AssessmentAvgOrderByAggregateInput
    _max?: AssessmentMaxOrderByAggregateInput
    _min?: AssessmentMinOrderByAggregateInput
    _sum?: AssessmentSumOrderByAggregateInput
  }

  export type AssessmentScalarWhereWithAggregatesInput = {
    AND?: AssessmentScalarWhereWithAggregatesInput | AssessmentScalarWhereWithAggregatesInput[]
    OR?: AssessmentScalarWhereWithAggregatesInput[]
    NOT?: AssessmentScalarWhereWithAggregatesInput | AssessmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Assessment"> | number
    name?: StringWithAggregatesFilter<"Assessment"> | string
    description?: StringNullableWithAggregatesFilter<"Assessment"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Assessment"> | string | null
    organisationId?: IntWithAggregatesFilter<"Assessment"> | number
    password?: StringNullableWithAggregatesFilter<"Assessment"> | string | null
    rememberToken?: StringNullableWithAggregatesFilter<"Assessment"> | string | null
    isActive?: BoolWithAggregatesFilter<"Assessment"> | boolean
    secretToken?: StringNullableWithAggregatesFilter<"Assessment"> | string | null
    tfaToken?: StringNullableWithAggregatesFilter<"Assessment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Assessment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Assessment"> | Date | string
    organisationTemplateId?: IntNullableWithAggregatesFilter<"Assessment"> | number | null
  }

  export type AssessmentQuestionWhereInput = {
    AND?: AssessmentQuestionWhereInput | AssessmentQuestionWhereInput[]
    OR?: AssessmentQuestionWhereInput[]
    NOT?: AssessmentQuestionWhereInput | AssessmentQuestionWhereInput[]
    id?: IntFilter<"AssessmentQuestion"> | number
    assessmentId?: IntFilter<"AssessmentQuestion"> | number
    assessmentStage?: StringFilter<"AssessmentQuestion"> | string
    questionMongoId?: StringFilter<"AssessmentQuestion"> | string
    isActive?: BoolFilter<"AssessmentQuestion"> | boolean
    createdAt?: DateTimeFilter<"AssessmentQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"AssessmentQuestion"> | Date | string
    Assessment?: XOR<AssessmentRelationFilter, AssessmentWhereInput>
    QuestionAnswer?: QuestionAnswerListRelationFilter
  }

  export type AssessmentQuestionOrderByWithRelationInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    assessmentStage?: SortOrder
    questionMongoId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Assessment?: AssessmentOrderByWithRelationInput
    QuestionAnswer?: QuestionAnswerOrderByRelationAggregateInput
  }

  export type AssessmentQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    questionMongoId?: string
    assessmentId_questionMongoId?: AssessmentQuestionAssessmentIdQuestionMongoIdCompoundUniqueInput
    AND?: AssessmentQuestionWhereInput | AssessmentQuestionWhereInput[]
    OR?: AssessmentQuestionWhereInput[]
    NOT?: AssessmentQuestionWhereInput | AssessmentQuestionWhereInput[]
    assessmentId?: IntFilter<"AssessmentQuestion"> | number
    assessmentStage?: StringFilter<"AssessmentQuestion"> | string
    isActive?: BoolFilter<"AssessmentQuestion"> | boolean
    createdAt?: DateTimeFilter<"AssessmentQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"AssessmentQuestion"> | Date | string
    Assessment?: XOR<AssessmentRelationFilter, AssessmentWhereInput>
    QuestionAnswer?: QuestionAnswerListRelationFilter
  }, "id" | "id" | "questionMongoId" | "assessmentId_questionMongoId">

  export type AssessmentQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    assessmentStage?: SortOrder
    questionMongoId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssessmentQuestionCountOrderByAggregateInput
    _avg?: AssessmentQuestionAvgOrderByAggregateInput
    _max?: AssessmentQuestionMaxOrderByAggregateInput
    _min?: AssessmentQuestionMinOrderByAggregateInput
    _sum?: AssessmentQuestionSumOrderByAggregateInput
  }

  export type AssessmentQuestionScalarWhereWithAggregatesInput = {
    AND?: AssessmentQuestionScalarWhereWithAggregatesInput | AssessmentQuestionScalarWhereWithAggregatesInput[]
    OR?: AssessmentQuestionScalarWhereWithAggregatesInput[]
    NOT?: AssessmentQuestionScalarWhereWithAggregatesInput | AssessmentQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AssessmentQuestion"> | number
    assessmentId?: IntWithAggregatesFilter<"AssessmentQuestion"> | number
    assessmentStage?: StringWithAggregatesFilter<"AssessmentQuestion"> | string
    questionMongoId?: StringWithAggregatesFilter<"AssessmentQuestion"> | string
    isActive?: BoolWithAggregatesFilter<"AssessmentQuestion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AssessmentQuestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AssessmentQuestion"> | Date | string
  }

  export type AssessmentTeamWhereInput = {
    AND?: AssessmentTeamWhereInput | AssessmentTeamWhereInput[]
    OR?: AssessmentTeamWhereInput[]
    NOT?: AssessmentTeamWhereInput | AssessmentTeamWhereInput[]
    id?: IntFilter<"AssessmentTeam"> | number
    assessmentId?: IntFilter<"AssessmentTeam"> | number
    organisationId?: IntFilter<"AssessmentTeam"> | number
    teamId?: IntFilter<"AssessmentTeam"> | number
    password?: StringNullableFilter<"AssessmentTeam"> | string | null
    rememberToken?: StringNullableFilter<"AssessmentTeam"> | string | null
    isActive?: BoolFilter<"AssessmentTeam"> | boolean
    secretToken?: StringNullableFilter<"AssessmentTeam"> | string | null
    tfaToken?: StringNullableFilter<"AssessmentTeam"> | string | null
    createdAt?: DateTimeFilter<"AssessmentTeam"> | Date | string
    updatedAt?: DateTimeFilter<"AssessmentTeam"> | Date | string
    Assessment?: XOR<AssessmentRelationFilter, AssessmentWhereInput>
    Organisation?: XOR<OrganisationRelationFilter, OrganisationWhereInput>
    Team?: XOR<TeamRelationFilter, TeamWhereInput>
    QuestionAnswer?: QuestionAnswerListRelationFilter
  }

  export type AssessmentTeamOrderByWithRelationInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    organisationId?: SortOrder
    teamId?: SortOrder
    password?: SortOrderInput | SortOrder
    rememberToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    secretToken?: SortOrderInput | SortOrder
    tfaToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Assessment?: AssessmentOrderByWithRelationInput
    Organisation?: OrganisationOrderByWithRelationInput
    Team?: TeamOrderByWithRelationInput
    QuestionAnswer?: QuestionAnswerOrderByRelationAggregateInput
  }

  export type AssessmentTeamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    assessmentId_teamId?: AssessmentTeamAssessmentIdTeamIdCompoundUniqueInput
    AND?: AssessmentTeamWhereInput | AssessmentTeamWhereInput[]
    OR?: AssessmentTeamWhereInput[]
    NOT?: AssessmentTeamWhereInput | AssessmentTeamWhereInput[]
    assessmentId?: IntFilter<"AssessmentTeam"> | number
    organisationId?: IntFilter<"AssessmentTeam"> | number
    teamId?: IntFilter<"AssessmentTeam"> | number
    password?: StringNullableFilter<"AssessmentTeam"> | string | null
    rememberToken?: StringNullableFilter<"AssessmentTeam"> | string | null
    isActive?: BoolFilter<"AssessmentTeam"> | boolean
    secretToken?: StringNullableFilter<"AssessmentTeam"> | string | null
    tfaToken?: StringNullableFilter<"AssessmentTeam"> | string | null
    createdAt?: DateTimeFilter<"AssessmentTeam"> | Date | string
    updatedAt?: DateTimeFilter<"AssessmentTeam"> | Date | string
    Assessment?: XOR<AssessmentRelationFilter, AssessmentWhereInput>
    Organisation?: XOR<OrganisationRelationFilter, OrganisationWhereInput>
    Team?: XOR<TeamRelationFilter, TeamWhereInput>
    QuestionAnswer?: QuestionAnswerListRelationFilter
  }, "id" | "id" | "assessmentId_teamId">

  export type AssessmentTeamOrderByWithAggregationInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    organisationId?: SortOrder
    teamId?: SortOrder
    password?: SortOrderInput | SortOrder
    rememberToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    secretToken?: SortOrderInput | SortOrder
    tfaToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssessmentTeamCountOrderByAggregateInput
    _avg?: AssessmentTeamAvgOrderByAggregateInput
    _max?: AssessmentTeamMaxOrderByAggregateInput
    _min?: AssessmentTeamMinOrderByAggregateInput
    _sum?: AssessmentTeamSumOrderByAggregateInput
  }

  export type AssessmentTeamScalarWhereWithAggregatesInput = {
    AND?: AssessmentTeamScalarWhereWithAggregatesInput | AssessmentTeamScalarWhereWithAggregatesInput[]
    OR?: AssessmentTeamScalarWhereWithAggregatesInput[]
    NOT?: AssessmentTeamScalarWhereWithAggregatesInput | AssessmentTeamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AssessmentTeam"> | number
    assessmentId?: IntWithAggregatesFilter<"AssessmentTeam"> | number
    organisationId?: IntWithAggregatesFilter<"AssessmentTeam"> | number
    teamId?: IntWithAggregatesFilter<"AssessmentTeam"> | number
    password?: StringNullableWithAggregatesFilter<"AssessmentTeam"> | string | null
    rememberToken?: StringNullableWithAggregatesFilter<"AssessmentTeam"> | string | null
    isActive?: BoolWithAggregatesFilter<"AssessmentTeam"> | boolean
    secretToken?: StringNullableWithAggregatesFilter<"AssessmentTeam"> | string | null
    tfaToken?: StringNullableWithAggregatesFilter<"AssessmentTeam"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AssessmentTeam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AssessmentTeam"> | Date | string
  }

  export type OrganisationWhereInput = {
    AND?: OrganisationWhereInput | OrganisationWhereInput[]
    OR?: OrganisationWhereInput[]
    NOT?: OrganisationWhereInput | OrganisationWhereInput[]
    id?: IntFilter<"Organisation"> | number
    name?: StringFilter<"Organisation"> | string
    description?: StringNullableFilter<"Organisation"> | string | null
    isActive?: BoolNullableFilter<"Organisation"> | boolean | null
    logo?: StringNullableFilter<"Organisation"> | string | null
    password?: StringNullableFilter<"Organisation"> | string | null
    rememberToken?: StringNullableFilter<"Organisation"> | string | null
    ownerId?: IntNullableFilter<"Organisation"> | number | null
    createdAt?: DateTimeFilter<"Organisation"> | Date | string
    updatedAt?: DateTimeFilter<"Organisation"> | Date | string
    Owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    Assessment?: AssessmentListRelationFilter
    Team?: TeamListRelationFilter
    OrganisationTemplate?: OrganisationTemplateListRelationFilter
    QuestionAnswer?: QuestionAnswerListRelationFilter
    AssessmentTeam?: AssessmentTeamListRelationFilter
  }

  export type OrganisationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    rememberToken?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Owner?: UserOrderByWithRelationInput
    Assessment?: AssessmentOrderByRelationAggregateInput
    Team?: TeamOrderByRelationAggregateInput
    OrganisationTemplate?: OrganisationTemplateOrderByRelationAggregateInput
    QuestionAnswer?: QuestionAnswerOrderByRelationAggregateInput
    AssessmentTeam?: AssessmentTeamOrderByRelationAggregateInput
  }

  export type OrganisationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    ownerId?: number
    AND?: OrganisationWhereInput | OrganisationWhereInput[]
    OR?: OrganisationWhereInput[]
    NOT?: OrganisationWhereInput | OrganisationWhereInput[]
    description?: StringNullableFilter<"Organisation"> | string | null
    isActive?: BoolNullableFilter<"Organisation"> | boolean | null
    logo?: StringNullableFilter<"Organisation"> | string | null
    password?: StringNullableFilter<"Organisation"> | string | null
    rememberToken?: StringNullableFilter<"Organisation"> | string | null
    createdAt?: DateTimeFilter<"Organisation"> | Date | string
    updatedAt?: DateTimeFilter<"Organisation"> | Date | string
    Owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    Assessment?: AssessmentListRelationFilter
    Team?: TeamListRelationFilter
    OrganisationTemplate?: OrganisationTemplateListRelationFilter
    QuestionAnswer?: QuestionAnswerListRelationFilter
    AssessmentTeam?: AssessmentTeamListRelationFilter
  }, "id" | "id" | "name" | "ownerId">

  export type OrganisationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    rememberToken?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganisationCountOrderByAggregateInput
    _avg?: OrganisationAvgOrderByAggregateInput
    _max?: OrganisationMaxOrderByAggregateInput
    _min?: OrganisationMinOrderByAggregateInput
    _sum?: OrganisationSumOrderByAggregateInput
  }

  export type OrganisationScalarWhereWithAggregatesInput = {
    AND?: OrganisationScalarWhereWithAggregatesInput | OrganisationScalarWhereWithAggregatesInput[]
    OR?: OrganisationScalarWhereWithAggregatesInput[]
    NOT?: OrganisationScalarWhereWithAggregatesInput | OrganisationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Organisation"> | number
    name?: StringWithAggregatesFilter<"Organisation"> | string
    description?: StringNullableWithAggregatesFilter<"Organisation"> | string | null
    isActive?: BoolNullableWithAggregatesFilter<"Organisation"> | boolean | null
    logo?: StringNullableWithAggregatesFilter<"Organisation"> | string | null
    password?: StringNullableWithAggregatesFilter<"Organisation"> | string | null
    rememberToken?: StringNullableWithAggregatesFilter<"Organisation"> | string | null
    ownerId?: IntNullableWithAggregatesFilter<"Organisation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Organisation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organisation"> | Date | string
  }

  export type OrganisationRoleWhereInput = {
    AND?: OrganisationRoleWhereInput | OrganisationRoleWhereInput[]
    OR?: OrganisationRoleWhereInput[]
    NOT?: OrganisationRoleWhereInput | OrganisationRoleWhereInput[]
    id?: IntFilter<"OrganisationRole"> | number
    isActive?: BoolNullableFilter<"OrganisationRole"> | boolean | null
    organisationStructureId?: IntFilter<"OrganisationRole"> | number
    roleId?: IntFilter<"OrganisationRole"> | number
    createdAt?: DateTimeFilter<"OrganisationRole"> | Date | string
    updatedAt?: DateTimeFilter<"OrganisationRole"> | Date | string
    OrganisationStructure?: XOR<OrganisationStructureRelationFilter, OrganisationStructureWhereInput>
    Role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type OrganisationRoleOrderByWithRelationInput = {
    id?: SortOrder
    isActive?: SortOrderInput | SortOrder
    organisationStructureId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    OrganisationStructure?: OrganisationStructureOrderByWithRelationInput
    Role?: RoleOrderByWithRelationInput
  }

  export type OrganisationRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    organisationStructureId_roleId?: OrganisationRoleOrganisationStructureIdRoleIdCompoundUniqueInput
    AND?: OrganisationRoleWhereInput | OrganisationRoleWhereInput[]
    OR?: OrganisationRoleWhereInput[]
    NOT?: OrganisationRoleWhereInput | OrganisationRoleWhereInput[]
    isActive?: BoolNullableFilter<"OrganisationRole"> | boolean | null
    organisationStructureId?: IntFilter<"OrganisationRole"> | number
    roleId?: IntFilter<"OrganisationRole"> | number
    createdAt?: DateTimeFilter<"OrganisationRole"> | Date | string
    updatedAt?: DateTimeFilter<"OrganisationRole"> | Date | string
    OrganisationStructure?: XOR<OrganisationStructureRelationFilter, OrganisationStructureWhereInput>
    Role?: XOR<RoleRelationFilter, RoleWhereInput>
  }, "id" | "id" | "organisationStructureId_roleId">

  export type OrganisationRoleOrderByWithAggregationInput = {
    id?: SortOrder
    isActive?: SortOrderInput | SortOrder
    organisationStructureId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganisationRoleCountOrderByAggregateInput
    _avg?: OrganisationRoleAvgOrderByAggregateInput
    _max?: OrganisationRoleMaxOrderByAggregateInput
    _min?: OrganisationRoleMinOrderByAggregateInput
    _sum?: OrganisationRoleSumOrderByAggregateInput
  }

  export type OrganisationRoleScalarWhereWithAggregatesInput = {
    AND?: OrganisationRoleScalarWhereWithAggregatesInput | OrganisationRoleScalarWhereWithAggregatesInput[]
    OR?: OrganisationRoleScalarWhereWithAggregatesInput[]
    NOT?: OrganisationRoleScalarWhereWithAggregatesInput | OrganisationRoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrganisationRole"> | number
    isActive?: BoolNullableWithAggregatesFilter<"OrganisationRole"> | boolean | null
    organisationStructureId?: IntWithAggregatesFilter<"OrganisationRole"> | number
    roleId?: IntWithAggregatesFilter<"OrganisationRole"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrganisationRole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrganisationRole"> | Date | string
  }

  export type OrganisationStructureWhereInput = {
    AND?: OrganisationStructureWhereInput | OrganisationStructureWhereInput[]
    OR?: OrganisationStructureWhereInput[]
    NOT?: OrganisationStructureWhereInput | OrganisationStructureWhereInput[]
    id?: IntFilter<"OrganisationStructure"> | number
    organisationId?: IntFilter<"OrganisationStructure"> | number
    teamId?: IntNullableFilter<"OrganisationStructure"> | number | null
    userId?: IntFilter<"OrganisationStructure"> | number
    isActive?: BoolNullableFilter<"OrganisationStructure"> | boolean | null
    createdAt?: DateTimeFilter<"OrganisationStructure"> | Date | string
    updatedAt?: DateTimeFilter<"OrganisationStructure"> | Date | string
    Team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    OrganisationRole?: OrganisationRoleListRelationFilter
    User?: XOR<UserRelationFilter, UserWhereInput>
    QuestionAnswer?: QuestionAnswerListRelationFilter
  }

  export type OrganisationStructureOrderByWithRelationInput = {
    id?: SortOrder
    organisationId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    userId?: SortOrder
    isActive?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Team?: TeamOrderByWithRelationInput
    OrganisationRole?: OrganisationRoleOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
    QuestionAnswer?: QuestionAnswerOrderByRelationAggregateInput
  }

  export type OrganisationStructureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    teamId_userId?: OrganisationStructureTeamIdUserIdCompoundUniqueInput
    AND?: OrganisationStructureWhereInput | OrganisationStructureWhereInput[]
    OR?: OrganisationStructureWhereInput[]
    NOT?: OrganisationStructureWhereInput | OrganisationStructureWhereInput[]
    organisationId?: IntFilter<"OrganisationStructure"> | number
    teamId?: IntNullableFilter<"OrganisationStructure"> | number | null
    userId?: IntFilter<"OrganisationStructure"> | number
    isActive?: BoolNullableFilter<"OrganisationStructure"> | boolean | null
    createdAt?: DateTimeFilter<"OrganisationStructure"> | Date | string
    updatedAt?: DateTimeFilter<"OrganisationStructure"> | Date | string
    Team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    OrganisationRole?: OrganisationRoleListRelationFilter
    User?: XOR<UserRelationFilter, UserWhereInput>
    QuestionAnswer?: QuestionAnswerListRelationFilter
  }, "id" | "id" | "teamId_userId">

  export type OrganisationStructureOrderByWithAggregationInput = {
    id?: SortOrder
    organisationId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    userId?: SortOrder
    isActive?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganisationStructureCountOrderByAggregateInput
    _avg?: OrganisationStructureAvgOrderByAggregateInput
    _max?: OrganisationStructureMaxOrderByAggregateInput
    _min?: OrganisationStructureMinOrderByAggregateInput
    _sum?: OrganisationStructureSumOrderByAggregateInput
  }

  export type OrganisationStructureScalarWhereWithAggregatesInput = {
    AND?: OrganisationStructureScalarWhereWithAggregatesInput | OrganisationStructureScalarWhereWithAggregatesInput[]
    OR?: OrganisationStructureScalarWhereWithAggregatesInput[]
    NOT?: OrganisationStructureScalarWhereWithAggregatesInput | OrganisationStructureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrganisationStructure"> | number
    organisationId?: IntWithAggregatesFilter<"OrganisationStructure"> | number
    teamId?: IntNullableWithAggregatesFilter<"OrganisationStructure"> | number | null
    userId?: IntWithAggregatesFilter<"OrganisationStructure"> | number
    isActive?: BoolNullableWithAggregatesFilter<"OrganisationStructure"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"OrganisationStructure"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrganisationStructure"> | Date | string
  }

  export type OrganisationTemplateWhereInput = {
    AND?: OrganisationTemplateWhereInput | OrganisationTemplateWhereInput[]
    OR?: OrganisationTemplateWhereInput[]
    NOT?: OrganisationTemplateWhereInput | OrganisationTemplateWhereInput[]
    id?: IntFilter<"OrganisationTemplate"> | number
    name?: StringFilter<"OrganisationTemplate"> | string
    description?: StringNullableFilter<"OrganisationTemplate"> | string | null
    logo?: StringNullableFilter<"OrganisationTemplate"> | string | null
    organisationId?: IntFilter<"OrganisationTemplate"> | number
    password?: StringNullableFilter<"OrganisationTemplate"> | string | null
    rememberToken?: StringNullableFilter<"OrganisationTemplate"> | string | null
    isActive?: BoolFilter<"OrganisationTemplate"> | boolean
    secretToken?: StringNullableFilter<"OrganisationTemplate"> | string | null
    tfaToken?: StringNullableFilter<"OrganisationTemplate"> | string | null
    createdAt?: DateTimeFilter<"OrganisationTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"OrganisationTemplate"> | Date | string
    templateId?: IntFilter<"OrganisationTemplate"> | number
    Organisation?: XOR<OrganisationRelationFilter, OrganisationWhereInput>
    Template?: XOR<TemplateNullableRelationFilter, TemplateWhereInput> | null
    Assessment?: AssessmentListRelationFilter
  }

  export type OrganisationTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    organisationId?: SortOrder
    password?: SortOrderInput | SortOrder
    rememberToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    secretToken?: SortOrderInput | SortOrder
    tfaToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
    Organisation?: OrganisationOrderByWithRelationInput
    Template?: TemplateOrderByWithRelationInput
    Assessment?: AssessmentOrderByRelationAggregateInput
  }

  export type OrganisationTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    organisationId_templateId?: OrganisationTemplateOrganisationIdTemplateIdCompoundUniqueInput
    AND?: OrganisationTemplateWhereInput | OrganisationTemplateWhereInput[]
    OR?: OrganisationTemplateWhereInput[]
    NOT?: OrganisationTemplateWhereInput | OrganisationTemplateWhereInput[]
    name?: StringFilter<"OrganisationTemplate"> | string
    description?: StringNullableFilter<"OrganisationTemplate"> | string | null
    logo?: StringNullableFilter<"OrganisationTemplate"> | string | null
    organisationId?: IntFilter<"OrganisationTemplate"> | number
    password?: StringNullableFilter<"OrganisationTemplate"> | string | null
    rememberToken?: StringNullableFilter<"OrganisationTemplate"> | string | null
    isActive?: BoolFilter<"OrganisationTemplate"> | boolean
    secretToken?: StringNullableFilter<"OrganisationTemplate"> | string | null
    tfaToken?: StringNullableFilter<"OrganisationTemplate"> | string | null
    createdAt?: DateTimeFilter<"OrganisationTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"OrganisationTemplate"> | Date | string
    templateId?: IntFilter<"OrganisationTemplate"> | number
    Organisation?: XOR<OrganisationRelationFilter, OrganisationWhereInput>
    Template?: XOR<TemplateNullableRelationFilter, TemplateWhereInput> | null
    Assessment?: AssessmentListRelationFilter
  }, "id" | "id" | "organisationId_templateId">

  export type OrganisationTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    organisationId?: SortOrder
    password?: SortOrderInput | SortOrder
    rememberToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    secretToken?: SortOrderInput | SortOrder
    tfaToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
    _count?: OrganisationTemplateCountOrderByAggregateInput
    _avg?: OrganisationTemplateAvgOrderByAggregateInput
    _max?: OrganisationTemplateMaxOrderByAggregateInput
    _min?: OrganisationTemplateMinOrderByAggregateInput
    _sum?: OrganisationTemplateSumOrderByAggregateInput
  }

  export type OrganisationTemplateScalarWhereWithAggregatesInput = {
    AND?: OrganisationTemplateScalarWhereWithAggregatesInput | OrganisationTemplateScalarWhereWithAggregatesInput[]
    OR?: OrganisationTemplateScalarWhereWithAggregatesInput[]
    NOT?: OrganisationTemplateScalarWhereWithAggregatesInput | OrganisationTemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrganisationTemplate"> | number
    name?: StringWithAggregatesFilter<"OrganisationTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"OrganisationTemplate"> | string | null
    logo?: StringNullableWithAggregatesFilter<"OrganisationTemplate"> | string | null
    organisationId?: IntWithAggregatesFilter<"OrganisationTemplate"> | number
    password?: StringNullableWithAggregatesFilter<"OrganisationTemplate"> | string | null
    rememberToken?: StringNullableWithAggregatesFilter<"OrganisationTemplate"> | string | null
    isActive?: BoolWithAggregatesFilter<"OrganisationTemplate"> | boolean
    secretToken?: StringNullableWithAggregatesFilter<"OrganisationTemplate"> | string | null
    tfaToken?: StringNullableWithAggregatesFilter<"OrganisationTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrganisationTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrganisationTemplate"> | Date | string
    templateId?: IntWithAggregatesFilter<"OrganisationTemplate"> | number
  }

  export type QuestionAnswerWhereInput = {
    AND?: QuestionAnswerWhereInput | QuestionAnswerWhereInput[]
    OR?: QuestionAnswerWhereInput[]
    NOT?: QuestionAnswerWhereInput | QuestionAnswerWhereInput[]
    id?: IntFilter<"QuestionAnswer"> | number
    organisationId?: IntNullableFilter<"QuestionAnswer"> | number | null
    organisationStructureId?: IntNullableFilter<"QuestionAnswer"> | number | null
    teamId?: IntNullableFilter<"QuestionAnswer"> | number | null
    userId?: IntNullableFilter<"QuestionAnswer"> | number | null
    assessmentTeamId?: IntNullableFilter<"QuestionAnswer"> | number | null
    assessmentId?: IntNullableFilter<"QuestionAnswer"> | number | null
    assessmentStage?: StringFilter<"QuestionAnswer"> | string
    questionMongoId?: StringFilter<"QuestionAnswer"> | string
    assessmentQuestionId?: IntNullableFilter<"QuestionAnswer"> | number | null
    password?: StringNullableFilter<"QuestionAnswer"> | string | null
    rememberToken?: StringNullableFilter<"QuestionAnswer"> | string | null
    notes?: StringNullableFilter<"QuestionAnswer"> | string | null
    isActive?: BoolFilter<"QuestionAnswer"> | boolean
    secretToken?: StringNullableFilter<"QuestionAnswer"> | string | null
    tfaToken?: StringNullableFilter<"QuestionAnswer"> | string | null
    createdAt?: DateTimeFilter<"QuestionAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionAnswer"> | Date | string
    Organisation?: XOR<OrganisationNullableRelationFilter, OrganisationWhereInput> | null
    OrganisationStructure?: XOR<OrganisationStructureNullableRelationFilter, OrganisationStructureWhereInput> | null
    Team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    AssessmentTeam?: XOR<AssessmentTeamNullableRelationFilter, AssessmentTeamWhereInput> | null
    Assessment?: XOR<AssessmentNullableRelationFilter, AssessmentWhereInput> | null
    AssessmentQuestion?: XOR<AssessmentQuestionNullableRelationFilter, AssessmentQuestionWhereInput> | null
  }

  export type QuestionAnswerOrderByWithRelationInput = {
    id?: SortOrder
    organisationId?: SortOrderInput | SortOrder
    organisationStructureId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    assessmentTeamId?: SortOrderInput | SortOrder
    assessmentId?: SortOrderInput | SortOrder
    assessmentStage?: SortOrder
    questionMongoId?: SortOrder
    assessmentQuestionId?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    rememberToken?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    secretToken?: SortOrderInput | SortOrder
    tfaToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Organisation?: OrganisationOrderByWithRelationInput
    OrganisationStructure?: OrganisationStructureOrderByWithRelationInput
    Team?: TeamOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    AssessmentTeam?: AssessmentTeamOrderByWithRelationInput
    Assessment?: AssessmentOrderByWithRelationInput
    AssessmentQuestion?: AssessmentQuestionOrderByWithRelationInput
  }

  export type QuestionAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    organisationStructureId_assessmentQuestionId?: QuestionAnswerOrganisationStructureIdAssessmentQuestionIdCompoundUniqueInput
    AND?: QuestionAnswerWhereInput | QuestionAnswerWhereInput[]
    OR?: QuestionAnswerWhereInput[]
    NOT?: QuestionAnswerWhereInput | QuestionAnswerWhereInput[]
    organisationId?: IntNullableFilter<"QuestionAnswer"> | number | null
    organisationStructureId?: IntNullableFilter<"QuestionAnswer"> | number | null
    teamId?: IntNullableFilter<"QuestionAnswer"> | number | null
    userId?: IntNullableFilter<"QuestionAnswer"> | number | null
    assessmentTeamId?: IntNullableFilter<"QuestionAnswer"> | number | null
    assessmentId?: IntNullableFilter<"QuestionAnswer"> | number | null
    assessmentStage?: StringFilter<"QuestionAnswer"> | string
    questionMongoId?: StringFilter<"QuestionAnswer"> | string
    assessmentQuestionId?: IntNullableFilter<"QuestionAnswer"> | number | null
    password?: StringNullableFilter<"QuestionAnswer"> | string | null
    rememberToken?: StringNullableFilter<"QuestionAnswer"> | string | null
    notes?: StringNullableFilter<"QuestionAnswer"> | string | null
    isActive?: BoolFilter<"QuestionAnswer"> | boolean
    secretToken?: StringNullableFilter<"QuestionAnswer"> | string | null
    tfaToken?: StringNullableFilter<"QuestionAnswer"> | string | null
    createdAt?: DateTimeFilter<"QuestionAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionAnswer"> | Date | string
    Organisation?: XOR<OrganisationNullableRelationFilter, OrganisationWhereInput> | null
    OrganisationStructure?: XOR<OrganisationStructureNullableRelationFilter, OrganisationStructureWhereInput> | null
    Team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    AssessmentTeam?: XOR<AssessmentTeamNullableRelationFilter, AssessmentTeamWhereInput> | null
    Assessment?: XOR<AssessmentNullableRelationFilter, AssessmentWhereInput> | null
    AssessmentQuestion?: XOR<AssessmentQuestionNullableRelationFilter, AssessmentQuestionWhereInput> | null
  }, "id" | "id" | "organisationStructureId_assessmentQuestionId">

  export type QuestionAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    organisationId?: SortOrderInput | SortOrder
    organisationStructureId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    assessmentTeamId?: SortOrderInput | SortOrder
    assessmentId?: SortOrderInput | SortOrder
    assessmentStage?: SortOrder
    questionMongoId?: SortOrder
    assessmentQuestionId?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    rememberToken?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    secretToken?: SortOrderInput | SortOrder
    tfaToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionAnswerCountOrderByAggregateInput
    _avg?: QuestionAnswerAvgOrderByAggregateInput
    _max?: QuestionAnswerMaxOrderByAggregateInput
    _min?: QuestionAnswerMinOrderByAggregateInput
    _sum?: QuestionAnswerSumOrderByAggregateInput
  }

  export type QuestionAnswerScalarWhereWithAggregatesInput = {
    AND?: QuestionAnswerScalarWhereWithAggregatesInput | QuestionAnswerScalarWhereWithAggregatesInput[]
    OR?: QuestionAnswerScalarWhereWithAggregatesInput[]
    NOT?: QuestionAnswerScalarWhereWithAggregatesInput | QuestionAnswerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuestionAnswer"> | number
    organisationId?: IntNullableWithAggregatesFilter<"QuestionAnswer"> | number | null
    organisationStructureId?: IntNullableWithAggregatesFilter<"QuestionAnswer"> | number | null
    teamId?: IntNullableWithAggregatesFilter<"QuestionAnswer"> | number | null
    userId?: IntNullableWithAggregatesFilter<"QuestionAnswer"> | number | null
    assessmentTeamId?: IntNullableWithAggregatesFilter<"QuestionAnswer"> | number | null
    assessmentId?: IntNullableWithAggregatesFilter<"QuestionAnswer"> | number | null
    assessmentStage?: StringWithAggregatesFilter<"QuestionAnswer"> | string
    questionMongoId?: StringWithAggregatesFilter<"QuestionAnswer"> | string
    assessmentQuestionId?: IntNullableWithAggregatesFilter<"QuestionAnswer"> | number | null
    password?: StringNullableWithAggregatesFilter<"QuestionAnswer"> | string | null
    rememberToken?: StringNullableWithAggregatesFilter<"QuestionAnswer"> | string | null
    notes?: StringNullableWithAggregatesFilter<"QuestionAnswer"> | string | null
    isActive?: BoolWithAggregatesFilter<"QuestionAnswer"> | boolean
    secretToken?: StringNullableWithAggregatesFilter<"QuestionAnswer"> | string | null
    tfaToken?: StringNullableWithAggregatesFilter<"QuestionAnswer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuestionAnswer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuestionAnswer"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    description?: StringFilter<"Role"> | string
    isActive?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    UserRole?: UserRoleListRelationFilter
    OrganisationRole?: OrganisationRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    UserRole?: UserRoleOrderByRelationAggregateInput
    OrganisationRole?: OrganisationRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    description?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    name?: StringFilter<"Role"> | string
    isActive?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    UserRole?: UserRoleListRelationFilter
    OrganisationRole?: OrganisationRoleListRelationFilter
  }, "id" | "id" | "description">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringWithAggregatesFilter<"Role"> | string
    isActive?: BoolWithAggregatesFilter<"Role"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: IntFilter<"Team"> | number
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    logo?: StringNullableFilter<"Team"> | string | null
    organisationId?: IntFilter<"Team"> | number
    password?: StringNullableFilter<"Team"> | string | null
    rememberToken?: StringNullableFilter<"Team"> | string | null
    isActive?: BoolFilter<"Team"> | boolean
    secretToken?: StringNullableFilter<"Team"> | string | null
    tfaToken?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    Organisation?: XOR<OrganisationRelationFilter, OrganisationWhereInput>
    OrganisationStructure?: OrganisationStructureListRelationFilter
    AssessmentTeam?: AssessmentTeamListRelationFilter
    QuestionAnswer?: QuestionAnswerListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    organisationId?: SortOrder
    password?: SortOrderInput | SortOrder
    rememberToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    secretToken?: SortOrderInput | SortOrder
    tfaToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Organisation?: OrganisationOrderByWithRelationInput
    OrganisationStructure?: OrganisationStructureOrderByRelationAggregateInput
    AssessmentTeam?: AssessmentTeamOrderByRelationAggregateInput
    QuestionAnswer?: QuestionAnswerOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    description?: StringNullableFilter<"Team"> | string | null
    logo?: StringNullableFilter<"Team"> | string | null
    organisationId?: IntFilter<"Team"> | number
    password?: StringNullableFilter<"Team"> | string | null
    rememberToken?: StringNullableFilter<"Team"> | string | null
    isActive?: BoolFilter<"Team"> | boolean
    secretToken?: StringNullableFilter<"Team"> | string | null
    tfaToken?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    Organisation?: XOR<OrganisationRelationFilter, OrganisationWhereInput>
    OrganisationStructure?: OrganisationStructureListRelationFilter
    AssessmentTeam?: AssessmentTeamListRelationFilter
    QuestionAnswer?: QuestionAnswerListRelationFilter
  }, "id" | "id" | "name">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    organisationId?: SortOrder
    password?: SortOrderInput | SortOrder
    rememberToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    secretToken?: SortOrderInput | SortOrder
    tfaToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Team"> | number
    name?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Team"> | string | null
    organisationId?: IntWithAggregatesFilter<"Team"> | number
    password?: StringNullableWithAggregatesFilter<"Team"> | string | null
    rememberToken?: StringNullableWithAggregatesFilter<"Team"> | string | null
    isActive?: BoolWithAggregatesFilter<"Team"> | boolean
    secretToken?: StringNullableWithAggregatesFilter<"Team"> | string | null
    tfaToken?: StringNullableWithAggregatesFilter<"Team"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type TemplateWhereInput = {
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    id?: IntFilter<"Template"> | number
    name?: StringFilter<"Template"> | string
    description?: StringNullableFilter<"Template"> | string | null
    isActive?: BoolFilter<"Template"> | boolean
    createdAt?: DateTimeFilter<"Template"> | Date | string
    updatedAt?: DateTimeFilter<"Template"> | Date | string
    TemplateStage?: TemplateStageListRelationFilter
    OrganisationTemplate?: OrganisationTemplateListRelationFilter
  }

  export type TemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    TemplateStage?: TemplateStageOrderByRelationAggregateInput
    OrganisationTemplate?: OrganisationTemplateOrderByRelationAggregateInput
  }

  export type TemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    description?: StringNullableFilter<"Template"> | string | null
    isActive?: BoolFilter<"Template"> | boolean
    createdAt?: DateTimeFilter<"Template"> | Date | string
    updatedAt?: DateTimeFilter<"Template"> | Date | string
    TemplateStage?: TemplateStageListRelationFilter
    OrganisationTemplate?: OrganisationTemplateListRelationFilter
  }, "id" | "id" | "name">

  export type TemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemplateCountOrderByAggregateInput
    _avg?: TemplateAvgOrderByAggregateInput
    _max?: TemplateMaxOrderByAggregateInput
    _min?: TemplateMinOrderByAggregateInput
    _sum?: TemplateSumOrderByAggregateInput
  }

  export type TemplateScalarWhereWithAggregatesInput = {
    AND?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    OR?: TemplateScalarWhereWithAggregatesInput[]
    NOT?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Template"> | number
    name?: StringWithAggregatesFilter<"Template"> | string
    description?: StringNullableWithAggregatesFilter<"Template"> | string | null
    isActive?: BoolWithAggregatesFilter<"Template"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Template"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Template"> | Date | string
  }

  export type TemplateStageWhereInput = {
    AND?: TemplateStageWhereInput | TemplateStageWhereInput[]
    OR?: TemplateStageWhereInput[]
    NOT?: TemplateStageWhereInput | TemplateStageWhereInput[]
    id?: IntFilter<"TemplateStage"> | number
    name?: StringFilter<"TemplateStage"> | string
    description?: StringNullableFilter<"TemplateStage"> | string | null
    isActive?: BoolFilter<"TemplateStage"> | boolean
    createdAt?: DateTimeFilter<"TemplateStage"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateStage"> | Date | string
    templateId?: IntFilter<"TemplateStage"> | number
    Template?: XOR<TemplateRelationFilter, TemplateWhereInput>
    TemplateQuestion?: TemplateQuestionListRelationFilter
  }

  export type TemplateStageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
    Template?: TemplateOrderByWithRelationInput
    TemplateQuestion?: TemplateQuestionOrderByRelationAggregateInput
  }

  export type TemplateStageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TemplateStageWhereInput | TemplateStageWhereInput[]
    OR?: TemplateStageWhereInput[]
    NOT?: TemplateStageWhereInput | TemplateStageWhereInput[]
    name?: StringFilter<"TemplateStage"> | string
    description?: StringNullableFilter<"TemplateStage"> | string | null
    isActive?: BoolFilter<"TemplateStage"> | boolean
    createdAt?: DateTimeFilter<"TemplateStage"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateStage"> | Date | string
    templateId?: IntFilter<"TemplateStage"> | number
    Template?: XOR<TemplateRelationFilter, TemplateWhereInput>
    TemplateQuestion?: TemplateQuestionListRelationFilter
  }, "id" | "id">

  export type TemplateStageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
    _count?: TemplateStageCountOrderByAggregateInput
    _avg?: TemplateStageAvgOrderByAggregateInput
    _max?: TemplateStageMaxOrderByAggregateInput
    _min?: TemplateStageMinOrderByAggregateInput
    _sum?: TemplateStageSumOrderByAggregateInput
  }

  export type TemplateStageScalarWhereWithAggregatesInput = {
    AND?: TemplateStageScalarWhereWithAggregatesInput | TemplateStageScalarWhereWithAggregatesInput[]
    OR?: TemplateStageScalarWhereWithAggregatesInput[]
    NOT?: TemplateStageScalarWhereWithAggregatesInput | TemplateStageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TemplateStage"> | number
    name?: StringWithAggregatesFilter<"TemplateStage"> | string
    description?: StringNullableWithAggregatesFilter<"TemplateStage"> | string | null
    isActive?: BoolWithAggregatesFilter<"TemplateStage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TemplateStage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TemplateStage"> | Date | string
    templateId?: IntWithAggregatesFilter<"TemplateStage"> | number
  }

  export type TemplateQuestionWhereInput = {
    AND?: TemplateQuestionWhereInput | TemplateQuestionWhereInput[]
    OR?: TemplateQuestionWhereInput[]
    NOT?: TemplateQuestionWhereInput | TemplateQuestionWhereInput[]
    id?: IntFilter<"TemplateQuestion"> | number
    question?: StringFilter<"TemplateQuestion"> | string
    description?: StringNullableFilter<"TemplateQuestion"> | string | null
    isActive?: BoolFilter<"TemplateQuestion"> | boolean
    templateStageId?: IntFilter<"TemplateQuestion"> | number
    createdAt?: DateTimeFilter<"TemplateQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateQuestion"> | Date | string
    templateId?: IntNullableFilter<"TemplateQuestion"> | number | null
    TemplateStage?: XOR<TemplateStageRelationFilter, TemplateStageWhereInput>
    TemplateQuestionAnswer?: TemplateQuestionAnswerListRelationFilter
  }

  export type TemplateQuestionOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    templateStageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrderInput | SortOrder
    TemplateStage?: TemplateStageOrderByWithRelationInput
    TemplateQuestionAnswer?: TemplateQuestionAnswerOrderByRelationAggregateInput
  }

  export type TemplateQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TemplateQuestionWhereInput | TemplateQuestionWhereInput[]
    OR?: TemplateQuestionWhereInput[]
    NOT?: TemplateQuestionWhereInput | TemplateQuestionWhereInput[]
    question?: StringFilter<"TemplateQuestion"> | string
    description?: StringNullableFilter<"TemplateQuestion"> | string | null
    isActive?: BoolFilter<"TemplateQuestion"> | boolean
    templateStageId?: IntFilter<"TemplateQuestion"> | number
    createdAt?: DateTimeFilter<"TemplateQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateQuestion"> | Date | string
    templateId?: IntNullableFilter<"TemplateQuestion"> | number | null
    TemplateStage?: XOR<TemplateStageRelationFilter, TemplateStageWhereInput>
    TemplateQuestionAnswer?: TemplateQuestionAnswerListRelationFilter
  }, "id" | "id">

  export type TemplateQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    templateStageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrderInput | SortOrder
    _count?: TemplateQuestionCountOrderByAggregateInput
    _avg?: TemplateQuestionAvgOrderByAggregateInput
    _max?: TemplateQuestionMaxOrderByAggregateInput
    _min?: TemplateQuestionMinOrderByAggregateInput
    _sum?: TemplateQuestionSumOrderByAggregateInput
  }

  export type TemplateQuestionScalarWhereWithAggregatesInput = {
    AND?: TemplateQuestionScalarWhereWithAggregatesInput | TemplateQuestionScalarWhereWithAggregatesInput[]
    OR?: TemplateQuestionScalarWhereWithAggregatesInput[]
    NOT?: TemplateQuestionScalarWhereWithAggregatesInput | TemplateQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TemplateQuestion"> | number
    question?: StringWithAggregatesFilter<"TemplateQuestion"> | string
    description?: StringNullableWithAggregatesFilter<"TemplateQuestion"> | string | null
    isActive?: BoolWithAggregatesFilter<"TemplateQuestion"> | boolean
    templateStageId?: IntWithAggregatesFilter<"TemplateQuestion"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TemplateQuestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TemplateQuestion"> | Date | string
    templateId?: IntNullableWithAggregatesFilter<"TemplateQuestion"> | number | null
  }

  export type TemplateQuestionAnswerWhereInput = {
    AND?: TemplateQuestionAnswerWhereInput | TemplateQuestionAnswerWhereInput[]
    OR?: TemplateQuestionAnswerWhereInput[]
    NOT?: TemplateQuestionAnswerWhereInput | TemplateQuestionAnswerWhereInput[]
    id?: IntFilter<"TemplateQuestionAnswer"> | number
    answer?: StringFilter<"TemplateQuestionAnswer"> | string
    description?: StringNullableFilter<"TemplateQuestionAnswer"> | string | null
    isActive?: BoolFilter<"TemplateQuestionAnswer"> | boolean
    templateQuestionId?: IntFilter<"TemplateQuestionAnswer"> | number
    createdAt?: DateTimeFilter<"TemplateQuestionAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateQuestionAnswer"> | Date | string
    TemplateQuestion?: XOR<TemplateQuestionRelationFilter, TemplateQuestionWhereInput>
  }

  export type TemplateQuestionAnswerOrderByWithRelationInput = {
    id?: SortOrder
    answer?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    templateQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    TemplateQuestion?: TemplateQuestionOrderByWithRelationInput
  }

  export type TemplateQuestionAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TemplateQuestionAnswerWhereInput | TemplateQuestionAnswerWhereInput[]
    OR?: TemplateQuestionAnswerWhereInput[]
    NOT?: TemplateQuestionAnswerWhereInput | TemplateQuestionAnswerWhereInput[]
    answer?: StringFilter<"TemplateQuestionAnswer"> | string
    description?: StringNullableFilter<"TemplateQuestionAnswer"> | string | null
    isActive?: BoolFilter<"TemplateQuestionAnswer"> | boolean
    templateQuestionId?: IntFilter<"TemplateQuestionAnswer"> | number
    createdAt?: DateTimeFilter<"TemplateQuestionAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateQuestionAnswer"> | Date | string
    TemplateQuestion?: XOR<TemplateQuestionRelationFilter, TemplateQuestionWhereInput>
  }, "id" | "id">

  export type TemplateQuestionAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    answer?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    templateQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemplateQuestionAnswerCountOrderByAggregateInput
    _avg?: TemplateQuestionAnswerAvgOrderByAggregateInput
    _max?: TemplateQuestionAnswerMaxOrderByAggregateInput
    _min?: TemplateQuestionAnswerMinOrderByAggregateInput
    _sum?: TemplateQuestionAnswerSumOrderByAggregateInput
  }

  export type TemplateQuestionAnswerScalarWhereWithAggregatesInput = {
    AND?: TemplateQuestionAnswerScalarWhereWithAggregatesInput | TemplateQuestionAnswerScalarWhereWithAggregatesInput[]
    OR?: TemplateQuestionAnswerScalarWhereWithAggregatesInput[]
    NOT?: TemplateQuestionAnswerScalarWhereWithAggregatesInput | TemplateQuestionAnswerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TemplateQuestionAnswer"> | number
    answer?: StringWithAggregatesFilter<"TemplateQuestionAnswer"> | string
    description?: StringNullableWithAggregatesFilter<"TemplateQuestionAnswer"> | string | null
    isActive?: BoolWithAggregatesFilter<"TemplateQuestionAnswer"> | boolean
    templateQuestionId?: IntWithAggregatesFilter<"TemplateQuestionAnswer"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TemplateQuestionAnswer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TemplateQuestionAnswer"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    company?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    rememberToken?: StringNullableFilter<"User"> | string | null
    logo?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    disabled?: BoolFilter<"User"> | boolean
    tfaSecret?: StringNullableFilter<"User"> | string | null
    fpwToken?: StringNullableFilter<"User"> | string | null
    qrCodeVisibility?: BoolFilter<"User"> | boolean
    isDureation?: BoolFilter<"User"> | boolean
    tfaStatus?: BoolFilter<"User"> | boolean
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    startDate?: DateTimeNullableFilter<"User"> | Date | string | null
    endDate?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    Organisation?: XOR<OrganisationNullableRelationFilter, OrganisationWhereInput> | null
    UserRole?: UserRoleListRelationFilter
    OrganisationStructure?: OrganisationStructureListRelationFilter
    QuestionAnswer?: QuestionAnswerListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    company?: SortOrderInput | SortOrder
    password?: SortOrder
    rememberToken?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    isActive?: SortOrder
    disabled?: SortOrder
    tfaSecret?: SortOrderInput | SortOrder
    fpwToken?: SortOrderInput | SortOrder
    qrCodeVisibility?: SortOrder
    isDureation?: SortOrder
    tfaStatus?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Organisation?: OrganisationOrderByWithRelationInput
    UserRole?: UserRoleOrderByRelationAggregateInput
    OrganisationStructure?: OrganisationStructureOrderByRelationAggregateInput
    QuestionAnswer?: QuestionAnswerOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    company?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    rememberToken?: StringNullableFilter<"User"> | string | null
    logo?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    disabled?: BoolFilter<"User"> | boolean
    tfaSecret?: StringNullableFilter<"User"> | string | null
    fpwToken?: StringNullableFilter<"User"> | string | null
    qrCodeVisibility?: BoolFilter<"User"> | boolean
    isDureation?: BoolFilter<"User"> | boolean
    tfaStatus?: BoolFilter<"User"> | boolean
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    startDate?: DateTimeNullableFilter<"User"> | Date | string | null
    endDate?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    Organisation?: XOR<OrganisationNullableRelationFilter, OrganisationWhereInput> | null
    UserRole?: UserRoleListRelationFilter
    OrganisationStructure?: OrganisationStructureListRelationFilter
    QuestionAnswer?: QuestionAnswerListRelationFilter
  }, "id" | "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    company?: SortOrderInput | SortOrder
    password?: SortOrder
    rememberToken?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    isActive?: SortOrder
    disabled?: SortOrder
    tfaSecret?: SortOrderInput | SortOrder
    fpwToken?: SortOrderInput | SortOrder
    qrCodeVisibility?: SortOrder
    isDureation?: SortOrder
    tfaStatus?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    company?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    rememberToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    logo?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    disabled?: BoolWithAggregatesFilter<"User"> | boolean
    tfaSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    fpwToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    qrCodeVisibility?: BoolWithAggregatesFilter<"User"> | boolean
    isDureation?: BoolWithAggregatesFilter<"User"> | boolean
    tfaStatus?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: IntFilter<"UserRole"> | number
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    isActive?: BoolFilter<"UserRole"> | boolean
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
    updatedAt?: DateTimeFilter<"UserRole"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    isActive?: BoolFilter<"UserRole"> | boolean
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
    updatedAt?: DateTimeFilter<"UserRole"> | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Role?: XOR<RoleRelationFilter, RoleWhereInput>
  }, "id" | "id">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _avg?: UserRoleAvgOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
    _sum?: UserRoleSumOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserRole"> | number
    userId?: IntWithAggregatesFilter<"UserRole"> | number
    roleId?: IntWithAggregatesFilter<"UserRole"> | number
    isActive?: BoolWithAggregatesFilter<"UserRole"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
  }

  export type AssessmentCreateInput = {
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation: OrganisationCreateNestedOneWithoutAssessmentInput
    AssessmentQuestion?: AssessmentQuestionCreateNestedManyWithoutAssessmentInput
    OrganisationTemplate?: OrganisationTemplateCreateNestedOneWithoutAssessmentInput
    AssessmentTeam?: AssessmentTeamCreateNestedManyWithoutAssessmentInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organisationTemplateId?: number | null
    AssessmentQuestion?: AssessmentQuestionUncheckedCreateNestedManyWithoutAssessmentInput
    AssessmentTeam?: AssessmentTeamUncheckedCreateNestedManyWithoutAssessmentInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneRequiredWithoutAssessmentNestedInput
    AssessmentQuestion?: AssessmentQuestionUpdateManyWithoutAssessmentNestedInput
    OrganisationTemplate?: OrganisationTemplateUpdateOneWithoutAssessmentNestedInput
    AssessmentTeam?: AssessmentTeamUpdateManyWithoutAssessmentNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organisationTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    AssessmentQuestion?: AssessmentQuestionUncheckedUpdateManyWithoutAssessmentNestedInput
    AssessmentTeam?: AssessmentTeamUncheckedUpdateManyWithoutAssessmentNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organisationTemplateId?: number | null
  }

  export type AssessmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organisationTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AssessmentQuestionCreateInput = {
    assessmentStage: string
    questionMongoId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Assessment: AssessmentCreateNestedOneWithoutAssessmentQuestionInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutAssessmentQuestionInput
  }

  export type AssessmentQuestionUncheckedCreateInput = {
    id?: number
    assessmentId: number
    assessmentStage: string
    questionMongoId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutAssessmentQuestionInput
  }

  export type AssessmentQuestionUpdateInput = {
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Assessment?: AssessmentUpdateOneRequiredWithoutAssessmentQuestionNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutAssessmentQuestionNestedInput
  }

  export type AssessmentQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutAssessmentQuestionNestedInput
  }

  export type AssessmentQuestionCreateManyInput = {
    id?: number
    assessmentId: number
    assessmentStage: string
    questionMongoId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentQuestionUpdateManyMutationInput = {
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentTeamCreateInput = {
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Assessment: AssessmentCreateNestedOneWithoutAssessmentTeamInput
    Organisation: OrganisationCreateNestedOneWithoutAssessmentTeamInput
    Team: TeamCreateNestedOneWithoutAssessmentTeamInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutAssessmentTeamInput
  }

  export type AssessmentTeamUncheckedCreateInput = {
    id?: number
    assessmentId: number
    organisationId: number
    teamId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutAssessmentTeamInput
  }

  export type AssessmentTeamUpdateInput = {
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Assessment?: AssessmentUpdateOneRequiredWithoutAssessmentTeamNestedInput
    Organisation?: OrganisationUpdateOneRequiredWithoutAssessmentTeamNestedInput
    Team?: TeamUpdateOneRequiredWithoutAssessmentTeamNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutAssessmentTeamNestedInput
  }

  export type AssessmentTeamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutAssessmentTeamNestedInput
  }

  export type AssessmentTeamCreateManyInput = {
    id?: number
    assessmentId: number
    organisationId: number
    teamId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentTeamUpdateManyMutationInput = {
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentTeamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationCreateInput = {
    name: string
    description?: string | null
    isActive?: boolean | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Owner?: UserCreateNestedOneWithoutOrganisationInput
    Assessment?: AssessmentCreateNestedManyWithoutOrganisationInput
    Team?: TeamCreateNestedManyWithoutOrganisationInput
    OrganisationTemplate?: OrganisationTemplateCreateNestedManyWithoutOrganisationInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutOrganisationInput
    AssessmentTeam?: AssessmentTeamCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    ownerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutOrganisationInput
    Team?: TeamUncheckedCreateNestedManyWithoutOrganisationInput
    OrganisationTemplate?: OrganisationTemplateUncheckedCreateNestedManyWithoutOrganisationInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutOrganisationInput
    AssessmentTeam?: AssessmentTeamUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Owner?: UserUpdateOneWithoutOrganisationNestedInput
    Assessment?: AssessmentUpdateManyWithoutOrganisationNestedInput
    Team?: TeamUpdateManyWithoutOrganisationNestedInput
    OrganisationTemplate?: OrganisationTemplateUpdateManyWithoutOrganisationNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutOrganisationNestedInput
    AssessmentTeam?: AssessmentTeamUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Assessment?: AssessmentUncheckedUpdateManyWithoutOrganisationNestedInput
    Team?: TeamUncheckedUpdateManyWithoutOrganisationNestedInput
    OrganisationTemplate?: OrganisationTemplateUncheckedUpdateManyWithoutOrganisationNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutOrganisationNestedInput
    AssessmentTeam?: AssessmentTeamUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    ownerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganisationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationRoleCreateInput = {
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationStructure: OrganisationStructureCreateNestedOneWithoutOrganisationRoleInput
    Role: RoleCreateNestedOneWithoutOrganisationRoleInput
  }

  export type OrganisationRoleUncheckedCreateInput = {
    id?: number
    isActive?: boolean | null
    organisationStructureId: number
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganisationRoleUpdateInput = {
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationStructure?: OrganisationStructureUpdateOneRequiredWithoutOrganisationRoleNestedInput
    Role?: RoleUpdateOneRequiredWithoutOrganisationRoleNestedInput
  }

  export type OrganisationRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organisationStructureId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationRoleCreateManyInput = {
    id?: number
    isActive?: boolean | null
    organisationStructureId: number
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganisationRoleUpdateManyMutationInput = {
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organisationStructureId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationStructureCreateInput = {
    organisationId: number
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Team?: TeamCreateNestedOneWithoutOrganisationStructureInput
    OrganisationRole?: OrganisationRoleCreateNestedManyWithoutOrganisationStructureInput
    User: UserCreateNestedOneWithoutOrganisationStructureInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutOrganisationStructureInput
  }

  export type OrganisationStructureUncheckedCreateInput = {
    id?: number
    organisationId: number
    teamId?: number | null
    userId: number
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationRole?: OrganisationRoleUncheckedCreateNestedManyWithoutOrganisationStructureInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutOrganisationStructureInput
  }

  export type OrganisationStructureUpdateInput = {
    organisationId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Team?: TeamUpdateOneWithoutOrganisationStructureNestedInput
    OrganisationRole?: OrganisationRoleUpdateManyWithoutOrganisationStructureNestedInput
    User?: UserUpdateOneRequiredWithoutOrganisationStructureNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutOrganisationStructureNestedInput
  }

  export type OrganisationStructureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationRole?: OrganisationRoleUncheckedUpdateManyWithoutOrganisationStructureNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutOrganisationStructureNestedInput
  }

  export type OrganisationStructureCreateManyInput = {
    id?: number
    organisationId: number
    teamId?: number | null
    userId: number
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganisationStructureUpdateManyMutationInput = {
    organisationId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationStructureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationTemplateCreateInput = {
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation: OrganisationCreateNestedOneWithoutOrganisationTemplateInput
    Template?: TemplateCreateNestedOneWithoutOrganisationTemplateInput
    Assessment?: AssessmentCreateNestedManyWithoutOrganisationTemplateInput
  }

  export type OrganisationTemplateUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId: number
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutOrganisationTemplateInput
  }

  export type OrganisationTemplateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneRequiredWithoutOrganisationTemplateNestedInput
    Template?: TemplateUpdateOneWithoutOrganisationTemplateNestedInput
    Assessment?: AssessmentUpdateManyWithoutOrganisationTemplateNestedInput
  }

  export type OrganisationTemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
    Assessment?: AssessmentUncheckedUpdateManyWithoutOrganisationTemplateNestedInput
  }

  export type OrganisationTemplateCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId: number
  }

  export type OrganisationTemplateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationTemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionAnswerCreateInput = {
    assessmentStage: string
    questionMongoId: string
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation?: OrganisationCreateNestedOneWithoutQuestionAnswerInput
    OrganisationStructure?: OrganisationStructureCreateNestedOneWithoutQuestionAnswerInput
    Team?: TeamCreateNestedOneWithoutQuestionAnswerInput
    User?: UserCreateNestedOneWithoutQuestionAnswerInput
    AssessmentTeam?: AssessmentTeamCreateNestedOneWithoutQuestionAnswerInput
    Assessment?: AssessmentCreateNestedOneWithoutQuestionAnswerInput
    AssessmentQuestion?: AssessmentQuestionCreateNestedOneWithoutQuestionAnswerInput
  }

  export type QuestionAnswerUncheckedCreateInput = {
    id?: number
    organisationId?: number | null
    organisationStructureId?: number | null
    teamId?: number | null
    userId?: number | null
    assessmentTeamId?: number | null
    assessmentId?: number | null
    assessmentStage: string
    questionMongoId: string
    assessmentQuestionId?: number | null
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerUpdateInput = {
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneWithoutQuestionAnswerNestedInput
    OrganisationStructure?: OrganisationStructureUpdateOneWithoutQuestionAnswerNestedInput
    Team?: TeamUpdateOneWithoutQuestionAnswerNestedInput
    User?: UserUpdateOneWithoutQuestionAnswerNestedInput
    AssessmentTeam?: AssessmentTeamUpdateOneWithoutQuestionAnswerNestedInput
    Assessment?: AssessmentUpdateOneWithoutQuestionAnswerNestedInput
    AssessmentQuestion?: AssessmentQuestionUpdateOneWithoutQuestionAnswerNestedInput
  }

  export type QuestionAnswerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationStructureId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    assessmentQuestionId?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerCreateManyInput = {
    id?: number
    organisationId?: number | null
    organisationStructureId?: number | null
    teamId?: number | null
    userId?: number | null
    assessmentTeamId?: number | null
    assessmentId?: number | null
    assessmentStage: string
    questionMongoId: string
    assessmentQuestionId?: number | null
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerUpdateManyMutationInput = {
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationStructureId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    assessmentQuestionId?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    name: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleCreateNestedManyWithoutRoleInput
    OrganisationRole?: OrganisationRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
    OrganisationRole?: OrganisationRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUpdateManyWithoutRoleNestedInput
    OrganisationRole?: OrganisationRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
    OrganisationRole?: OrganisationRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation: OrganisationCreateNestedOneWithoutTeamInput
    OrganisationStructure?: OrganisationStructureCreateNestedManyWithoutTeamInput
    AssessmentTeam?: AssessmentTeamCreateNestedManyWithoutTeamInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationStructure?: OrganisationStructureUncheckedCreateNestedManyWithoutTeamInput
    AssessmentTeam?: AssessmentTeamUncheckedCreateNestedManyWithoutTeamInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneRequiredWithoutTeamNestedInput
    OrganisationStructure?: OrganisationStructureUpdateManyWithoutTeamNestedInput
    AssessmentTeam?: AssessmentTeamUpdateManyWithoutTeamNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationStructure?: OrganisationStructureUncheckedUpdateManyWithoutTeamNestedInput
    AssessmentTeam?: AssessmentTeamUncheckedUpdateManyWithoutTeamNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCreateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    TemplateStage?: TemplateStageCreateNestedManyWithoutTemplateInput
    OrganisationTemplate?: OrganisationTemplateCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    TemplateStage?: TemplateStageUncheckedCreateNestedManyWithoutTemplateInput
    OrganisationTemplate?: OrganisationTemplateUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TemplateStage?: TemplateStageUpdateManyWithoutTemplateNestedInput
    OrganisationTemplate?: OrganisationTemplateUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TemplateStage?: TemplateStageUncheckedUpdateManyWithoutTemplateNestedInput
    OrganisationTemplate?: OrganisationTemplateUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateStageCreateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Template: TemplateCreateNestedOneWithoutTemplateStageInput
    TemplateQuestion?: TemplateQuestionCreateNestedManyWithoutTemplateStageInput
  }

  export type TemplateStageUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId: number
    TemplateQuestion?: TemplateQuestionUncheckedCreateNestedManyWithoutTemplateStageInput
  }

  export type TemplateStageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Template?: TemplateUpdateOneRequiredWithoutTemplateStageNestedInput
    TemplateQuestion?: TemplateQuestionUpdateManyWithoutTemplateStageNestedInput
  }

  export type TemplateStageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
    TemplateQuestion?: TemplateQuestionUncheckedUpdateManyWithoutTemplateStageNestedInput
  }

  export type TemplateStageCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId: number
  }

  export type TemplateStageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateStageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateQuestionCreateInput = {
    question: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: number | null
    TemplateStage: TemplateStageCreateNestedOneWithoutTemplateQuestionInput
    TemplateQuestionAnswer?: TemplateQuestionAnswerCreateNestedManyWithoutTemplateQuestionInput
  }

  export type TemplateQuestionUncheckedCreateInput = {
    id?: number
    question: string
    description?: string | null
    isActive?: boolean
    templateStageId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: number | null
    TemplateQuestionAnswer?: TemplateQuestionAnswerUncheckedCreateNestedManyWithoutTemplateQuestionInput
  }

  export type TemplateQuestionUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    TemplateStage?: TemplateStageUpdateOneRequiredWithoutTemplateQuestionNestedInput
    TemplateQuestionAnswer?: TemplateQuestionAnswerUpdateManyWithoutTemplateQuestionNestedInput
  }

  export type TemplateQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateStageId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    TemplateQuestionAnswer?: TemplateQuestionAnswerUncheckedUpdateManyWithoutTemplateQuestionNestedInput
  }

  export type TemplateQuestionCreateManyInput = {
    id?: number
    question: string
    description?: string | null
    isActive?: boolean
    templateStageId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: number | null
  }

  export type TemplateQuestionUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TemplateQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateStageId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TemplateQuestionAnswerCreateInput = {
    answer: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    TemplateQuestion: TemplateQuestionCreateNestedOneWithoutTemplateQuestionAnswerInput
  }

  export type TemplateQuestionAnswerUncheckedCreateInput = {
    id?: number
    answer: string
    description?: string | null
    isActive?: boolean
    templateQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateQuestionAnswerUpdateInput = {
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TemplateQuestion?: TemplateQuestionUpdateOneRequiredWithoutTemplateQuestionAnswerNestedInput
  }

  export type TemplateQuestionAnswerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateQuestionAnswerCreateManyInput = {
    id?: number
    answer: string
    description?: string | null
    isActive?: boolean
    templateQuestionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateQuestionAnswerUpdateManyMutationInput = {
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateQuestionAnswerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateQuestionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    name: string
    firstName?: string | null
    lastName?: string | null
    email: string
    company?: string | null
    password: string
    rememberToken?: string | null
    logo?: string | null
    isActive?: boolean
    disabled?: boolean
    tfaSecret?: string | null
    fpwToken?: string | null
    qrCodeVisibility?: boolean
    isDureation?: boolean
    tfaStatus?: boolean
    emailVerifiedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation?: OrganisationCreateNestedOneWithoutOwnerInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    OrganisationStructure?: OrganisationStructureCreateNestedManyWithoutUserInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    firstName?: string | null
    lastName?: string | null
    email: string
    company?: string | null
    password: string
    rememberToken?: string | null
    logo?: string | null
    isActive?: boolean
    disabled?: boolean
    tfaSecret?: string | null
    fpwToken?: string | null
    qrCodeVisibility?: boolean
    isDureation?: boolean
    tfaStatus?: boolean
    emailVerifiedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation?: OrganisationUncheckedCreateNestedOneWithoutOwnerInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    OrganisationStructure?: OrganisationStructureUncheckedCreateNestedManyWithoutUserInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    tfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fpwToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeVisibility?: BoolFieldUpdateOperationsInput | boolean
    isDureation?: BoolFieldUpdateOperationsInput | boolean
    tfaStatus?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneWithoutOwnerNestedInput
    UserRole?: UserRoleUpdateManyWithoutUserNestedInput
    OrganisationStructure?: OrganisationStructureUpdateManyWithoutUserNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    tfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fpwToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeVisibility?: BoolFieldUpdateOperationsInput | boolean
    isDureation?: BoolFieldUpdateOperationsInput | boolean
    tfaStatus?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUncheckedUpdateOneWithoutOwnerNestedInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    OrganisationStructure?: OrganisationStructureUncheckedUpdateManyWithoutUserNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    firstName?: string | null
    lastName?: string | null
    email: string
    company?: string | null
    password: string
    rememberToken?: string | null
    logo?: string | null
    isActive?: boolean
    disabled?: boolean
    tfaSecret?: string | null
    fpwToken?: string | null
    qrCodeVisibility?: boolean
    isDureation?: boolean
    tfaStatus?: boolean
    emailVerifiedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    tfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fpwToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeVisibility?: BoolFieldUpdateOperationsInput | boolean
    isDureation?: BoolFieldUpdateOperationsInput | boolean
    tfaStatus?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    tfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fpwToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeVisibility?: BoolFieldUpdateOperationsInput | boolean
    isDureation?: BoolFieldUpdateOperationsInput | boolean
    tfaStatus?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutUserRoleInput
    Role: RoleCreateNestedOneWithoutUserRoleInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: number
    userId: number
    roleId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRoleUpdateInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutUserRoleNestedInput
    Role?: RoleUpdateOneRequiredWithoutUserRoleNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyInput = {
    id?: number
    userId: number
    roleId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRoleUpdateManyMutationInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type OrganisationRelationFilter = {
    is?: OrganisationWhereInput
    isNot?: OrganisationWhereInput
  }

  export type AssessmentQuestionListRelationFilter = {
    every?: AssessmentQuestionWhereInput
    some?: AssessmentQuestionWhereInput
    none?: AssessmentQuestionWhereInput
  }

  export type OrganisationTemplateNullableRelationFilter = {
    is?: OrganisationTemplateWhereInput | null
    isNot?: OrganisationTemplateWhereInput | null
  }

  export type AssessmentTeamListRelationFilter = {
    every?: AssessmentTeamWhereInput
    some?: AssessmentTeamWhereInput
    none?: AssessmentTeamWhereInput
  }

  export type QuestionAnswerListRelationFilter = {
    every?: QuestionAnswerWhereInput
    some?: QuestionAnswerWhereInput
    none?: QuestionAnswerWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AssessmentQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssessmentTeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    organisationId?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    isActive?: SortOrder
    secretToken?: SortOrder
    tfaToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organisationTemplateId?: SortOrder
  }

  export type AssessmentAvgOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    organisationTemplateId?: SortOrder
  }

  export type AssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    organisationId?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    isActive?: SortOrder
    secretToken?: SortOrder
    tfaToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organisationTemplateId?: SortOrder
  }

  export type AssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    organisationId?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    isActive?: SortOrder
    secretToken?: SortOrder
    tfaToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organisationTemplateId?: SortOrder
  }

  export type AssessmentSumOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    organisationTemplateId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AssessmentRelationFilter = {
    is?: AssessmentWhereInput
    isNot?: AssessmentWhereInput
  }

  export type AssessmentQuestionAssessmentIdQuestionMongoIdCompoundUniqueInput = {
    assessmentId: number
    questionMongoId: string
  }

  export type AssessmentQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    assessmentStage?: SortOrder
    questionMongoId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssessmentQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
  }

  export type AssessmentQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    assessmentStage?: SortOrder
    questionMongoId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssessmentQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    assessmentStage?: SortOrder
    questionMongoId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssessmentQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
  }

  export type TeamRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type AssessmentTeamAssessmentIdTeamIdCompoundUniqueInput = {
    assessmentId: number
    teamId: number
  }

  export type AssessmentTeamCountOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    organisationId?: SortOrder
    teamId?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    isActive?: SortOrder
    secretToken?: SortOrder
    tfaToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssessmentTeamAvgOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    organisationId?: SortOrder
    teamId?: SortOrder
  }

  export type AssessmentTeamMaxOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    organisationId?: SortOrder
    teamId?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    isActive?: SortOrder
    secretToken?: SortOrder
    tfaToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssessmentTeamMinOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    organisationId?: SortOrder
    teamId?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    isActive?: SortOrder
    secretToken?: SortOrder
    tfaToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssessmentTeamSumOrderByAggregateInput = {
    id?: SortOrder
    assessmentId?: SortOrder
    organisationId?: SortOrder
    teamId?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AssessmentListRelationFilter = {
    every?: AssessmentWhereInput
    some?: AssessmentWhereInput
    none?: AssessmentWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type OrganisationTemplateListRelationFilter = {
    every?: OrganisationTemplateWhereInput
    some?: OrganisationTemplateWhereInput
    none?: OrganisationTemplateWhereInput
  }

  export type AssessmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganisationTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganisationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    logo?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganisationAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
  }

  export type OrganisationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    logo?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganisationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    logo?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganisationSumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type OrganisationStructureRelationFilter = {
    is?: OrganisationStructureWhereInput
    isNot?: OrganisationStructureWhereInput
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type OrganisationRoleOrganisationStructureIdRoleIdCompoundUniqueInput = {
    organisationStructureId: number
    roleId: number
  }

  export type OrganisationRoleCountOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    organisationStructureId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganisationRoleAvgOrderByAggregateInput = {
    id?: SortOrder
    organisationStructureId?: SortOrder
    roleId?: SortOrder
  }

  export type OrganisationRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    organisationStructureId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganisationRoleMinOrderByAggregateInput = {
    id?: SortOrder
    isActive?: SortOrder
    organisationStructureId?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganisationRoleSumOrderByAggregateInput = {
    id?: SortOrder
    organisationStructureId?: SortOrder
    roleId?: SortOrder
  }

  export type TeamNullableRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type OrganisationRoleListRelationFilter = {
    every?: OrganisationRoleWhereInput
    some?: OrganisationRoleWhereInput
    none?: OrganisationRoleWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type OrganisationRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganisationStructureTeamIdUserIdCompoundUniqueInput = {
    teamId: number
    userId: number
  }

  export type OrganisationStructureCountOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganisationStructureAvgOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type OrganisationStructureMaxOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganisationStructureMinOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganisationStructureSumOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type TemplateNullableRelationFilter = {
    is?: TemplateWhereInput | null
    isNot?: TemplateWhereInput | null
  }

  export type OrganisationTemplateOrganisationIdTemplateIdCompoundUniqueInput = {
    organisationId: number
    templateId: number
  }

  export type OrganisationTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    organisationId?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    isActive?: SortOrder
    secretToken?: SortOrder
    tfaToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
  }

  export type OrganisationTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    templateId?: SortOrder
  }

  export type OrganisationTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    organisationId?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    isActive?: SortOrder
    secretToken?: SortOrder
    tfaToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
  }

  export type OrganisationTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    organisationId?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    isActive?: SortOrder
    secretToken?: SortOrder
    tfaToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
  }

  export type OrganisationTemplateSumOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    templateId?: SortOrder
  }

  export type OrganisationNullableRelationFilter = {
    is?: OrganisationWhereInput | null
    isNot?: OrganisationWhereInput | null
  }

  export type OrganisationStructureNullableRelationFilter = {
    is?: OrganisationStructureWhereInput | null
    isNot?: OrganisationStructureWhereInput | null
  }

  export type AssessmentTeamNullableRelationFilter = {
    is?: AssessmentTeamWhereInput | null
    isNot?: AssessmentTeamWhereInput | null
  }

  export type AssessmentNullableRelationFilter = {
    is?: AssessmentWhereInput | null
    isNot?: AssessmentWhereInput | null
  }

  export type AssessmentQuestionNullableRelationFilter = {
    is?: AssessmentQuestionWhereInput | null
    isNot?: AssessmentQuestionWhereInput | null
  }

  export type QuestionAnswerOrganisationStructureIdAssessmentQuestionIdCompoundUniqueInput = {
    organisationStructureId: number
    assessmentQuestionId: number
  }

  export type QuestionAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    organisationStructureId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    assessmentTeamId?: SortOrder
    assessmentId?: SortOrder
    assessmentStage?: SortOrder
    questionMongoId?: SortOrder
    assessmentQuestionId?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    secretToken?: SortOrder
    tfaToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionAnswerAvgOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    organisationStructureId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    assessmentTeamId?: SortOrder
    assessmentId?: SortOrder
    assessmentQuestionId?: SortOrder
  }

  export type QuestionAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    organisationStructureId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    assessmentTeamId?: SortOrder
    assessmentId?: SortOrder
    assessmentStage?: SortOrder
    questionMongoId?: SortOrder
    assessmentQuestionId?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    secretToken?: SortOrder
    tfaToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    organisationStructureId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    assessmentTeamId?: SortOrder
    assessmentId?: SortOrder
    assessmentStage?: SortOrder
    questionMongoId?: SortOrder
    assessmentQuestionId?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    secretToken?: SortOrder
    tfaToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionAnswerSumOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
    organisationStructureId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    assessmentTeamId?: SortOrder
    assessmentId?: SortOrder
    assessmentQuestionId?: SortOrder
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrganisationStructureListRelationFilter = {
    every?: OrganisationStructureWhereInput
    some?: OrganisationStructureWhereInput
    none?: OrganisationStructureWhereInput
  }

  export type OrganisationStructureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    organisationId?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    isActive?: SortOrder
    secretToken?: SortOrder
    tfaToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    organisationId?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    isActive?: SortOrder
    secretToken?: SortOrder
    tfaToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    organisationId?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    isActive?: SortOrder
    secretToken?: SortOrder
    tfaToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    id?: SortOrder
    organisationId?: SortOrder
  }

  export type TemplateStageListRelationFilter = {
    every?: TemplateStageWhereInput
    some?: TemplateStageWhereInput
    none?: TemplateStageWhereInput
  }

  export type TemplateStageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TemplateRelationFilter = {
    is?: TemplateWhereInput
    isNot?: TemplateWhereInput
  }

  export type TemplateQuestionListRelationFilter = {
    every?: TemplateQuestionWhereInput
    some?: TemplateQuestionWhereInput
    none?: TemplateQuestionWhereInput
  }

  export type TemplateQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateStageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateStageAvgOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateStageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateStageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateStageSumOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateStageRelationFilter = {
    is?: TemplateStageWhereInput
    isNot?: TemplateStageWhereInput
  }

  export type TemplateQuestionAnswerListRelationFilter = {
    every?: TemplateQuestionAnswerWhereInput
    some?: TemplateQuestionAnswerWhereInput
    none?: TemplateQuestionAnswerWhereInput
  }

  export type TemplateQuestionAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    templateStageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    templateStageId?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    templateStageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    templateStageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    templateStageId?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateQuestionRelationFilter = {
    is?: TemplateQuestionWhereInput
    isNot?: TemplateQuestionWhereInput
  }

  export type TemplateQuestionAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    answer?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    templateQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateQuestionAnswerAvgOrderByAggregateInput = {
    id?: SortOrder
    templateQuestionId?: SortOrder
  }

  export type TemplateQuestionAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    answer?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    templateQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateQuestionAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    answer?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    templateQuestionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateQuestionAnswerSumOrderByAggregateInput = {
    id?: SortOrder
    templateQuestionId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    company?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    logo?: SortOrder
    isActive?: SortOrder
    disabled?: SortOrder
    tfaSecret?: SortOrder
    fpwToken?: SortOrder
    qrCodeVisibility?: SortOrder
    isDureation?: SortOrder
    tfaStatus?: SortOrder
    emailVerifiedAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    deletedAt?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    company?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    logo?: SortOrder
    isActive?: SortOrder
    disabled?: SortOrder
    tfaSecret?: SortOrder
    fpwToken?: SortOrder
    qrCodeVisibility?: SortOrder
    isDureation?: SortOrder
    tfaStatus?: SortOrder
    emailVerifiedAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    deletedAt?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    company?: SortOrder
    password?: SortOrder
    rememberToken?: SortOrder
    logo?: SortOrder
    isActive?: SortOrder
    disabled?: SortOrder
    tfaSecret?: SortOrder
    fpwToken?: SortOrder
    qrCodeVisibility?: SortOrder
    isDureation?: SortOrder
    tfaStatus?: SortOrder
    emailVerifiedAt?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    deletedAt?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRoleAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRoleSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type OrganisationCreateNestedOneWithoutAssessmentInput = {
    create?: XOR<OrganisationCreateWithoutAssessmentInput, OrganisationUncheckedCreateWithoutAssessmentInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutAssessmentInput
    connect?: OrganisationWhereUniqueInput
  }

  export type AssessmentQuestionCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput> | AssessmentQuestionCreateWithoutAssessmentInput[] | AssessmentQuestionUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentQuestionCreateOrConnectWithoutAssessmentInput | AssessmentQuestionCreateOrConnectWithoutAssessmentInput[]
    createMany?: AssessmentQuestionCreateManyAssessmentInputEnvelope
    connect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
  }

  export type OrganisationTemplateCreateNestedOneWithoutAssessmentInput = {
    create?: XOR<OrganisationTemplateCreateWithoutAssessmentInput, OrganisationTemplateUncheckedCreateWithoutAssessmentInput>
    connectOrCreate?: OrganisationTemplateCreateOrConnectWithoutAssessmentInput
    connect?: OrganisationTemplateWhereUniqueInput
  }

  export type AssessmentTeamCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<AssessmentTeamCreateWithoutAssessmentInput, AssessmentTeamUncheckedCreateWithoutAssessmentInput> | AssessmentTeamCreateWithoutAssessmentInput[] | AssessmentTeamUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentTeamCreateOrConnectWithoutAssessmentInput | AssessmentTeamCreateOrConnectWithoutAssessmentInput[]
    createMany?: AssessmentTeamCreateManyAssessmentInputEnvelope
    connect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
  }

  export type QuestionAnswerCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<QuestionAnswerCreateWithoutAssessmentInput, QuestionAnswerUncheckedCreateWithoutAssessmentInput> | QuestionAnswerCreateWithoutAssessmentInput[] | QuestionAnswerUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAssessmentInput | QuestionAnswerCreateOrConnectWithoutAssessmentInput[]
    createMany?: QuestionAnswerCreateManyAssessmentInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type AssessmentQuestionUncheckedCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput> | AssessmentQuestionCreateWithoutAssessmentInput[] | AssessmentQuestionUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentQuestionCreateOrConnectWithoutAssessmentInput | AssessmentQuestionCreateOrConnectWithoutAssessmentInput[]
    createMany?: AssessmentQuestionCreateManyAssessmentInputEnvelope
    connect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
  }

  export type AssessmentTeamUncheckedCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<AssessmentTeamCreateWithoutAssessmentInput, AssessmentTeamUncheckedCreateWithoutAssessmentInput> | AssessmentTeamCreateWithoutAssessmentInput[] | AssessmentTeamUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentTeamCreateOrConnectWithoutAssessmentInput | AssessmentTeamCreateOrConnectWithoutAssessmentInput[]
    createMany?: AssessmentTeamCreateManyAssessmentInputEnvelope
    connect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
  }

  export type QuestionAnswerUncheckedCreateNestedManyWithoutAssessmentInput = {
    create?: XOR<QuestionAnswerCreateWithoutAssessmentInput, QuestionAnswerUncheckedCreateWithoutAssessmentInput> | QuestionAnswerCreateWithoutAssessmentInput[] | QuestionAnswerUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAssessmentInput | QuestionAnswerCreateOrConnectWithoutAssessmentInput[]
    createMany?: QuestionAnswerCreateManyAssessmentInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OrganisationUpdateOneRequiredWithoutAssessmentNestedInput = {
    create?: XOR<OrganisationCreateWithoutAssessmentInput, OrganisationUncheckedCreateWithoutAssessmentInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutAssessmentInput
    upsert?: OrganisationUpsertWithoutAssessmentInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutAssessmentInput, OrganisationUpdateWithoutAssessmentInput>, OrganisationUncheckedUpdateWithoutAssessmentInput>
  }

  export type AssessmentQuestionUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput> | AssessmentQuestionCreateWithoutAssessmentInput[] | AssessmentQuestionUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentQuestionCreateOrConnectWithoutAssessmentInput | AssessmentQuestionCreateOrConnectWithoutAssessmentInput[]
    upsert?: AssessmentQuestionUpsertWithWhereUniqueWithoutAssessmentInput | AssessmentQuestionUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: AssessmentQuestionCreateManyAssessmentInputEnvelope
    set?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    disconnect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    delete?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    connect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    update?: AssessmentQuestionUpdateWithWhereUniqueWithoutAssessmentInput | AssessmentQuestionUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: AssessmentQuestionUpdateManyWithWhereWithoutAssessmentInput | AssessmentQuestionUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: AssessmentQuestionScalarWhereInput | AssessmentQuestionScalarWhereInput[]
  }

  export type OrganisationTemplateUpdateOneWithoutAssessmentNestedInput = {
    create?: XOR<OrganisationTemplateCreateWithoutAssessmentInput, OrganisationTemplateUncheckedCreateWithoutAssessmentInput>
    connectOrCreate?: OrganisationTemplateCreateOrConnectWithoutAssessmentInput
    upsert?: OrganisationTemplateUpsertWithoutAssessmentInput
    disconnect?: OrganisationTemplateWhereInput | boolean
    delete?: OrganisationTemplateWhereInput | boolean
    connect?: OrganisationTemplateWhereUniqueInput
    update?: XOR<XOR<OrganisationTemplateUpdateToOneWithWhereWithoutAssessmentInput, OrganisationTemplateUpdateWithoutAssessmentInput>, OrganisationTemplateUncheckedUpdateWithoutAssessmentInput>
  }

  export type AssessmentTeamUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<AssessmentTeamCreateWithoutAssessmentInput, AssessmentTeamUncheckedCreateWithoutAssessmentInput> | AssessmentTeamCreateWithoutAssessmentInput[] | AssessmentTeamUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentTeamCreateOrConnectWithoutAssessmentInput | AssessmentTeamCreateOrConnectWithoutAssessmentInput[]
    upsert?: AssessmentTeamUpsertWithWhereUniqueWithoutAssessmentInput | AssessmentTeamUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: AssessmentTeamCreateManyAssessmentInputEnvelope
    set?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    disconnect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    delete?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    connect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    update?: AssessmentTeamUpdateWithWhereUniqueWithoutAssessmentInput | AssessmentTeamUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: AssessmentTeamUpdateManyWithWhereWithoutAssessmentInput | AssessmentTeamUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: AssessmentTeamScalarWhereInput | AssessmentTeamScalarWhereInput[]
  }

  export type QuestionAnswerUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutAssessmentInput, QuestionAnswerUncheckedCreateWithoutAssessmentInput> | QuestionAnswerCreateWithoutAssessmentInput[] | QuestionAnswerUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAssessmentInput | QuestionAnswerCreateOrConnectWithoutAssessmentInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutAssessmentInput | QuestionAnswerUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: QuestionAnswerCreateManyAssessmentInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutAssessmentInput | QuestionAnswerUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutAssessmentInput | QuestionAnswerUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AssessmentQuestionUncheckedUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput> | AssessmentQuestionCreateWithoutAssessmentInput[] | AssessmentQuestionUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentQuestionCreateOrConnectWithoutAssessmentInput | AssessmentQuestionCreateOrConnectWithoutAssessmentInput[]
    upsert?: AssessmentQuestionUpsertWithWhereUniqueWithoutAssessmentInput | AssessmentQuestionUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: AssessmentQuestionCreateManyAssessmentInputEnvelope
    set?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    disconnect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    delete?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    connect?: AssessmentQuestionWhereUniqueInput | AssessmentQuestionWhereUniqueInput[]
    update?: AssessmentQuestionUpdateWithWhereUniqueWithoutAssessmentInput | AssessmentQuestionUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: AssessmentQuestionUpdateManyWithWhereWithoutAssessmentInput | AssessmentQuestionUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: AssessmentQuestionScalarWhereInput | AssessmentQuestionScalarWhereInput[]
  }

  export type AssessmentTeamUncheckedUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<AssessmentTeamCreateWithoutAssessmentInput, AssessmentTeamUncheckedCreateWithoutAssessmentInput> | AssessmentTeamCreateWithoutAssessmentInput[] | AssessmentTeamUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: AssessmentTeamCreateOrConnectWithoutAssessmentInput | AssessmentTeamCreateOrConnectWithoutAssessmentInput[]
    upsert?: AssessmentTeamUpsertWithWhereUniqueWithoutAssessmentInput | AssessmentTeamUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: AssessmentTeamCreateManyAssessmentInputEnvelope
    set?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    disconnect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    delete?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    connect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    update?: AssessmentTeamUpdateWithWhereUniqueWithoutAssessmentInput | AssessmentTeamUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: AssessmentTeamUpdateManyWithWhereWithoutAssessmentInput | AssessmentTeamUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: AssessmentTeamScalarWhereInput | AssessmentTeamScalarWhereInput[]
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutAssessmentNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutAssessmentInput, QuestionAnswerUncheckedCreateWithoutAssessmentInput> | QuestionAnswerCreateWithoutAssessmentInput[] | QuestionAnswerUncheckedCreateWithoutAssessmentInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAssessmentInput | QuestionAnswerCreateOrConnectWithoutAssessmentInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutAssessmentInput | QuestionAnswerUpsertWithWhereUniqueWithoutAssessmentInput[]
    createMany?: QuestionAnswerCreateManyAssessmentInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutAssessmentInput | QuestionAnswerUpdateWithWhereUniqueWithoutAssessmentInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutAssessmentInput | QuestionAnswerUpdateManyWithWhereWithoutAssessmentInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type AssessmentCreateNestedOneWithoutAssessmentQuestionInput = {
    create?: XOR<AssessmentCreateWithoutAssessmentQuestionInput, AssessmentUncheckedCreateWithoutAssessmentQuestionInput>
    connectOrCreate?: AssessmentCreateOrConnectWithoutAssessmentQuestionInput
    connect?: AssessmentWhereUniqueInput
  }

  export type QuestionAnswerCreateNestedManyWithoutAssessmentQuestionInput = {
    create?: XOR<QuestionAnswerCreateWithoutAssessmentQuestionInput, QuestionAnswerUncheckedCreateWithoutAssessmentQuestionInput> | QuestionAnswerCreateWithoutAssessmentQuestionInput[] | QuestionAnswerUncheckedCreateWithoutAssessmentQuestionInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAssessmentQuestionInput | QuestionAnswerCreateOrConnectWithoutAssessmentQuestionInput[]
    createMany?: QuestionAnswerCreateManyAssessmentQuestionInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type QuestionAnswerUncheckedCreateNestedManyWithoutAssessmentQuestionInput = {
    create?: XOR<QuestionAnswerCreateWithoutAssessmentQuestionInput, QuestionAnswerUncheckedCreateWithoutAssessmentQuestionInput> | QuestionAnswerCreateWithoutAssessmentQuestionInput[] | QuestionAnswerUncheckedCreateWithoutAssessmentQuestionInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAssessmentQuestionInput | QuestionAnswerCreateOrConnectWithoutAssessmentQuestionInput[]
    createMany?: QuestionAnswerCreateManyAssessmentQuestionInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type AssessmentUpdateOneRequiredWithoutAssessmentQuestionNestedInput = {
    create?: XOR<AssessmentCreateWithoutAssessmentQuestionInput, AssessmentUncheckedCreateWithoutAssessmentQuestionInput>
    connectOrCreate?: AssessmentCreateOrConnectWithoutAssessmentQuestionInput
    upsert?: AssessmentUpsertWithoutAssessmentQuestionInput
    connect?: AssessmentWhereUniqueInput
    update?: XOR<XOR<AssessmentUpdateToOneWithWhereWithoutAssessmentQuestionInput, AssessmentUpdateWithoutAssessmentQuestionInput>, AssessmentUncheckedUpdateWithoutAssessmentQuestionInput>
  }

  export type QuestionAnswerUpdateManyWithoutAssessmentQuestionNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutAssessmentQuestionInput, QuestionAnswerUncheckedCreateWithoutAssessmentQuestionInput> | QuestionAnswerCreateWithoutAssessmentQuestionInput[] | QuestionAnswerUncheckedCreateWithoutAssessmentQuestionInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAssessmentQuestionInput | QuestionAnswerCreateOrConnectWithoutAssessmentQuestionInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutAssessmentQuestionInput | QuestionAnswerUpsertWithWhereUniqueWithoutAssessmentQuestionInput[]
    createMany?: QuestionAnswerCreateManyAssessmentQuestionInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutAssessmentQuestionInput | QuestionAnswerUpdateWithWhereUniqueWithoutAssessmentQuestionInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutAssessmentQuestionInput | QuestionAnswerUpdateManyWithWhereWithoutAssessmentQuestionInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutAssessmentQuestionNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutAssessmentQuestionInput, QuestionAnswerUncheckedCreateWithoutAssessmentQuestionInput> | QuestionAnswerCreateWithoutAssessmentQuestionInput[] | QuestionAnswerUncheckedCreateWithoutAssessmentQuestionInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAssessmentQuestionInput | QuestionAnswerCreateOrConnectWithoutAssessmentQuestionInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutAssessmentQuestionInput | QuestionAnswerUpsertWithWhereUniqueWithoutAssessmentQuestionInput[]
    createMany?: QuestionAnswerCreateManyAssessmentQuestionInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutAssessmentQuestionInput | QuestionAnswerUpdateWithWhereUniqueWithoutAssessmentQuestionInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutAssessmentQuestionInput | QuestionAnswerUpdateManyWithWhereWithoutAssessmentQuestionInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type AssessmentCreateNestedOneWithoutAssessmentTeamInput = {
    create?: XOR<AssessmentCreateWithoutAssessmentTeamInput, AssessmentUncheckedCreateWithoutAssessmentTeamInput>
    connectOrCreate?: AssessmentCreateOrConnectWithoutAssessmentTeamInput
    connect?: AssessmentWhereUniqueInput
  }

  export type OrganisationCreateNestedOneWithoutAssessmentTeamInput = {
    create?: XOR<OrganisationCreateWithoutAssessmentTeamInput, OrganisationUncheckedCreateWithoutAssessmentTeamInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutAssessmentTeamInput
    connect?: OrganisationWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutAssessmentTeamInput = {
    create?: XOR<TeamCreateWithoutAssessmentTeamInput, TeamUncheckedCreateWithoutAssessmentTeamInput>
    connectOrCreate?: TeamCreateOrConnectWithoutAssessmentTeamInput
    connect?: TeamWhereUniqueInput
  }

  export type QuestionAnswerCreateNestedManyWithoutAssessmentTeamInput = {
    create?: XOR<QuestionAnswerCreateWithoutAssessmentTeamInput, QuestionAnswerUncheckedCreateWithoutAssessmentTeamInput> | QuestionAnswerCreateWithoutAssessmentTeamInput[] | QuestionAnswerUncheckedCreateWithoutAssessmentTeamInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAssessmentTeamInput | QuestionAnswerCreateOrConnectWithoutAssessmentTeamInput[]
    createMany?: QuestionAnswerCreateManyAssessmentTeamInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type QuestionAnswerUncheckedCreateNestedManyWithoutAssessmentTeamInput = {
    create?: XOR<QuestionAnswerCreateWithoutAssessmentTeamInput, QuestionAnswerUncheckedCreateWithoutAssessmentTeamInput> | QuestionAnswerCreateWithoutAssessmentTeamInput[] | QuestionAnswerUncheckedCreateWithoutAssessmentTeamInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAssessmentTeamInput | QuestionAnswerCreateOrConnectWithoutAssessmentTeamInput[]
    createMany?: QuestionAnswerCreateManyAssessmentTeamInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type AssessmentUpdateOneRequiredWithoutAssessmentTeamNestedInput = {
    create?: XOR<AssessmentCreateWithoutAssessmentTeamInput, AssessmentUncheckedCreateWithoutAssessmentTeamInput>
    connectOrCreate?: AssessmentCreateOrConnectWithoutAssessmentTeamInput
    upsert?: AssessmentUpsertWithoutAssessmentTeamInput
    connect?: AssessmentWhereUniqueInput
    update?: XOR<XOR<AssessmentUpdateToOneWithWhereWithoutAssessmentTeamInput, AssessmentUpdateWithoutAssessmentTeamInput>, AssessmentUncheckedUpdateWithoutAssessmentTeamInput>
  }

  export type OrganisationUpdateOneRequiredWithoutAssessmentTeamNestedInput = {
    create?: XOR<OrganisationCreateWithoutAssessmentTeamInput, OrganisationUncheckedCreateWithoutAssessmentTeamInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutAssessmentTeamInput
    upsert?: OrganisationUpsertWithoutAssessmentTeamInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutAssessmentTeamInput, OrganisationUpdateWithoutAssessmentTeamInput>, OrganisationUncheckedUpdateWithoutAssessmentTeamInput>
  }

  export type TeamUpdateOneRequiredWithoutAssessmentTeamNestedInput = {
    create?: XOR<TeamCreateWithoutAssessmentTeamInput, TeamUncheckedCreateWithoutAssessmentTeamInput>
    connectOrCreate?: TeamCreateOrConnectWithoutAssessmentTeamInput
    upsert?: TeamUpsertWithoutAssessmentTeamInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutAssessmentTeamInput, TeamUpdateWithoutAssessmentTeamInput>, TeamUncheckedUpdateWithoutAssessmentTeamInput>
  }

  export type QuestionAnswerUpdateManyWithoutAssessmentTeamNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutAssessmentTeamInput, QuestionAnswerUncheckedCreateWithoutAssessmentTeamInput> | QuestionAnswerCreateWithoutAssessmentTeamInput[] | QuestionAnswerUncheckedCreateWithoutAssessmentTeamInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAssessmentTeamInput | QuestionAnswerCreateOrConnectWithoutAssessmentTeamInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutAssessmentTeamInput | QuestionAnswerUpsertWithWhereUniqueWithoutAssessmentTeamInput[]
    createMany?: QuestionAnswerCreateManyAssessmentTeamInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutAssessmentTeamInput | QuestionAnswerUpdateWithWhereUniqueWithoutAssessmentTeamInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutAssessmentTeamInput | QuestionAnswerUpdateManyWithWhereWithoutAssessmentTeamInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutAssessmentTeamNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutAssessmentTeamInput, QuestionAnswerUncheckedCreateWithoutAssessmentTeamInput> | QuestionAnswerCreateWithoutAssessmentTeamInput[] | QuestionAnswerUncheckedCreateWithoutAssessmentTeamInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutAssessmentTeamInput | QuestionAnswerCreateOrConnectWithoutAssessmentTeamInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutAssessmentTeamInput | QuestionAnswerUpsertWithWhereUniqueWithoutAssessmentTeamInput[]
    createMany?: QuestionAnswerCreateManyAssessmentTeamInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutAssessmentTeamInput | QuestionAnswerUpdateWithWhereUniqueWithoutAssessmentTeamInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutAssessmentTeamInput | QuestionAnswerUpdateManyWithWhereWithoutAssessmentTeamInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOrganisationInput = {
    create?: XOR<UserCreateWithoutOrganisationInput, UserUncheckedCreateWithoutOrganisationInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganisationInput
    connect?: UserWhereUniqueInput
  }

  export type AssessmentCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<AssessmentCreateWithoutOrganisationInput, AssessmentUncheckedCreateWithoutOrganisationInput> | AssessmentCreateWithoutOrganisationInput[] | AssessmentUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutOrganisationInput | AssessmentCreateOrConnectWithoutOrganisationInput[]
    createMany?: AssessmentCreateManyOrganisationInputEnvelope
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<TeamCreateWithoutOrganisationInput, TeamUncheckedCreateWithoutOrganisationInput> | TeamCreateWithoutOrganisationInput[] | TeamUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganisationInput | TeamCreateOrConnectWithoutOrganisationInput[]
    createMany?: TeamCreateManyOrganisationInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type OrganisationTemplateCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<OrganisationTemplateCreateWithoutOrganisationInput, OrganisationTemplateUncheckedCreateWithoutOrganisationInput> | OrganisationTemplateCreateWithoutOrganisationInput[] | OrganisationTemplateUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: OrganisationTemplateCreateOrConnectWithoutOrganisationInput | OrganisationTemplateCreateOrConnectWithoutOrganisationInput[]
    createMany?: OrganisationTemplateCreateManyOrganisationInputEnvelope
    connect?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
  }

  export type QuestionAnswerCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<QuestionAnswerCreateWithoutOrganisationInput, QuestionAnswerUncheckedCreateWithoutOrganisationInput> | QuestionAnswerCreateWithoutOrganisationInput[] | QuestionAnswerUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutOrganisationInput | QuestionAnswerCreateOrConnectWithoutOrganisationInput[]
    createMany?: QuestionAnswerCreateManyOrganisationInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type AssessmentTeamCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<AssessmentTeamCreateWithoutOrganisationInput, AssessmentTeamUncheckedCreateWithoutOrganisationInput> | AssessmentTeamCreateWithoutOrganisationInput[] | AssessmentTeamUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: AssessmentTeamCreateOrConnectWithoutOrganisationInput | AssessmentTeamCreateOrConnectWithoutOrganisationInput[]
    createMany?: AssessmentTeamCreateManyOrganisationInputEnvelope
    connect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
  }

  export type AssessmentUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<AssessmentCreateWithoutOrganisationInput, AssessmentUncheckedCreateWithoutOrganisationInput> | AssessmentCreateWithoutOrganisationInput[] | AssessmentUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutOrganisationInput | AssessmentCreateOrConnectWithoutOrganisationInput[]
    createMany?: AssessmentCreateManyOrganisationInputEnvelope
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<TeamCreateWithoutOrganisationInput, TeamUncheckedCreateWithoutOrganisationInput> | TeamCreateWithoutOrganisationInput[] | TeamUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganisationInput | TeamCreateOrConnectWithoutOrganisationInput[]
    createMany?: TeamCreateManyOrganisationInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type OrganisationTemplateUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<OrganisationTemplateCreateWithoutOrganisationInput, OrganisationTemplateUncheckedCreateWithoutOrganisationInput> | OrganisationTemplateCreateWithoutOrganisationInput[] | OrganisationTemplateUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: OrganisationTemplateCreateOrConnectWithoutOrganisationInput | OrganisationTemplateCreateOrConnectWithoutOrganisationInput[]
    createMany?: OrganisationTemplateCreateManyOrganisationInputEnvelope
    connect?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
  }

  export type QuestionAnswerUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<QuestionAnswerCreateWithoutOrganisationInput, QuestionAnswerUncheckedCreateWithoutOrganisationInput> | QuestionAnswerCreateWithoutOrganisationInput[] | QuestionAnswerUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutOrganisationInput | QuestionAnswerCreateOrConnectWithoutOrganisationInput[]
    createMany?: QuestionAnswerCreateManyOrganisationInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type AssessmentTeamUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<AssessmentTeamCreateWithoutOrganisationInput, AssessmentTeamUncheckedCreateWithoutOrganisationInput> | AssessmentTeamCreateWithoutOrganisationInput[] | AssessmentTeamUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: AssessmentTeamCreateOrConnectWithoutOrganisationInput | AssessmentTeamCreateOrConnectWithoutOrganisationInput[]
    createMany?: AssessmentTeamCreateManyOrganisationInputEnvelope
    connect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneWithoutOrganisationNestedInput = {
    create?: XOR<UserCreateWithoutOrganisationInput, UserUncheckedCreateWithoutOrganisationInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganisationInput
    upsert?: UserUpsertWithoutOrganisationInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrganisationInput, UserUpdateWithoutOrganisationInput>, UserUncheckedUpdateWithoutOrganisationInput>
  }

  export type AssessmentUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<AssessmentCreateWithoutOrganisationInput, AssessmentUncheckedCreateWithoutOrganisationInput> | AssessmentCreateWithoutOrganisationInput[] | AssessmentUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutOrganisationInput | AssessmentCreateOrConnectWithoutOrganisationInput[]
    upsert?: AssessmentUpsertWithWhereUniqueWithoutOrganisationInput | AssessmentUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: AssessmentCreateManyOrganisationInputEnvelope
    set?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    disconnect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    delete?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    update?: AssessmentUpdateWithWhereUniqueWithoutOrganisationInput | AssessmentUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: AssessmentUpdateManyWithWhereWithoutOrganisationInput | AssessmentUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<TeamCreateWithoutOrganisationInput, TeamUncheckedCreateWithoutOrganisationInput> | TeamCreateWithoutOrganisationInput[] | TeamUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganisationInput | TeamCreateOrConnectWithoutOrganisationInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutOrganisationInput | TeamUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: TeamCreateManyOrganisationInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutOrganisationInput | TeamUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutOrganisationInput | TeamUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type OrganisationTemplateUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<OrganisationTemplateCreateWithoutOrganisationInput, OrganisationTemplateUncheckedCreateWithoutOrganisationInput> | OrganisationTemplateCreateWithoutOrganisationInput[] | OrganisationTemplateUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: OrganisationTemplateCreateOrConnectWithoutOrganisationInput | OrganisationTemplateCreateOrConnectWithoutOrganisationInput[]
    upsert?: OrganisationTemplateUpsertWithWhereUniqueWithoutOrganisationInput | OrganisationTemplateUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: OrganisationTemplateCreateManyOrganisationInputEnvelope
    set?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    disconnect?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    delete?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    connect?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    update?: OrganisationTemplateUpdateWithWhereUniqueWithoutOrganisationInput | OrganisationTemplateUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: OrganisationTemplateUpdateManyWithWhereWithoutOrganisationInput | OrganisationTemplateUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: OrganisationTemplateScalarWhereInput | OrganisationTemplateScalarWhereInput[]
  }

  export type QuestionAnswerUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutOrganisationInput, QuestionAnswerUncheckedCreateWithoutOrganisationInput> | QuestionAnswerCreateWithoutOrganisationInput[] | QuestionAnswerUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutOrganisationInput | QuestionAnswerCreateOrConnectWithoutOrganisationInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutOrganisationInput | QuestionAnswerUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: QuestionAnswerCreateManyOrganisationInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutOrganisationInput | QuestionAnswerUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutOrganisationInput | QuestionAnswerUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type AssessmentTeamUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<AssessmentTeamCreateWithoutOrganisationInput, AssessmentTeamUncheckedCreateWithoutOrganisationInput> | AssessmentTeamCreateWithoutOrganisationInput[] | AssessmentTeamUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: AssessmentTeamCreateOrConnectWithoutOrganisationInput | AssessmentTeamCreateOrConnectWithoutOrganisationInput[]
    upsert?: AssessmentTeamUpsertWithWhereUniqueWithoutOrganisationInput | AssessmentTeamUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: AssessmentTeamCreateManyOrganisationInputEnvelope
    set?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    disconnect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    delete?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    connect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    update?: AssessmentTeamUpdateWithWhereUniqueWithoutOrganisationInput | AssessmentTeamUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: AssessmentTeamUpdateManyWithWhereWithoutOrganisationInput | AssessmentTeamUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: AssessmentTeamScalarWhereInput | AssessmentTeamScalarWhereInput[]
  }

  export type AssessmentUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<AssessmentCreateWithoutOrganisationInput, AssessmentUncheckedCreateWithoutOrganisationInput> | AssessmentCreateWithoutOrganisationInput[] | AssessmentUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutOrganisationInput | AssessmentCreateOrConnectWithoutOrganisationInput[]
    upsert?: AssessmentUpsertWithWhereUniqueWithoutOrganisationInput | AssessmentUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: AssessmentCreateManyOrganisationInputEnvelope
    set?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    disconnect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    delete?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    update?: AssessmentUpdateWithWhereUniqueWithoutOrganisationInput | AssessmentUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: AssessmentUpdateManyWithWhereWithoutOrganisationInput | AssessmentUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<TeamCreateWithoutOrganisationInput, TeamUncheckedCreateWithoutOrganisationInput> | TeamCreateWithoutOrganisationInput[] | TeamUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganisationInput | TeamCreateOrConnectWithoutOrganisationInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutOrganisationInput | TeamUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: TeamCreateManyOrganisationInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutOrganisationInput | TeamUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutOrganisationInput | TeamUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type OrganisationTemplateUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<OrganisationTemplateCreateWithoutOrganisationInput, OrganisationTemplateUncheckedCreateWithoutOrganisationInput> | OrganisationTemplateCreateWithoutOrganisationInput[] | OrganisationTemplateUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: OrganisationTemplateCreateOrConnectWithoutOrganisationInput | OrganisationTemplateCreateOrConnectWithoutOrganisationInput[]
    upsert?: OrganisationTemplateUpsertWithWhereUniqueWithoutOrganisationInput | OrganisationTemplateUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: OrganisationTemplateCreateManyOrganisationInputEnvelope
    set?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    disconnect?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    delete?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    connect?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    update?: OrganisationTemplateUpdateWithWhereUniqueWithoutOrganisationInput | OrganisationTemplateUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: OrganisationTemplateUpdateManyWithWhereWithoutOrganisationInput | OrganisationTemplateUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: OrganisationTemplateScalarWhereInput | OrganisationTemplateScalarWhereInput[]
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutOrganisationInput, QuestionAnswerUncheckedCreateWithoutOrganisationInput> | QuestionAnswerCreateWithoutOrganisationInput[] | QuestionAnswerUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutOrganisationInput | QuestionAnswerCreateOrConnectWithoutOrganisationInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutOrganisationInput | QuestionAnswerUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: QuestionAnswerCreateManyOrganisationInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutOrganisationInput | QuestionAnswerUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutOrganisationInput | QuestionAnswerUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type AssessmentTeamUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<AssessmentTeamCreateWithoutOrganisationInput, AssessmentTeamUncheckedCreateWithoutOrganisationInput> | AssessmentTeamCreateWithoutOrganisationInput[] | AssessmentTeamUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: AssessmentTeamCreateOrConnectWithoutOrganisationInput | AssessmentTeamCreateOrConnectWithoutOrganisationInput[]
    upsert?: AssessmentTeamUpsertWithWhereUniqueWithoutOrganisationInput | AssessmentTeamUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: AssessmentTeamCreateManyOrganisationInputEnvelope
    set?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    disconnect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    delete?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    connect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    update?: AssessmentTeamUpdateWithWhereUniqueWithoutOrganisationInput | AssessmentTeamUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: AssessmentTeamUpdateManyWithWhereWithoutOrganisationInput | AssessmentTeamUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: AssessmentTeamScalarWhereInput | AssessmentTeamScalarWhereInput[]
  }

  export type OrganisationStructureCreateNestedOneWithoutOrganisationRoleInput = {
    create?: XOR<OrganisationStructureCreateWithoutOrganisationRoleInput, OrganisationStructureUncheckedCreateWithoutOrganisationRoleInput>
    connectOrCreate?: OrganisationStructureCreateOrConnectWithoutOrganisationRoleInput
    connect?: OrganisationStructureWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutOrganisationRoleInput = {
    create?: XOR<RoleCreateWithoutOrganisationRoleInput, RoleUncheckedCreateWithoutOrganisationRoleInput>
    connectOrCreate?: RoleCreateOrConnectWithoutOrganisationRoleInput
    connect?: RoleWhereUniqueInput
  }

  export type OrganisationStructureUpdateOneRequiredWithoutOrganisationRoleNestedInput = {
    create?: XOR<OrganisationStructureCreateWithoutOrganisationRoleInput, OrganisationStructureUncheckedCreateWithoutOrganisationRoleInput>
    connectOrCreate?: OrganisationStructureCreateOrConnectWithoutOrganisationRoleInput
    upsert?: OrganisationStructureUpsertWithoutOrganisationRoleInput
    connect?: OrganisationStructureWhereUniqueInput
    update?: XOR<XOR<OrganisationStructureUpdateToOneWithWhereWithoutOrganisationRoleInput, OrganisationStructureUpdateWithoutOrganisationRoleInput>, OrganisationStructureUncheckedUpdateWithoutOrganisationRoleInput>
  }

  export type RoleUpdateOneRequiredWithoutOrganisationRoleNestedInput = {
    create?: XOR<RoleCreateWithoutOrganisationRoleInput, RoleUncheckedCreateWithoutOrganisationRoleInput>
    connectOrCreate?: RoleCreateOrConnectWithoutOrganisationRoleInput
    upsert?: RoleUpsertWithoutOrganisationRoleInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutOrganisationRoleInput, RoleUpdateWithoutOrganisationRoleInput>, RoleUncheckedUpdateWithoutOrganisationRoleInput>
  }

  export type TeamCreateNestedOneWithoutOrganisationStructureInput = {
    create?: XOR<TeamCreateWithoutOrganisationStructureInput, TeamUncheckedCreateWithoutOrganisationStructureInput>
    connectOrCreate?: TeamCreateOrConnectWithoutOrganisationStructureInput
    connect?: TeamWhereUniqueInput
  }

  export type OrganisationRoleCreateNestedManyWithoutOrganisationStructureInput = {
    create?: XOR<OrganisationRoleCreateWithoutOrganisationStructureInput, OrganisationRoleUncheckedCreateWithoutOrganisationStructureInput> | OrganisationRoleCreateWithoutOrganisationStructureInput[] | OrganisationRoleUncheckedCreateWithoutOrganisationStructureInput[]
    connectOrCreate?: OrganisationRoleCreateOrConnectWithoutOrganisationStructureInput | OrganisationRoleCreateOrConnectWithoutOrganisationStructureInput[]
    createMany?: OrganisationRoleCreateManyOrganisationStructureInputEnvelope
    connect?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOrganisationStructureInput = {
    create?: XOR<UserCreateWithoutOrganisationStructureInput, UserUncheckedCreateWithoutOrganisationStructureInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganisationStructureInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionAnswerCreateNestedManyWithoutOrganisationStructureInput = {
    create?: XOR<QuestionAnswerCreateWithoutOrganisationStructureInput, QuestionAnswerUncheckedCreateWithoutOrganisationStructureInput> | QuestionAnswerCreateWithoutOrganisationStructureInput[] | QuestionAnswerUncheckedCreateWithoutOrganisationStructureInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutOrganisationStructureInput | QuestionAnswerCreateOrConnectWithoutOrganisationStructureInput[]
    createMany?: QuestionAnswerCreateManyOrganisationStructureInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type OrganisationRoleUncheckedCreateNestedManyWithoutOrganisationStructureInput = {
    create?: XOR<OrganisationRoleCreateWithoutOrganisationStructureInput, OrganisationRoleUncheckedCreateWithoutOrganisationStructureInput> | OrganisationRoleCreateWithoutOrganisationStructureInput[] | OrganisationRoleUncheckedCreateWithoutOrganisationStructureInput[]
    connectOrCreate?: OrganisationRoleCreateOrConnectWithoutOrganisationStructureInput | OrganisationRoleCreateOrConnectWithoutOrganisationStructureInput[]
    createMany?: OrganisationRoleCreateManyOrganisationStructureInputEnvelope
    connect?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
  }

  export type QuestionAnswerUncheckedCreateNestedManyWithoutOrganisationStructureInput = {
    create?: XOR<QuestionAnswerCreateWithoutOrganisationStructureInput, QuestionAnswerUncheckedCreateWithoutOrganisationStructureInput> | QuestionAnswerCreateWithoutOrganisationStructureInput[] | QuestionAnswerUncheckedCreateWithoutOrganisationStructureInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutOrganisationStructureInput | QuestionAnswerCreateOrConnectWithoutOrganisationStructureInput[]
    createMany?: QuestionAnswerCreateManyOrganisationStructureInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type TeamUpdateOneWithoutOrganisationStructureNestedInput = {
    create?: XOR<TeamCreateWithoutOrganisationStructureInput, TeamUncheckedCreateWithoutOrganisationStructureInput>
    connectOrCreate?: TeamCreateOrConnectWithoutOrganisationStructureInput
    upsert?: TeamUpsertWithoutOrganisationStructureInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutOrganisationStructureInput, TeamUpdateWithoutOrganisationStructureInput>, TeamUncheckedUpdateWithoutOrganisationStructureInput>
  }

  export type OrganisationRoleUpdateManyWithoutOrganisationStructureNestedInput = {
    create?: XOR<OrganisationRoleCreateWithoutOrganisationStructureInput, OrganisationRoleUncheckedCreateWithoutOrganisationStructureInput> | OrganisationRoleCreateWithoutOrganisationStructureInput[] | OrganisationRoleUncheckedCreateWithoutOrganisationStructureInput[]
    connectOrCreate?: OrganisationRoleCreateOrConnectWithoutOrganisationStructureInput | OrganisationRoleCreateOrConnectWithoutOrganisationStructureInput[]
    upsert?: OrganisationRoleUpsertWithWhereUniqueWithoutOrganisationStructureInput | OrganisationRoleUpsertWithWhereUniqueWithoutOrganisationStructureInput[]
    createMany?: OrganisationRoleCreateManyOrganisationStructureInputEnvelope
    set?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    disconnect?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    delete?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    connect?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    update?: OrganisationRoleUpdateWithWhereUniqueWithoutOrganisationStructureInput | OrganisationRoleUpdateWithWhereUniqueWithoutOrganisationStructureInput[]
    updateMany?: OrganisationRoleUpdateManyWithWhereWithoutOrganisationStructureInput | OrganisationRoleUpdateManyWithWhereWithoutOrganisationStructureInput[]
    deleteMany?: OrganisationRoleScalarWhereInput | OrganisationRoleScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutOrganisationStructureNestedInput = {
    create?: XOR<UserCreateWithoutOrganisationStructureInput, UserUncheckedCreateWithoutOrganisationStructureInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganisationStructureInput
    upsert?: UserUpsertWithoutOrganisationStructureInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrganisationStructureInput, UserUpdateWithoutOrganisationStructureInput>, UserUncheckedUpdateWithoutOrganisationStructureInput>
  }

  export type QuestionAnswerUpdateManyWithoutOrganisationStructureNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutOrganisationStructureInput, QuestionAnswerUncheckedCreateWithoutOrganisationStructureInput> | QuestionAnswerCreateWithoutOrganisationStructureInput[] | QuestionAnswerUncheckedCreateWithoutOrganisationStructureInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutOrganisationStructureInput | QuestionAnswerCreateOrConnectWithoutOrganisationStructureInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutOrganisationStructureInput | QuestionAnswerUpsertWithWhereUniqueWithoutOrganisationStructureInput[]
    createMany?: QuestionAnswerCreateManyOrganisationStructureInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutOrganisationStructureInput | QuestionAnswerUpdateWithWhereUniqueWithoutOrganisationStructureInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutOrganisationStructureInput | QuestionAnswerUpdateManyWithWhereWithoutOrganisationStructureInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type OrganisationRoleUncheckedUpdateManyWithoutOrganisationStructureNestedInput = {
    create?: XOR<OrganisationRoleCreateWithoutOrganisationStructureInput, OrganisationRoleUncheckedCreateWithoutOrganisationStructureInput> | OrganisationRoleCreateWithoutOrganisationStructureInput[] | OrganisationRoleUncheckedCreateWithoutOrganisationStructureInput[]
    connectOrCreate?: OrganisationRoleCreateOrConnectWithoutOrganisationStructureInput | OrganisationRoleCreateOrConnectWithoutOrganisationStructureInput[]
    upsert?: OrganisationRoleUpsertWithWhereUniqueWithoutOrganisationStructureInput | OrganisationRoleUpsertWithWhereUniqueWithoutOrganisationStructureInput[]
    createMany?: OrganisationRoleCreateManyOrganisationStructureInputEnvelope
    set?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    disconnect?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    delete?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    connect?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    update?: OrganisationRoleUpdateWithWhereUniqueWithoutOrganisationStructureInput | OrganisationRoleUpdateWithWhereUniqueWithoutOrganisationStructureInput[]
    updateMany?: OrganisationRoleUpdateManyWithWhereWithoutOrganisationStructureInput | OrganisationRoleUpdateManyWithWhereWithoutOrganisationStructureInput[]
    deleteMany?: OrganisationRoleScalarWhereInput | OrganisationRoleScalarWhereInput[]
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutOrganisationStructureNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutOrganisationStructureInput, QuestionAnswerUncheckedCreateWithoutOrganisationStructureInput> | QuestionAnswerCreateWithoutOrganisationStructureInput[] | QuestionAnswerUncheckedCreateWithoutOrganisationStructureInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutOrganisationStructureInput | QuestionAnswerCreateOrConnectWithoutOrganisationStructureInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutOrganisationStructureInput | QuestionAnswerUpsertWithWhereUniqueWithoutOrganisationStructureInput[]
    createMany?: QuestionAnswerCreateManyOrganisationStructureInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutOrganisationStructureInput | QuestionAnswerUpdateWithWhereUniqueWithoutOrganisationStructureInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutOrganisationStructureInput | QuestionAnswerUpdateManyWithWhereWithoutOrganisationStructureInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type OrganisationCreateNestedOneWithoutOrganisationTemplateInput = {
    create?: XOR<OrganisationCreateWithoutOrganisationTemplateInput, OrganisationUncheckedCreateWithoutOrganisationTemplateInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutOrganisationTemplateInput
    connect?: OrganisationWhereUniqueInput
  }

  export type TemplateCreateNestedOneWithoutOrganisationTemplateInput = {
    create?: XOR<TemplateCreateWithoutOrganisationTemplateInput, TemplateUncheckedCreateWithoutOrganisationTemplateInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutOrganisationTemplateInput
    connect?: TemplateWhereUniqueInput
  }

  export type AssessmentCreateNestedManyWithoutOrganisationTemplateInput = {
    create?: XOR<AssessmentCreateWithoutOrganisationTemplateInput, AssessmentUncheckedCreateWithoutOrganisationTemplateInput> | AssessmentCreateWithoutOrganisationTemplateInput[] | AssessmentUncheckedCreateWithoutOrganisationTemplateInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutOrganisationTemplateInput | AssessmentCreateOrConnectWithoutOrganisationTemplateInput[]
    createMany?: AssessmentCreateManyOrganisationTemplateInputEnvelope
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
  }

  export type AssessmentUncheckedCreateNestedManyWithoutOrganisationTemplateInput = {
    create?: XOR<AssessmentCreateWithoutOrganisationTemplateInput, AssessmentUncheckedCreateWithoutOrganisationTemplateInput> | AssessmentCreateWithoutOrganisationTemplateInput[] | AssessmentUncheckedCreateWithoutOrganisationTemplateInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutOrganisationTemplateInput | AssessmentCreateOrConnectWithoutOrganisationTemplateInput[]
    createMany?: AssessmentCreateManyOrganisationTemplateInputEnvelope
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
  }

  export type OrganisationUpdateOneRequiredWithoutOrganisationTemplateNestedInput = {
    create?: XOR<OrganisationCreateWithoutOrganisationTemplateInput, OrganisationUncheckedCreateWithoutOrganisationTemplateInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutOrganisationTemplateInput
    upsert?: OrganisationUpsertWithoutOrganisationTemplateInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutOrganisationTemplateInput, OrganisationUpdateWithoutOrganisationTemplateInput>, OrganisationUncheckedUpdateWithoutOrganisationTemplateInput>
  }

  export type TemplateUpdateOneWithoutOrganisationTemplateNestedInput = {
    create?: XOR<TemplateCreateWithoutOrganisationTemplateInput, TemplateUncheckedCreateWithoutOrganisationTemplateInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutOrganisationTemplateInput
    upsert?: TemplateUpsertWithoutOrganisationTemplateInput
    disconnect?: TemplateWhereInput | boolean
    delete?: TemplateWhereInput | boolean
    connect?: TemplateWhereUniqueInput
    update?: XOR<XOR<TemplateUpdateToOneWithWhereWithoutOrganisationTemplateInput, TemplateUpdateWithoutOrganisationTemplateInput>, TemplateUncheckedUpdateWithoutOrganisationTemplateInput>
  }

  export type AssessmentUpdateManyWithoutOrganisationTemplateNestedInput = {
    create?: XOR<AssessmentCreateWithoutOrganisationTemplateInput, AssessmentUncheckedCreateWithoutOrganisationTemplateInput> | AssessmentCreateWithoutOrganisationTemplateInput[] | AssessmentUncheckedCreateWithoutOrganisationTemplateInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutOrganisationTemplateInput | AssessmentCreateOrConnectWithoutOrganisationTemplateInput[]
    upsert?: AssessmentUpsertWithWhereUniqueWithoutOrganisationTemplateInput | AssessmentUpsertWithWhereUniqueWithoutOrganisationTemplateInput[]
    createMany?: AssessmentCreateManyOrganisationTemplateInputEnvelope
    set?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    disconnect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    delete?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    update?: AssessmentUpdateWithWhereUniqueWithoutOrganisationTemplateInput | AssessmentUpdateWithWhereUniqueWithoutOrganisationTemplateInput[]
    updateMany?: AssessmentUpdateManyWithWhereWithoutOrganisationTemplateInput | AssessmentUpdateManyWithWhereWithoutOrganisationTemplateInput[]
    deleteMany?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
  }

  export type AssessmentUncheckedUpdateManyWithoutOrganisationTemplateNestedInput = {
    create?: XOR<AssessmentCreateWithoutOrganisationTemplateInput, AssessmentUncheckedCreateWithoutOrganisationTemplateInput> | AssessmentCreateWithoutOrganisationTemplateInput[] | AssessmentUncheckedCreateWithoutOrganisationTemplateInput[]
    connectOrCreate?: AssessmentCreateOrConnectWithoutOrganisationTemplateInput | AssessmentCreateOrConnectWithoutOrganisationTemplateInput[]
    upsert?: AssessmentUpsertWithWhereUniqueWithoutOrganisationTemplateInput | AssessmentUpsertWithWhereUniqueWithoutOrganisationTemplateInput[]
    createMany?: AssessmentCreateManyOrganisationTemplateInputEnvelope
    set?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    disconnect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    delete?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    connect?: AssessmentWhereUniqueInput | AssessmentWhereUniqueInput[]
    update?: AssessmentUpdateWithWhereUniqueWithoutOrganisationTemplateInput | AssessmentUpdateWithWhereUniqueWithoutOrganisationTemplateInput[]
    updateMany?: AssessmentUpdateManyWithWhereWithoutOrganisationTemplateInput | AssessmentUpdateManyWithWhereWithoutOrganisationTemplateInput[]
    deleteMany?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
  }

  export type OrganisationCreateNestedOneWithoutQuestionAnswerInput = {
    create?: XOR<OrganisationCreateWithoutQuestionAnswerInput, OrganisationUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutQuestionAnswerInput
    connect?: OrganisationWhereUniqueInput
  }

  export type OrganisationStructureCreateNestedOneWithoutQuestionAnswerInput = {
    create?: XOR<OrganisationStructureCreateWithoutQuestionAnswerInput, OrganisationStructureUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: OrganisationStructureCreateOrConnectWithoutQuestionAnswerInput
    connect?: OrganisationStructureWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutQuestionAnswerInput = {
    create?: XOR<TeamCreateWithoutQuestionAnswerInput, TeamUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: TeamCreateOrConnectWithoutQuestionAnswerInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQuestionAnswerInput = {
    create?: XOR<UserCreateWithoutQuestionAnswerInput, UserUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionAnswerInput
    connect?: UserWhereUniqueInput
  }

  export type AssessmentTeamCreateNestedOneWithoutQuestionAnswerInput = {
    create?: XOR<AssessmentTeamCreateWithoutQuestionAnswerInput, AssessmentTeamUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: AssessmentTeamCreateOrConnectWithoutQuestionAnswerInput
    connect?: AssessmentTeamWhereUniqueInput
  }

  export type AssessmentCreateNestedOneWithoutQuestionAnswerInput = {
    create?: XOR<AssessmentCreateWithoutQuestionAnswerInput, AssessmentUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: AssessmentCreateOrConnectWithoutQuestionAnswerInput
    connect?: AssessmentWhereUniqueInput
  }

  export type AssessmentQuestionCreateNestedOneWithoutQuestionAnswerInput = {
    create?: XOR<AssessmentQuestionCreateWithoutQuestionAnswerInput, AssessmentQuestionUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: AssessmentQuestionCreateOrConnectWithoutQuestionAnswerInput
    connect?: AssessmentQuestionWhereUniqueInput
  }

  export type OrganisationUpdateOneWithoutQuestionAnswerNestedInput = {
    create?: XOR<OrganisationCreateWithoutQuestionAnswerInput, OrganisationUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutQuestionAnswerInput
    upsert?: OrganisationUpsertWithoutQuestionAnswerInput
    disconnect?: OrganisationWhereInput | boolean
    delete?: OrganisationWhereInput | boolean
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutQuestionAnswerInput, OrganisationUpdateWithoutQuestionAnswerInput>, OrganisationUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type OrganisationStructureUpdateOneWithoutQuestionAnswerNestedInput = {
    create?: XOR<OrganisationStructureCreateWithoutQuestionAnswerInput, OrganisationStructureUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: OrganisationStructureCreateOrConnectWithoutQuestionAnswerInput
    upsert?: OrganisationStructureUpsertWithoutQuestionAnswerInput
    disconnect?: OrganisationStructureWhereInput | boolean
    delete?: OrganisationStructureWhereInput | boolean
    connect?: OrganisationStructureWhereUniqueInput
    update?: XOR<XOR<OrganisationStructureUpdateToOneWithWhereWithoutQuestionAnswerInput, OrganisationStructureUpdateWithoutQuestionAnswerInput>, OrganisationStructureUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type TeamUpdateOneWithoutQuestionAnswerNestedInput = {
    create?: XOR<TeamCreateWithoutQuestionAnswerInput, TeamUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: TeamCreateOrConnectWithoutQuestionAnswerInput
    upsert?: TeamUpsertWithoutQuestionAnswerInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutQuestionAnswerInput, TeamUpdateWithoutQuestionAnswerInput>, TeamUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type UserUpdateOneWithoutQuestionAnswerNestedInput = {
    create?: XOR<UserCreateWithoutQuestionAnswerInput, UserUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionAnswerInput
    upsert?: UserUpsertWithoutQuestionAnswerInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuestionAnswerInput, UserUpdateWithoutQuestionAnswerInput>, UserUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type AssessmentTeamUpdateOneWithoutQuestionAnswerNestedInput = {
    create?: XOR<AssessmentTeamCreateWithoutQuestionAnswerInput, AssessmentTeamUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: AssessmentTeamCreateOrConnectWithoutQuestionAnswerInput
    upsert?: AssessmentTeamUpsertWithoutQuestionAnswerInput
    disconnect?: AssessmentTeamWhereInput | boolean
    delete?: AssessmentTeamWhereInput | boolean
    connect?: AssessmentTeamWhereUniqueInput
    update?: XOR<XOR<AssessmentTeamUpdateToOneWithWhereWithoutQuestionAnswerInput, AssessmentTeamUpdateWithoutQuestionAnswerInput>, AssessmentTeamUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type AssessmentUpdateOneWithoutQuestionAnswerNestedInput = {
    create?: XOR<AssessmentCreateWithoutQuestionAnswerInput, AssessmentUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: AssessmentCreateOrConnectWithoutQuestionAnswerInput
    upsert?: AssessmentUpsertWithoutQuestionAnswerInput
    disconnect?: AssessmentWhereInput | boolean
    delete?: AssessmentWhereInput | boolean
    connect?: AssessmentWhereUniqueInput
    update?: XOR<XOR<AssessmentUpdateToOneWithWhereWithoutQuestionAnswerInput, AssessmentUpdateWithoutQuestionAnswerInput>, AssessmentUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type AssessmentQuestionUpdateOneWithoutQuestionAnswerNestedInput = {
    create?: XOR<AssessmentQuestionCreateWithoutQuestionAnswerInput, AssessmentQuestionUncheckedCreateWithoutQuestionAnswerInput>
    connectOrCreate?: AssessmentQuestionCreateOrConnectWithoutQuestionAnswerInput
    upsert?: AssessmentQuestionUpsertWithoutQuestionAnswerInput
    disconnect?: AssessmentQuestionWhereInput | boolean
    delete?: AssessmentQuestionWhereInput | boolean
    connect?: AssessmentQuestionWhereUniqueInput
    update?: XOR<XOR<AssessmentQuestionUpdateToOneWithWhereWithoutQuestionAnswerInput, AssessmentQuestionUpdateWithoutQuestionAnswerInput>, AssessmentQuestionUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type OrganisationRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<OrganisationRoleCreateWithoutRoleInput, OrganisationRoleUncheckedCreateWithoutRoleInput> | OrganisationRoleCreateWithoutRoleInput[] | OrganisationRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: OrganisationRoleCreateOrConnectWithoutRoleInput | OrganisationRoleCreateOrConnectWithoutRoleInput[]
    createMany?: OrganisationRoleCreateManyRoleInputEnvelope
    connect?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type OrganisationRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<OrganisationRoleCreateWithoutRoleInput, OrganisationRoleUncheckedCreateWithoutRoleInput> | OrganisationRoleCreateWithoutRoleInput[] | OrganisationRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: OrganisationRoleCreateOrConnectWithoutRoleInput | OrganisationRoleCreateOrConnectWithoutRoleInput[]
    createMany?: OrganisationRoleCreateManyRoleInputEnvelope
    connect?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type OrganisationRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<OrganisationRoleCreateWithoutRoleInput, OrganisationRoleUncheckedCreateWithoutRoleInput> | OrganisationRoleCreateWithoutRoleInput[] | OrganisationRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: OrganisationRoleCreateOrConnectWithoutRoleInput | OrganisationRoleCreateOrConnectWithoutRoleInput[]
    upsert?: OrganisationRoleUpsertWithWhereUniqueWithoutRoleInput | OrganisationRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: OrganisationRoleCreateManyRoleInputEnvelope
    set?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    disconnect?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    delete?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    connect?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    update?: OrganisationRoleUpdateWithWhereUniqueWithoutRoleInput | OrganisationRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: OrganisationRoleUpdateManyWithWhereWithoutRoleInput | OrganisationRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: OrganisationRoleScalarWhereInput | OrganisationRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type OrganisationRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<OrganisationRoleCreateWithoutRoleInput, OrganisationRoleUncheckedCreateWithoutRoleInput> | OrganisationRoleCreateWithoutRoleInput[] | OrganisationRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: OrganisationRoleCreateOrConnectWithoutRoleInput | OrganisationRoleCreateOrConnectWithoutRoleInput[]
    upsert?: OrganisationRoleUpsertWithWhereUniqueWithoutRoleInput | OrganisationRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: OrganisationRoleCreateManyRoleInputEnvelope
    set?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    disconnect?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    delete?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    connect?: OrganisationRoleWhereUniqueInput | OrganisationRoleWhereUniqueInput[]
    update?: OrganisationRoleUpdateWithWhereUniqueWithoutRoleInput | OrganisationRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: OrganisationRoleUpdateManyWithWhereWithoutRoleInput | OrganisationRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: OrganisationRoleScalarWhereInput | OrganisationRoleScalarWhereInput[]
  }

  export type OrganisationCreateNestedOneWithoutTeamInput = {
    create?: XOR<OrganisationCreateWithoutTeamInput, OrganisationUncheckedCreateWithoutTeamInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutTeamInput
    connect?: OrganisationWhereUniqueInput
  }

  export type OrganisationStructureCreateNestedManyWithoutTeamInput = {
    create?: XOR<OrganisationStructureCreateWithoutTeamInput, OrganisationStructureUncheckedCreateWithoutTeamInput> | OrganisationStructureCreateWithoutTeamInput[] | OrganisationStructureUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: OrganisationStructureCreateOrConnectWithoutTeamInput | OrganisationStructureCreateOrConnectWithoutTeamInput[]
    createMany?: OrganisationStructureCreateManyTeamInputEnvelope
    connect?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
  }

  export type AssessmentTeamCreateNestedManyWithoutTeamInput = {
    create?: XOR<AssessmentTeamCreateWithoutTeamInput, AssessmentTeamUncheckedCreateWithoutTeamInput> | AssessmentTeamCreateWithoutTeamInput[] | AssessmentTeamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AssessmentTeamCreateOrConnectWithoutTeamInput | AssessmentTeamCreateOrConnectWithoutTeamInput[]
    createMany?: AssessmentTeamCreateManyTeamInputEnvelope
    connect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
  }

  export type QuestionAnswerCreateNestedManyWithoutTeamInput = {
    create?: XOR<QuestionAnswerCreateWithoutTeamInput, QuestionAnswerUncheckedCreateWithoutTeamInput> | QuestionAnswerCreateWithoutTeamInput[] | QuestionAnswerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutTeamInput | QuestionAnswerCreateOrConnectWithoutTeamInput[]
    createMany?: QuestionAnswerCreateManyTeamInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type OrganisationStructureUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<OrganisationStructureCreateWithoutTeamInput, OrganisationStructureUncheckedCreateWithoutTeamInput> | OrganisationStructureCreateWithoutTeamInput[] | OrganisationStructureUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: OrganisationStructureCreateOrConnectWithoutTeamInput | OrganisationStructureCreateOrConnectWithoutTeamInput[]
    createMany?: OrganisationStructureCreateManyTeamInputEnvelope
    connect?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
  }

  export type AssessmentTeamUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<AssessmentTeamCreateWithoutTeamInput, AssessmentTeamUncheckedCreateWithoutTeamInput> | AssessmentTeamCreateWithoutTeamInput[] | AssessmentTeamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AssessmentTeamCreateOrConnectWithoutTeamInput | AssessmentTeamCreateOrConnectWithoutTeamInput[]
    createMany?: AssessmentTeamCreateManyTeamInputEnvelope
    connect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
  }

  export type QuestionAnswerUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<QuestionAnswerCreateWithoutTeamInput, QuestionAnswerUncheckedCreateWithoutTeamInput> | QuestionAnswerCreateWithoutTeamInput[] | QuestionAnswerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutTeamInput | QuestionAnswerCreateOrConnectWithoutTeamInput[]
    createMany?: QuestionAnswerCreateManyTeamInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type OrganisationUpdateOneRequiredWithoutTeamNestedInput = {
    create?: XOR<OrganisationCreateWithoutTeamInput, OrganisationUncheckedCreateWithoutTeamInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutTeamInput
    upsert?: OrganisationUpsertWithoutTeamInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutTeamInput, OrganisationUpdateWithoutTeamInput>, OrganisationUncheckedUpdateWithoutTeamInput>
  }

  export type OrganisationStructureUpdateManyWithoutTeamNestedInput = {
    create?: XOR<OrganisationStructureCreateWithoutTeamInput, OrganisationStructureUncheckedCreateWithoutTeamInput> | OrganisationStructureCreateWithoutTeamInput[] | OrganisationStructureUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: OrganisationStructureCreateOrConnectWithoutTeamInput | OrganisationStructureCreateOrConnectWithoutTeamInput[]
    upsert?: OrganisationStructureUpsertWithWhereUniqueWithoutTeamInput | OrganisationStructureUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: OrganisationStructureCreateManyTeamInputEnvelope
    set?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    disconnect?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    delete?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    connect?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    update?: OrganisationStructureUpdateWithWhereUniqueWithoutTeamInput | OrganisationStructureUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: OrganisationStructureUpdateManyWithWhereWithoutTeamInput | OrganisationStructureUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: OrganisationStructureScalarWhereInput | OrganisationStructureScalarWhereInput[]
  }

  export type AssessmentTeamUpdateManyWithoutTeamNestedInput = {
    create?: XOR<AssessmentTeamCreateWithoutTeamInput, AssessmentTeamUncheckedCreateWithoutTeamInput> | AssessmentTeamCreateWithoutTeamInput[] | AssessmentTeamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AssessmentTeamCreateOrConnectWithoutTeamInput | AssessmentTeamCreateOrConnectWithoutTeamInput[]
    upsert?: AssessmentTeamUpsertWithWhereUniqueWithoutTeamInput | AssessmentTeamUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: AssessmentTeamCreateManyTeamInputEnvelope
    set?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    disconnect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    delete?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    connect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    update?: AssessmentTeamUpdateWithWhereUniqueWithoutTeamInput | AssessmentTeamUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: AssessmentTeamUpdateManyWithWhereWithoutTeamInput | AssessmentTeamUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: AssessmentTeamScalarWhereInput | AssessmentTeamScalarWhereInput[]
  }

  export type QuestionAnswerUpdateManyWithoutTeamNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutTeamInput, QuestionAnswerUncheckedCreateWithoutTeamInput> | QuestionAnswerCreateWithoutTeamInput[] | QuestionAnswerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutTeamInput | QuestionAnswerCreateOrConnectWithoutTeamInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutTeamInput | QuestionAnswerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: QuestionAnswerCreateManyTeamInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutTeamInput | QuestionAnswerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutTeamInput | QuestionAnswerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type OrganisationStructureUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<OrganisationStructureCreateWithoutTeamInput, OrganisationStructureUncheckedCreateWithoutTeamInput> | OrganisationStructureCreateWithoutTeamInput[] | OrganisationStructureUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: OrganisationStructureCreateOrConnectWithoutTeamInput | OrganisationStructureCreateOrConnectWithoutTeamInput[]
    upsert?: OrganisationStructureUpsertWithWhereUniqueWithoutTeamInput | OrganisationStructureUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: OrganisationStructureCreateManyTeamInputEnvelope
    set?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    disconnect?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    delete?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    connect?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    update?: OrganisationStructureUpdateWithWhereUniqueWithoutTeamInput | OrganisationStructureUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: OrganisationStructureUpdateManyWithWhereWithoutTeamInput | OrganisationStructureUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: OrganisationStructureScalarWhereInput | OrganisationStructureScalarWhereInput[]
  }

  export type AssessmentTeamUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<AssessmentTeamCreateWithoutTeamInput, AssessmentTeamUncheckedCreateWithoutTeamInput> | AssessmentTeamCreateWithoutTeamInput[] | AssessmentTeamUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AssessmentTeamCreateOrConnectWithoutTeamInput | AssessmentTeamCreateOrConnectWithoutTeamInput[]
    upsert?: AssessmentTeamUpsertWithWhereUniqueWithoutTeamInput | AssessmentTeamUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: AssessmentTeamCreateManyTeamInputEnvelope
    set?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    disconnect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    delete?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    connect?: AssessmentTeamWhereUniqueInput | AssessmentTeamWhereUniqueInput[]
    update?: AssessmentTeamUpdateWithWhereUniqueWithoutTeamInput | AssessmentTeamUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: AssessmentTeamUpdateManyWithWhereWithoutTeamInput | AssessmentTeamUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: AssessmentTeamScalarWhereInput | AssessmentTeamScalarWhereInput[]
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutTeamInput, QuestionAnswerUncheckedCreateWithoutTeamInput> | QuestionAnswerCreateWithoutTeamInput[] | QuestionAnswerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutTeamInput | QuestionAnswerCreateOrConnectWithoutTeamInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutTeamInput | QuestionAnswerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: QuestionAnswerCreateManyTeamInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutTeamInput | QuestionAnswerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutTeamInput | QuestionAnswerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type TemplateStageCreateNestedManyWithoutTemplateInput = {
    create?: XOR<TemplateStageCreateWithoutTemplateInput, TemplateStageUncheckedCreateWithoutTemplateInput> | TemplateStageCreateWithoutTemplateInput[] | TemplateStageUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateStageCreateOrConnectWithoutTemplateInput | TemplateStageCreateOrConnectWithoutTemplateInput[]
    createMany?: TemplateStageCreateManyTemplateInputEnvelope
    connect?: TemplateStageWhereUniqueInput | TemplateStageWhereUniqueInput[]
  }

  export type OrganisationTemplateCreateNestedManyWithoutTemplateInput = {
    create?: XOR<OrganisationTemplateCreateWithoutTemplateInput, OrganisationTemplateUncheckedCreateWithoutTemplateInput> | OrganisationTemplateCreateWithoutTemplateInput[] | OrganisationTemplateUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: OrganisationTemplateCreateOrConnectWithoutTemplateInput | OrganisationTemplateCreateOrConnectWithoutTemplateInput[]
    createMany?: OrganisationTemplateCreateManyTemplateInputEnvelope
    connect?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
  }

  export type TemplateStageUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<TemplateStageCreateWithoutTemplateInput, TemplateStageUncheckedCreateWithoutTemplateInput> | TemplateStageCreateWithoutTemplateInput[] | TemplateStageUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateStageCreateOrConnectWithoutTemplateInput | TemplateStageCreateOrConnectWithoutTemplateInput[]
    createMany?: TemplateStageCreateManyTemplateInputEnvelope
    connect?: TemplateStageWhereUniqueInput | TemplateStageWhereUniqueInput[]
  }

  export type OrganisationTemplateUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<OrganisationTemplateCreateWithoutTemplateInput, OrganisationTemplateUncheckedCreateWithoutTemplateInput> | OrganisationTemplateCreateWithoutTemplateInput[] | OrganisationTemplateUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: OrganisationTemplateCreateOrConnectWithoutTemplateInput | OrganisationTemplateCreateOrConnectWithoutTemplateInput[]
    createMany?: OrganisationTemplateCreateManyTemplateInputEnvelope
    connect?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
  }

  export type TemplateStageUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<TemplateStageCreateWithoutTemplateInput, TemplateStageUncheckedCreateWithoutTemplateInput> | TemplateStageCreateWithoutTemplateInput[] | TemplateStageUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateStageCreateOrConnectWithoutTemplateInput | TemplateStageCreateOrConnectWithoutTemplateInput[]
    upsert?: TemplateStageUpsertWithWhereUniqueWithoutTemplateInput | TemplateStageUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: TemplateStageCreateManyTemplateInputEnvelope
    set?: TemplateStageWhereUniqueInput | TemplateStageWhereUniqueInput[]
    disconnect?: TemplateStageWhereUniqueInput | TemplateStageWhereUniqueInput[]
    delete?: TemplateStageWhereUniqueInput | TemplateStageWhereUniqueInput[]
    connect?: TemplateStageWhereUniqueInput | TemplateStageWhereUniqueInput[]
    update?: TemplateStageUpdateWithWhereUniqueWithoutTemplateInput | TemplateStageUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: TemplateStageUpdateManyWithWhereWithoutTemplateInput | TemplateStageUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: TemplateStageScalarWhereInput | TemplateStageScalarWhereInput[]
  }

  export type OrganisationTemplateUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<OrganisationTemplateCreateWithoutTemplateInput, OrganisationTemplateUncheckedCreateWithoutTemplateInput> | OrganisationTemplateCreateWithoutTemplateInput[] | OrganisationTemplateUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: OrganisationTemplateCreateOrConnectWithoutTemplateInput | OrganisationTemplateCreateOrConnectWithoutTemplateInput[]
    upsert?: OrganisationTemplateUpsertWithWhereUniqueWithoutTemplateInput | OrganisationTemplateUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: OrganisationTemplateCreateManyTemplateInputEnvelope
    set?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    disconnect?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    delete?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    connect?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    update?: OrganisationTemplateUpdateWithWhereUniqueWithoutTemplateInput | OrganisationTemplateUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: OrganisationTemplateUpdateManyWithWhereWithoutTemplateInput | OrganisationTemplateUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: OrganisationTemplateScalarWhereInput | OrganisationTemplateScalarWhereInput[]
  }

  export type TemplateStageUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<TemplateStageCreateWithoutTemplateInput, TemplateStageUncheckedCreateWithoutTemplateInput> | TemplateStageCreateWithoutTemplateInput[] | TemplateStageUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateStageCreateOrConnectWithoutTemplateInput | TemplateStageCreateOrConnectWithoutTemplateInput[]
    upsert?: TemplateStageUpsertWithWhereUniqueWithoutTemplateInput | TemplateStageUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: TemplateStageCreateManyTemplateInputEnvelope
    set?: TemplateStageWhereUniqueInput | TemplateStageWhereUniqueInput[]
    disconnect?: TemplateStageWhereUniqueInput | TemplateStageWhereUniqueInput[]
    delete?: TemplateStageWhereUniqueInput | TemplateStageWhereUniqueInput[]
    connect?: TemplateStageWhereUniqueInput | TemplateStageWhereUniqueInput[]
    update?: TemplateStageUpdateWithWhereUniqueWithoutTemplateInput | TemplateStageUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: TemplateStageUpdateManyWithWhereWithoutTemplateInput | TemplateStageUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: TemplateStageScalarWhereInput | TemplateStageScalarWhereInput[]
  }

  export type OrganisationTemplateUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<OrganisationTemplateCreateWithoutTemplateInput, OrganisationTemplateUncheckedCreateWithoutTemplateInput> | OrganisationTemplateCreateWithoutTemplateInput[] | OrganisationTemplateUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: OrganisationTemplateCreateOrConnectWithoutTemplateInput | OrganisationTemplateCreateOrConnectWithoutTemplateInput[]
    upsert?: OrganisationTemplateUpsertWithWhereUniqueWithoutTemplateInput | OrganisationTemplateUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: OrganisationTemplateCreateManyTemplateInputEnvelope
    set?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    disconnect?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    delete?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    connect?: OrganisationTemplateWhereUniqueInput | OrganisationTemplateWhereUniqueInput[]
    update?: OrganisationTemplateUpdateWithWhereUniqueWithoutTemplateInput | OrganisationTemplateUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: OrganisationTemplateUpdateManyWithWhereWithoutTemplateInput | OrganisationTemplateUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: OrganisationTemplateScalarWhereInput | OrganisationTemplateScalarWhereInput[]
  }

  export type TemplateCreateNestedOneWithoutTemplateStageInput = {
    create?: XOR<TemplateCreateWithoutTemplateStageInput, TemplateUncheckedCreateWithoutTemplateStageInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutTemplateStageInput
    connect?: TemplateWhereUniqueInput
  }

  export type TemplateQuestionCreateNestedManyWithoutTemplateStageInput = {
    create?: XOR<TemplateQuestionCreateWithoutTemplateStageInput, TemplateQuestionUncheckedCreateWithoutTemplateStageInput> | TemplateQuestionCreateWithoutTemplateStageInput[] | TemplateQuestionUncheckedCreateWithoutTemplateStageInput[]
    connectOrCreate?: TemplateQuestionCreateOrConnectWithoutTemplateStageInput | TemplateQuestionCreateOrConnectWithoutTemplateStageInput[]
    createMany?: TemplateQuestionCreateManyTemplateStageInputEnvelope
    connect?: TemplateQuestionWhereUniqueInput | TemplateQuestionWhereUniqueInput[]
  }

  export type TemplateQuestionUncheckedCreateNestedManyWithoutTemplateStageInput = {
    create?: XOR<TemplateQuestionCreateWithoutTemplateStageInput, TemplateQuestionUncheckedCreateWithoutTemplateStageInput> | TemplateQuestionCreateWithoutTemplateStageInput[] | TemplateQuestionUncheckedCreateWithoutTemplateStageInput[]
    connectOrCreate?: TemplateQuestionCreateOrConnectWithoutTemplateStageInput | TemplateQuestionCreateOrConnectWithoutTemplateStageInput[]
    createMany?: TemplateQuestionCreateManyTemplateStageInputEnvelope
    connect?: TemplateQuestionWhereUniqueInput | TemplateQuestionWhereUniqueInput[]
  }

  export type TemplateUpdateOneRequiredWithoutTemplateStageNestedInput = {
    create?: XOR<TemplateCreateWithoutTemplateStageInput, TemplateUncheckedCreateWithoutTemplateStageInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutTemplateStageInput
    upsert?: TemplateUpsertWithoutTemplateStageInput
    connect?: TemplateWhereUniqueInput
    update?: XOR<XOR<TemplateUpdateToOneWithWhereWithoutTemplateStageInput, TemplateUpdateWithoutTemplateStageInput>, TemplateUncheckedUpdateWithoutTemplateStageInput>
  }

  export type TemplateQuestionUpdateManyWithoutTemplateStageNestedInput = {
    create?: XOR<TemplateQuestionCreateWithoutTemplateStageInput, TemplateQuestionUncheckedCreateWithoutTemplateStageInput> | TemplateQuestionCreateWithoutTemplateStageInput[] | TemplateQuestionUncheckedCreateWithoutTemplateStageInput[]
    connectOrCreate?: TemplateQuestionCreateOrConnectWithoutTemplateStageInput | TemplateQuestionCreateOrConnectWithoutTemplateStageInput[]
    upsert?: TemplateQuestionUpsertWithWhereUniqueWithoutTemplateStageInput | TemplateQuestionUpsertWithWhereUniqueWithoutTemplateStageInput[]
    createMany?: TemplateQuestionCreateManyTemplateStageInputEnvelope
    set?: TemplateQuestionWhereUniqueInput | TemplateQuestionWhereUniqueInput[]
    disconnect?: TemplateQuestionWhereUniqueInput | TemplateQuestionWhereUniqueInput[]
    delete?: TemplateQuestionWhereUniqueInput | TemplateQuestionWhereUniqueInput[]
    connect?: TemplateQuestionWhereUniqueInput | TemplateQuestionWhereUniqueInput[]
    update?: TemplateQuestionUpdateWithWhereUniqueWithoutTemplateStageInput | TemplateQuestionUpdateWithWhereUniqueWithoutTemplateStageInput[]
    updateMany?: TemplateQuestionUpdateManyWithWhereWithoutTemplateStageInput | TemplateQuestionUpdateManyWithWhereWithoutTemplateStageInput[]
    deleteMany?: TemplateQuestionScalarWhereInput | TemplateQuestionScalarWhereInput[]
  }

  export type TemplateQuestionUncheckedUpdateManyWithoutTemplateStageNestedInput = {
    create?: XOR<TemplateQuestionCreateWithoutTemplateStageInput, TemplateQuestionUncheckedCreateWithoutTemplateStageInput> | TemplateQuestionCreateWithoutTemplateStageInput[] | TemplateQuestionUncheckedCreateWithoutTemplateStageInput[]
    connectOrCreate?: TemplateQuestionCreateOrConnectWithoutTemplateStageInput | TemplateQuestionCreateOrConnectWithoutTemplateStageInput[]
    upsert?: TemplateQuestionUpsertWithWhereUniqueWithoutTemplateStageInput | TemplateQuestionUpsertWithWhereUniqueWithoutTemplateStageInput[]
    createMany?: TemplateQuestionCreateManyTemplateStageInputEnvelope
    set?: TemplateQuestionWhereUniqueInput | TemplateQuestionWhereUniqueInput[]
    disconnect?: TemplateQuestionWhereUniqueInput | TemplateQuestionWhereUniqueInput[]
    delete?: TemplateQuestionWhereUniqueInput | TemplateQuestionWhereUniqueInput[]
    connect?: TemplateQuestionWhereUniqueInput | TemplateQuestionWhereUniqueInput[]
    update?: TemplateQuestionUpdateWithWhereUniqueWithoutTemplateStageInput | TemplateQuestionUpdateWithWhereUniqueWithoutTemplateStageInput[]
    updateMany?: TemplateQuestionUpdateManyWithWhereWithoutTemplateStageInput | TemplateQuestionUpdateManyWithWhereWithoutTemplateStageInput[]
    deleteMany?: TemplateQuestionScalarWhereInput | TemplateQuestionScalarWhereInput[]
  }

  export type TemplateStageCreateNestedOneWithoutTemplateQuestionInput = {
    create?: XOR<TemplateStageCreateWithoutTemplateQuestionInput, TemplateStageUncheckedCreateWithoutTemplateQuestionInput>
    connectOrCreate?: TemplateStageCreateOrConnectWithoutTemplateQuestionInput
    connect?: TemplateStageWhereUniqueInput
  }

  export type TemplateQuestionAnswerCreateNestedManyWithoutTemplateQuestionInput = {
    create?: XOR<TemplateQuestionAnswerCreateWithoutTemplateQuestionInput, TemplateQuestionAnswerUncheckedCreateWithoutTemplateQuestionInput> | TemplateQuestionAnswerCreateWithoutTemplateQuestionInput[] | TemplateQuestionAnswerUncheckedCreateWithoutTemplateQuestionInput[]
    connectOrCreate?: TemplateQuestionAnswerCreateOrConnectWithoutTemplateQuestionInput | TemplateQuestionAnswerCreateOrConnectWithoutTemplateQuestionInput[]
    createMany?: TemplateQuestionAnswerCreateManyTemplateQuestionInputEnvelope
    connect?: TemplateQuestionAnswerWhereUniqueInput | TemplateQuestionAnswerWhereUniqueInput[]
  }

  export type TemplateQuestionAnswerUncheckedCreateNestedManyWithoutTemplateQuestionInput = {
    create?: XOR<TemplateQuestionAnswerCreateWithoutTemplateQuestionInput, TemplateQuestionAnswerUncheckedCreateWithoutTemplateQuestionInput> | TemplateQuestionAnswerCreateWithoutTemplateQuestionInput[] | TemplateQuestionAnswerUncheckedCreateWithoutTemplateQuestionInput[]
    connectOrCreate?: TemplateQuestionAnswerCreateOrConnectWithoutTemplateQuestionInput | TemplateQuestionAnswerCreateOrConnectWithoutTemplateQuestionInput[]
    createMany?: TemplateQuestionAnswerCreateManyTemplateQuestionInputEnvelope
    connect?: TemplateQuestionAnswerWhereUniqueInput | TemplateQuestionAnswerWhereUniqueInput[]
  }

  export type TemplateStageUpdateOneRequiredWithoutTemplateQuestionNestedInput = {
    create?: XOR<TemplateStageCreateWithoutTemplateQuestionInput, TemplateStageUncheckedCreateWithoutTemplateQuestionInput>
    connectOrCreate?: TemplateStageCreateOrConnectWithoutTemplateQuestionInput
    upsert?: TemplateStageUpsertWithoutTemplateQuestionInput
    connect?: TemplateStageWhereUniqueInput
    update?: XOR<XOR<TemplateStageUpdateToOneWithWhereWithoutTemplateQuestionInput, TemplateStageUpdateWithoutTemplateQuestionInput>, TemplateStageUncheckedUpdateWithoutTemplateQuestionInput>
  }

  export type TemplateQuestionAnswerUpdateManyWithoutTemplateQuestionNestedInput = {
    create?: XOR<TemplateQuestionAnswerCreateWithoutTemplateQuestionInput, TemplateQuestionAnswerUncheckedCreateWithoutTemplateQuestionInput> | TemplateQuestionAnswerCreateWithoutTemplateQuestionInput[] | TemplateQuestionAnswerUncheckedCreateWithoutTemplateQuestionInput[]
    connectOrCreate?: TemplateQuestionAnswerCreateOrConnectWithoutTemplateQuestionInput | TemplateQuestionAnswerCreateOrConnectWithoutTemplateQuestionInput[]
    upsert?: TemplateQuestionAnswerUpsertWithWhereUniqueWithoutTemplateQuestionInput | TemplateQuestionAnswerUpsertWithWhereUniqueWithoutTemplateQuestionInput[]
    createMany?: TemplateQuestionAnswerCreateManyTemplateQuestionInputEnvelope
    set?: TemplateQuestionAnswerWhereUniqueInput | TemplateQuestionAnswerWhereUniqueInput[]
    disconnect?: TemplateQuestionAnswerWhereUniqueInput | TemplateQuestionAnswerWhereUniqueInput[]
    delete?: TemplateQuestionAnswerWhereUniqueInput | TemplateQuestionAnswerWhereUniqueInput[]
    connect?: TemplateQuestionAnswerWhereUniqueInput | TemplateQuestionAnswerWhereUniqueInput[]
    update?: TemplateQuestionAnswerUpdateWithWhereUniqueWithoutTemplateQuestionInput | TemplateQuestionAnswerUpdateWithWhereUniqueWithoutTemplateQuestionInput[]
    updateMany?: TemplateQuestionAnswerUpdateManyWithWhereWithoutTemplateQuestionInput | TemplateQuestionAnswerUpdateManyWithWhereWithoutTemplateQuestionInput[]
    deleteMany?: TemplateQuestionAnswerScalarWhereInput | TemplateQuestionAnswerScalarWhereInput[]
  }

  export type TemplateQuestionAnswerUncheckedUpdateManyWithoutTemplateQuestionNestedInput = {
    create?: XOR<TemplateQuestionAnswerCreateWithoutTemplateQuestionInput, TemplateQuestionAnswerUncheckedCreateWithoutTemplateQuestionInput> | TemplateQuestionAnswerCreateWithoutTemplateQuestionInput[] | TemplateQuestionAnswerUncheckedCreateWithoutTemplateQuestionInput[]
    connectOrCreate?: TemplateQuestionAnswerCreateOrConnectWithoutTemplateQuestionInput | TemplateQuestionAnswerCreateOrConnectWithoutTemplateQuestionInput[]
    upsert?: TemplateQuestionAnswerUpsertWithWhereUniqueWithoutTemplateQuestionInput | TemplateQuestionAnswerUpsertWithWhereUniqueWithoutTemplateQuestionInput[]
    createMany?: TemplateQuestionAnswerCreateManyTemplateQuestionInputEnvelope
    set?: TemplateQuestionAnswerWhereUniqueInput | TemplateQuestionAnswerWhereUniqueInput[]
    disconnect?: TemplateQuestionAnswerWhereUniqueInput | TemplateQuestionAnswerWhereUniqueInput[]
    delete?: TemplateQuestionAnswerWhereUniqueInput | TemplateQuestionAnswerWhereUniqueInput[]
    connect?: TemplateQuestionAnswerWhereUniqueInput | TemplateQuestionAnswerWhereUniqueInput[]
    update?: TemplateQuestionAnswerUpdateWithWhereUniqueWithoutTemplateQuestionInput | TemplateQuestionAnswerUpdateWithWhereUniqueWithoutTemplateQuestionInput[]
    updateMany?: TemplateQuestionAnswerUpdateManyWithWhereWithoutTemplateQuestionInput | TemplateQuestionAnswerUpdateManyWithWhereWithoutTemplateQuestionInput[]
    deleteMany?: TemplateQuestionAnswerScalarWhereInput | TemplateQuestionAnswerScalarWhereInput[]
  }

  export type TemplateQuestionCreateNestedOneWithoutTemplateQuestionAnswerInput = {
    create?: XOR<TemplateQuestionCreateWithoutTemplateQuestionAnswerInput, TemplateQuestionUncheckedCreateWithoutTemplateQuestionAnswerInput>
    connectOrCreate?: TemplateQuestionCreateOrConnectWithoutTemplateQuestionAnswerInput
    connect?: TemplateQuestionWhereUniqueInput
  }

  export type TemplateQuestionUpdateOneRequiredWithoutTemplateQuestionAnswerNestedInput = {
    create?: XOR<TemplateQuestionCreateWithoutTemplateQuestionAnswerInput, TemplateQuestionUncheckedCreateWithoutTemplateQuestionAnswerInput>
    connectOrCreate?: TemplateQuestionCreateOrConnectWithoutTemplateQuestionAnswerInput
    upsert?: TemplateQuestionUpsertWithoutTemplateQuestionAnswerInput
    connect?: TemplateQuestionWhereUniqueInput
    update?: XOR<XOR<TemplateQuestionUpdateToOneWithWhereWithoutTemplateQuestionAnswerInput, TemplateQuestionUpdateWithoutTemplateQuestionAnswerInput>, TemplateQuestionUncheckedUpdateWithoutTemplateQuestionAnswerInput>
  }

  export type OrganisationCreateNestedOneWithoutOwnerInput = {
    create?: XOR<OrganisationCreateWithoutOwnerInput, OrganisationUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutOwnerInput
    connect?: OrganisationWhereUniqueInput
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type OrganisationStructureCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganisationStructureCreateWithoutUserInput, OrganisationStructureUncheckedCreateWithoutUserInput> | OrganisationStructureCreateWithoutUserInput[] | OrganisationStructureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganisationStructureCreateOrConnectWithoutUserInput | OrganisationStructureCreateOrConnectWithoutUserInput[]
    createMany?: OrganisationStructureCreateManyUserInputEnvelope
    connect?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
  }

  export type QuestionAnswerCreateNestedManyWithoutUserInput = {
    create?: XOR<QuestionAnswerCreateWithoutUserInput, QuestionAnswerUncheckedCreateWithoutUserInput> | QuestionAnswerCreateWithoutUserInput[] | QuestionAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutUserInput | QuestionAnswerCreateOrConnectWithoutUserInput[]
    createMany?: QuestionAnswerCreateManyUserInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type OrganisationUncheckedCreateNestedOneWithoutOwnerInput = {
    create?: XOR<OrganisationCreateWithoutOwnerInput, OrganisationUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutOwnerInput
    connect?: OrganisationWhereUniqueInput
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type OrganisationStructureUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganisationStructureCreateWithoutUserInput, OrganisationStructureUncheckedCreateWithoutUserInput> | OrganisationStructureCreateWithoutUserInput[] | OrganisationStructureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganisationStructureCreateOrConnectWithoutUserInput | OrganisationStructureCreateOrConnectWithoutUserInput[]
    createMany?: OrganisationStructureCreateManyUserInputEnvelope
    connect?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
  }

  export type QuestionAnswerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuestionAnswerCreateWithoutUserInput, QuestionAnswerUncheckedCreateWithoutUserInput> | QuestionAnswerCreateWithoutUserInput[] | QuestionAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutUserInput | QuestionAnswerCreateOrConnectWithoutUserInput[]
    createMany?: QuestionAnswerCreateManyUserInputEnvelope
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type OrganisationUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<OrganisationCreateWithoutOwnerInput, OrganisationUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutOwnerInput
    upsert?: OrganisationUpsertWithoutOwnerInput
    disconnect?: OrganisationWhereInput | boolean
    delete?: OrganisationWhereInput | boolean
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutOwnerInput, OrganisationUpdateWithoutOwnerInput>, OrganisationUncheckedUpdateWithoutOwnerInput>
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type OrganisationStructureUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganisationStructureCreateWithoutUserInput, OrganisationStructureUncheckedCreateWithoutUserInput> | OrganisationStructureCreateWithoutUserInput[] | OrganisationStructureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganisationStructureCreateOrConnectWithoutUserInput | OrganisationStructureCreateOrConnectWithoutUserInput[]
    upsert?: OrganisationStructureUpsertWithWhereUniqueWithoutUserInput | OrganisationStructureUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganisationStructureCreateManyUserInputEnvelope
    set?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    disconnect?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    delete?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    connect?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    update?: OrganisationStructureUpdateWithWhereUniqueWithoutUserInput | OrganisationStructureUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganisationStructureUpdateManyWithWhereWithoutUserInput | OrganisationStructureUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganisationStructureScalarWhereInput | OrganisationStructureScalarWhereInput[]
  }

  export type QuestionAnswerUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutUserInput, QuestionAnswerUncheckedCreateWithoutUserInput> | QuestionAnswerCreateWithoutUserInput[] | QuestionAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutUserInput | QuestionAnswerCreateOrConnectWithoutUserInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutUserInput | QuestionAnswerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuestionAnswerCreateManyUserInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutUserInput | QuestionAnswerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutUserInput | QuestionAnswerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type OrganisationUncheckedUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<OrganisationCreateWithoutOwnerInput, OrganisationUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutOwnerInput
    upsert?: OrganisationUpsertWithoutOwnerInput
    disconnect?: OrganisationWhereInput | boolean
    delete?: OrganisationWhereInput | boolean
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutOwnerInput, OrganisationUpdateWithoutOwnerInput>, OrganisationUncheckedUpdateWithoutOwnerInput>
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type OrganisationStructureUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganisationStructureCreateWithoutUserInput, OrganisationStructureUncheckedCreateWithoutUserInput> | OrganisationStructureCreateWithoutUserInput[] | OrganisationStructureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganisationStructureCreateOrConnectWithoutUserInput | OrganisationStructureCreateOrConnectWithoutUserInput[]
    upsert?: OrganisationStructureUpsertWithWhereUniqueWithoutUserInput | OrganisationStructureUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganisationStructureCreateManyUserInputEnvelope
    set?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    disconnect?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    delete?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    connect?: OrganisationStructureWhereUniqueInput | OrganisationStructureWhereUniqueInput[]
    update?: OrganisationStructureUpdateWithWhereUniqueWithoutUserInput | OrganisationStructureUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganisationStructureUpdateManyWithWhereWithoutUserInput | OrganisationStructureUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganisationStructureScalarWhereInput | OrganisationStructureScalarWhereInput[]
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuestionAnswerCreateWithoutUserInput, QuestionAnswerUncheckedCreateWithoutUserInput> | QuestionAnswerCreateWithoutUserInput[] | QuestionAnswerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionAnswerCreateOrConnectWithoutUserInput | QuestionAnswerCreateOrConnectWithoutUserInput[]
    upsert?: QuestionAnswerUpsertWithWhereUniqueWithoutUserInput | QuestionAnswerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuestionAnswerCreateManyUserInputEnvelope
    set?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    disconnect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    delete?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    connect?: QuestionAnswerWhereUniqueInput | QuestionAnswerWhereUniqueInput[]
    update?: QuestionAnswerUpdateWithWhereUniqueWithoutUserInput | QuestionAnswerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuestionAnswerUpdateManyWithWhereWithoutUserInput | QuestionAnswerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserRoleInput = {
    create?: XOR<UserCreateWithoutUserRoleInput, UserUncheckedCreateWithoutUserRoleInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRoleInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUserRoleInput = {
    create?: XOR<RoleCreateWithoutUserRoleInput, RoleUncheckedCreateWithoutUserRoleInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRoleInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserRoleNestedInput = {
    create?: XOR<UserCreateWithoutUserRoleInput, UserUncheckedCreateWithoutUserRoleInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRoleInput
    upsert?: UserUpsertWithoutUserRoleInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRoleInput, UserUpdateWithoutUserRoleInput>, UserUncheckedUpdateWithoutUserRoleInput>
  }

  export type RoleUpdateOneRequiredWithoutUserRoleNestedInput = {
    create?: XOR<RoleCreateWithoutUserRoleInput, RoleUncheckedCreateWithoutUserRoleInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRoleInput
    upsert?: RoleUpsertWithoutUserRoleInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserRoleInput, RoleUpdateWithoutUserRoleInput>, RoleUncheckedUpdateWithoutUserRoleInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type OrganisationCreateWithoutAssessmentInput = {
    name: string
    description?: string | null
    isActive?: boolean | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Owner?: UserCreateNestedOneWithoutOrganisationInput
    Team?: TeamCreateNestedManyWithoutOrganisationInput
    OrganisationTemplate?: OrganisationTemplateCreateNestedManyWithoutOrganisationInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutOrganisationInput
    AssessmentTeam?: AssessmentTeamCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutAssessmentInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    ownerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Team?: TeamUncheckedCreateNestedManyWithoutOrganisationInput
    OrganisationTemplate?: OrganisationTemplateUncheckedCreateNestedManyWithoutOrganisationInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutOrganisationInput
    AssessmentTeam?: AssessmentTeamUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutAssessmentInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutAssessmentInput, OrganisationUncheckedCreateWithoutAssessmentInput>
  }

  export type AssessmentQuestionCreateWithoutAssessmentInput = {
    assessmentStage: string
    questionMongoId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutAssessmentQuestionInput
  }

  export type AssessmentQuestionUncheckedCreateWithoutAssessmentInput = {
    id?: number
    assessmentStage: string
    questionMongoId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutAssessmentQuestionInput
  }

  export type AssessmentQuestionCreateOrConnectWithoutAssessmentInput = {
    where: AssessmentQuestionWhereUniqueInput
    create: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput>
  }

  export type AssessmentQuestionCreateManyAssessmentInputEnvelope = {
    data: AssessmentQuestionCreateManyAssessmentInput | AssessmentQuestionCreateManyAssessmentInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationTemplateCreateWithoutAssessmentInput = {
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation: OrganisationCreateNestedOneWithoutOrganisationTemplateInput
    Template?: TemplateCreateNestedOneWithoutOrganisationTemplateInput
  }

  export type OrganisationTemplateUncheckedCreateWithoutAssessmentInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId: number
  }

  export type OrganisationTemplateCreateOrConnectWithoutAssessmentInput = {
    where: OrganisationTemplateWhereUniqueInput
    create: XOR<OrganisationTemplateCreateWithoutAssessmentInput, OrganisationTemplateUncheckedCreateWithoutAssessmentInput>
  }

  export type AssessmentTeamCreateWithoutAssessmentInput = {
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation: OrganisationCreateNestedOneWithoutAssessmentTeamInput
    Team: TeamCreateNestedOneWithoutAssessmentTeamInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutAssessmentTeamInput
  }

  export type AssessmentTeamUncheckedCreateWithoutAssessmentInput = {
    id?: number
    organisationId: number
    teamId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutAssessmentTeamInput
  }

  export type AssessmentTeamCreateOrConnectWithoutAssessmentInput = {
    where: AssessmentTeamWhereUniqueInput
    create: XOR<AssessmentTeamCreateWithoutAssessmentInput, AssessmentTeamUncheckedCreateWithoutAssessmentInput>
  }

  export type AssessmentTeamCreateManyAssessmentInputEnvelope = {
    data: AssessmentTeamCreateManyAssessmentInput | AssessmentTeamCreateManyAssessmentInput[]
    skipDuplicates?: boolean
  }

  export type QuestionAnswerCreateWithoutAssessmentInput = {
    assessmentStage: string
    questionMongoId: string
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation?: OrganisationCreateNestedOneWithoutQuestionAnswerInput
    OrganisationStructure?: OrganisationStructureCreateNestedOneWithoutQuestionAnswerInput
    Team?: TeamCreateNestedOneWithoutQuestionAnswerInput
    User?: UserCreateNestedOneWithoutQuestionAnswerInput
    AssessmentTeam?: AssessmentTeamCreateNestedOneWithoutQuestionAnswerInput
    AssessmentQuestion?: AssessmentQuestionCreateNestedOneWithoutQuestionAnswerInput
  }

  export type QuestionAnswerUncheckedCreateWithoutAssessmentInput = {
    id?: number
    organisationId?: number | null
    organisationStructureId?: number | null
    teamId?: number | null
    userId?: number | null
    assessmentTeamId?: number | null
    assessmentStage: string
    questionMongoId: string
    assessmentQuestionId?: number | null
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerCreateOrConnectWithoutAssessmentInput = {
    where: QuestionAnswerWhereUniqueInput
    create: XOR<QuestionAnswerCreateWithoutAssessmentInput, QuestionAnswerUncheckedCreateWithoutAssessmentInput>
  }

  export type QuestionAnswerCreateManyAssessmentInputEnvelope = {
    data: QuestionAnswerCreateManyAssessmentInput | QuestionAnswerCreateManyAssessmentInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationUpsertWithoutAssessmentInput = {
    update: XOR<OrganisationUpdateWithoutAssessmentInput, OrganisationUncheckedUpdateWithoutAssessmentInput>
    create: XOR<OrganisationCreateWithoutAssessmentInput, OrganisationUncheckedCreateWithoutAssessmentInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutAssessmentInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutAssessmentInput, OrganisationUncheckedUpdateWithoutAssessmentInput>
  }

  export type OrganisationUpdateWithoutAssessmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Owner?: UserUpdateOneWithoutOrganisationNestedInput
    Team?: TeamUpdateManyWithoutOrganisationNestedInput
    OrganisationTemplate?: OrganisationTemplateUpdateManyWithoutOrganisationNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutOrganisationNestedInput
    AssessmentTeam?: AssessmentTeamUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Team?: TeamUncheckedUpdateManyWithoutOrganisationNestedInput
    OrganisationTemplate?: OrganisationTemplateUncheckedUpdateManyWithoutOrganisationNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutOrganisationNestedInput
    AssessmentTeam?: AssessmentTeamUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type AssessmentQuestionUpsertWithWhereUniqueWithoutAssessmentInput = {
    where: AssessmentQuestionWhereUniqueInput
    update: XOR<AssessmentQuestionUpdateWithoutAssessmentInput, AssessmentQuestionUncheckedUpdateWithoutAssessmentInput>
    create: XOR<AssessmentQuestionCreateWithoutAssessmentInput, AssessmentQuestionUncheckedCreateWithoutAssessmentInput>
  }

  export type AssessmentQuestionUpdateWithWhereUniqueWithoutAssessmentInput = {
    where: AssessmentQuestionWhereUniqueInput
    data: XOR<AssessmentQuestionUpdateWithoutAssessmentInput, AssessmentQuestionUncheckedUpdateWithoutAssessmentInput>
  }

  export type AssessmentQuestionUpdateManyWithWhereWithoutAssessmentInput = {
    where: AssessmentQuestionScalarWhereInput
    data: XOR<AssessmentQuestionUpdateManyMutationInput, AssessmentQuestionUncheckedUpdateManyWithoutAssessmentInput>
  }

  export type AssessmentQuestionScalarWhereInput = {
    AND?: AssessmentQuestionScalarWhereInput | AssessmentQuestionScalarWhereInput[]
    OR?: AssessmentQuestionScalarWhereInput[]
    NOT?: AssessmentQuestionScalarWhereInput | AssessmentQuestionScalarWhereInput[]
    id?: IntFilter<"AssessmentQuestion"> | number
    assessmentId?: IntFilter<"AssessmentQuestion"> | number
    assessmentStage?: StringFilter<"AssessmentQuestion"> | string
    questionMongoId?: StringFilter<"AssessmentQuestion"> | string
    isActive?: BoolFilter<"AssessmentQuestion"> | boolean
    createdAt?: DateTimeFilter<"AssessmentQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"AssessmentQuestion"> | Date | string
  }

  export type OrganisationTemplateUpsertWithoutAssessmentInput = {
    update: XOR<OrganisationTemplateUpdateWithoutAssessmentInput, OrganisationTemplateUncheckedUpdateWithoutAssessmentInput>
    create: XOR<OrganisationTemplateCreateWithoutAssessmentInput, OrganisationTemplateUncheckedCreateWithoutAssessmentInput>
    where?: OrganisationTemplateWhereInput
  }

  export type OrganisationTemplateUpdateToOneWithWhereWithoutAssessmentInput = {
    where?: OrganisationTemplateWhereInput
    data: XOR<OrganisationTemplateUpdateWithoutAssessmentInput, OrganisationTemplateUncheckedUpdateWithoutAssessmentInput>
  }

  export type OrganisationTemplateUpdateWithoutAssessmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneRequiredWithoutOrganisationTemplateNestedInput
    Template?: TemplateUpdateOneWithoutOrganisationTemplateNestedInput
  }

  export type OrganisationTemplateUncheckedUpdateWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
  }

  export type AssessmentTeamUpsertWithWhereUniqueWithoutAssessmentInput = {
    where: AssessmentTeamWhereUniqueInput
    update: XOR<AssessmentTeamUpdateWithoutAssessmentInput, AssessmentTeamUncheckedUpdateWithoutAssessmentInput>
    create: XOR<AssessmentTeamCreateWithoutAssessmentInput, AssessmentTeamUncheckedCreateWithoutAssessmentInput>
  }

  export type AssessmentTeamUpdateWithWhereUniqueWithoutAssessmentInput = {
    where: AssessmentTeamWhereUniqueInput
    data: XOR<AssessmentTeamUpdateWithoutAssessmentInput, AssessmentTeamUncheckedUpdateWithoutAssessmentInput>
  }

  export type AssessmentTeamUpdateManyWithWhereWithoutAssessmentInput = {
    where: AssessmentTeamScalarWhereInput
    data: XOR<AssessmentTeamUpdateManyMutationInput, AssessmentTeamUncheckedUpdateManyWithoutAssessmentInput>
  }

  export type AssessmentTeamScalarWhereInput = {
    AND?: AssessmentTeamScalarWhereInput | AssessmentTeamScalarWhereInput[]
    OR?: AssessmentTeamScalarWhereInput[]
    NOT?: AssessmentTeamScalarWhereInput | AssessmentTeamScalarWhereInput[]
    id?: IntFilter<"AssessmentTeam"> | number
    assessmentId?: IntFilter<"AssessmentTeam"> | number
    organisationId?: IntFilter<"AssessmentTeam"> | number
    teamId?: IntFilter<"AssessmentTeam"> | number
    password?: StringNullableFilter<"AssessmentTeam"> | string | null
    rememberToken?: StringNullableFilter<"AssessmentTeam"> | string | null
    isActive?: BoolFilter<"AssessmentTeam"> | boolean
    secretToken?: StringNullableFilter<"AssessmentTeam"> | string | null
    tfaToken?: StringNullableFilter<"AssessmentTeam"> | string | null
    createdAt?: DateTimeFilter<"AssessmentTeam"> | Date | string
    updatedAt?: DateTimeFilter<"AssessmentTeam"> | Date | string
  }

  export type QuestionAnswerUpsertWithWhereUniqueWithoutAssessmentInput = {
    where: QuestionAnswerWhereUniqueInput
    update: XOR<QuestionAnswerUpdateWithoutAssessmentInput, QuestionAnswerUncheckedUpdateWithoutAssessmentInput>
    create: XOR<QuestionAnswerCreateWithoutAssessmentInput, QuestionAnswerUncheckedCreateWithoutAssessmentInput>
  }

  export type QuestionAnswerUpdateWithWhereUniqueWithoutAssessmentInput = {
    where: QuestionAnswerWhereUniqueInput
    data: XOR<QuestionAnswerUpdateWithoutAssessmentInput, QuestionAnswerUncheckedUpdateWithoutAssessmentInput>
  }

  export type QuestionAnswerUpdateManyWithWhereWithoutAssessmentInput = {
    where: QuestionAnswerScalarWhereInput
    data: XOR<QuestionAnswerUpdateManyMutationInput, QuestionAnswerUncheckedUpdateManyWithoutAssessmentInput>
  }

  export type QuestionAnswerScalarWhereInput = {
    AND?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
    OR?: QuestionAnswerScalarWhereInput[]
    NOT?: QuestionAnswerScalarWhereInput | QuestionAnswerScalarWhereInput[]
    id?: IntFilter<"QuestionAnswer"> | number
    organisationId?: IntNullableFilter<"QuestionAnswer"> | number | null
    organisationStructureId?: IntNullableFilter<"QuestionAnswer"> | number | null
    teamId?: IntNullableFilter<"QuestionAnswer"> | number | null
    userId?: IntNullableFilter<"QuestionAnswer"> | number | null
    assessmentTeamId?: IntNullableFilter<"QuestionAnswer"> | number | null
    assessmentId?: IntNullableFilter<"QuestionAnswer"> | number | null
    assessmentStage?: StringFilter<"QuestionAnswer"> | string
    questionMongoId?: StringFilter<"QuestionAnswer"> | string
    assessmentQuestionId?: IntNullableFilter<"QuestionAnswer"> | number | null
    password?: StringNullableFilter<"QuestionAnswer"> | string | null
    rememberToken?: StringNullableFilter<"QuestionAnswer"> | string | null
    notes?: StringNullableFilter<"QuestionAnswer"> | string | null
    isActive?: BoolFilter<"QuestionAnswer"> | boolean
    secretToken?: StringNullableFilter<"QuestionAnswer"> | string | null
    tfaToken?: StringNullableFilter<"QuestionAnswer"> | string | null
    createdAt?: DateTimeFilter<"QuestionAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionAnswer"> | Date | string
  }

  export type AssessmentCreateWithoutAssessmentQuestionInput = {
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation: OrganisationCreateNestedOneWithoutAssessmentInput
    OrganisationTemplate?: OrganisationTemplateCreateNestedOneWithoutAssessmentInput
    AssessmentTeam?: AssessmentTeamCreateNestedManyWithoutAssessmentInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUncheckedCreateWithoutAssessmentQuestionInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organisationTemplateId?: number | null
    AssessmentTeam?: AssessmentTeamUncheckedCreateNestedManyWithoutAssessmentInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentCreateOrConnectWithoutAssessmentQuestionInput = {
    where: AssessmentWhereUniqueInput
    create: XOR<AssessmentCreateWithoutAssessmentQuestionInput, AssessmentUncheckedCreateWithoutAssessmentQuestionInput>
  }

  export type QuestionAnswerCreateWithoutAssessmentQuestionInput = {
    assessmentStage: string
    questionMongoId: string
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation?: OrganisationCreateNestedOneWithoutQuestionAnswerInput
    OrganisationStructure?: OrganisationStructureCreateNestedOneWithoutQuestionAnswerInput
    Team?: TeamCreateNestedOneWithoutQuestionAnswerInput
    User?: UserCreateNestedOneWithoutQuestionAnswerInput
    AssessmentTeam?: AssessmentTeamCreateNestedOneWithoutQuestionAnswerInput
    Assessment?: AssessmentCreateNestedOneWithoutQuestionAnswerInput
  }

  export type QuestionAnswerUncheckedCreateWithoutAssessmentQuestionInput = {
    id?: number
    organisationId?: number | null
    organisationStructureId?: number | null
    teamId?: number | null
    userId?: number | null
    assessmentTeamId?: number | null
    assessmentId?: number | null
    assessmentStage: string
    questionMongoId: string
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerCreateOrConnectWithoutAssessmentQuestionInput = {
    where: QuestionAnswerWhereUniqueInput
    create: XOR<QuestionAnswerCreateWithoutAssessmentQuestionInput, QuestionAnswerUncheckedCreateWithoutAssessmentQuestionInput>
  }

  export type QuestionAnswerCreateManyAssessmentQuestionInputEnvelope = {
    data: QuestionAnswerCreateManyAssessmentQuestionInput | QuestionAnswerCreateManyAssessmentQuestionInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentUpsertWithoutAssessmentQuestionInput = {
    update: XOR<AssessmentUpdateWithoutAssessmentQuestionInput, AssessmentUncheckedUpdateWithoutAssessmentQuestionInput>
    create: XOR<AssessmentCreateWithoutAssessmentQuestionInput, AssessmentUncheckedCreateWithoutAssessmentQuestionInput>
    where?: AssessmentWhereInput
  }

  export type AssessmentUpdateToOneWithWhereWithoutAssessmentQuestionInput = {
    where?: AssessmentWhereInput
    data: XOR<AssessmentUpdateWithoutAssessmentQuestionInput, AssessmentUncheckedUpdateWithoutAssessmentQuestionInput>
  }

  export type AssessmentUpdateWithoutAssessmentQuestionInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneRequiredWithoutAssessmentNestedInput
    OrganisationTemplate?: OrganisationTemplateUpdateOneWithoutAssessmentNestedInput
    AssessmentTeam?: AssessmentTeamUpdateManyWithoutAssessmentNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateWithoutAssessmentQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organisationTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    AssessmentTeam?: AssessmentTeamUncheckedUpdateManyWithoutAssessmentNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type QuestionAnswerUpsertWithWhereUniqueWithoutAssessmentQuestionInput = {
    where: QuestionAnswerWhereUniqueInput
    update: XOR<QuestionAnswerUpdateWithoutAssessmentQuestionInput, QuestionAnswerUncheckedUpdateWithoutAssessmentQuestionInput>
    create: XOR<QuestionAnswerCreateWithoutAssessmentQuestionInput, QuestionAnswerUncheckedCreateWithoutAssessmentQuestionInput>
  }

  export type QuestionAnswerUpdateWithWhereUniqueWithoutAssessmentQuestionInput = {
    where: QuestionAnswerWhereUniqueInput
    data: XOR<QuestionAnswerUpdateWithoutAssessmentQuestionInput, QuestionAnswerUncheckedUpdateWithoutAssessmentQuestionInput>
  }

  export type QuestionAnswerUpdateManyWithWhereWithoutAssessmentQuestionInput = {
    where: QuestionAnswerScalarWhereInput
    data: XOR<QuestionAnswerUpdateManyMutationInput, QuestionAnswerUncheckedUpdateManyWithoutAssessmentQuestionInput>
  }

  export type AssessmentCreateWithoutAssessmentTeamInput = {
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation: OrganisationCreateNestedOneWithoutAssessmentInput
    AssessmentQuestion?: AssessmentQuestionCreateNestedManyWithoutAssessmentInput
    OrganisationTemplate?: OrganisationTemplateCreateNestedOneWithoutAssessmentInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUncheckedCreateWithoutAssessmentTeamInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organisationTemplateId?: number | null
    AssessmentQuestion?: AssessmentQuestionUncheckedCreateNestedManyWithoutAssessmentInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentCreateOrConnectWithoutAssessmentTeamInput = {
    where: AssessmentWhereUniqueInput
    create: XOR<AssessmentCreateWithoutAssessmentTeamInput, AssessmentUncheckedCreateWithoutAssessmentTeamInput>
  }

  export type OrganisationCreateWithoutAssessmentTeamInput = {
    name: string
    description?: string | null
    isActive?: boolean | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Owner?: UserCreateNestedOneWithoutOrganisationInput
    Assessment?: AssessmentCreateNestedManyWithoutOrganisationInput
    Team?: TeamCreateNestedManyWithoutOrganisationInput
    OrganisationTemplate?: OrganisationTemplateCreateNestedManyWithoutOrganisationInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutAssessmentTeamInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    ownerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutOrganisationInput
    Team?: TeamUncheckedCreateNestedManyWithoutOrganisationInput
    OrganisationTemplate?: OrganisationTemplateUncheckedCreateNestedManyWithoutOrganisationInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutAssessmentTeamInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutAssessmentTeamInput, OrganisationUncheckedCreateWithoutAssessmentTeamInput>
  }

  export type TeamCreateWithoutAssessmentTeamInput = {
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation: OrganisationCreateNestedOneWithoutTeamInput
    OrganisationStructure?: OrganisationStructureCreateNestedManyWithoutTeamInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutAssessmentTeamInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationStructure?: OrganisationStructureUncheckedCreateNestedManyWithoutTeamInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutAssessmentTeamInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutAssessmentTeamInput, TeamUncheckedCreateWithoutAssessmentTeamInput>
  }

  export type QuestionAnswerCreateWithoutAssessmentTeamInput = {
    assessmentStage: string
    questionMongoId: string
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation?: OrganisationCreateNestedOneWithoutQuestionAnswerInput
    OrganisationStructure?: OrganisationStructureCreateNestedOneWithoutQuestionAnswerInput
    Team?: TeamCreateNestedOneWithoutQuestionAnswerInput
    User?: UserCreateNestedOneWithoutQuestionAnswerInput
    Assessment?: AssessmentCreateNestedOneWithoutQuestionAnswerInput
    AssessmentQuestion?: AssessmentQuestionCreateNestedOneWithoutQuestionAnswerInput
  }

  export type QuestionAnswerUncheckedCreateWithoutAssessmentTeamInput = {
    id?: number
    organisationId?: number | null
    organisationStructureId?: number | null
    teamId?: number | null
    userId?: number | null
    assessmentId?: number | null
    assessmentStage: string
    questionMongoId: string
    assessmentQuestionId?: number | null
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerCreateOrConnectWithoutAssessmentTeamInput = {
    where: QuestionAnswerWhereUniqueInput
    create: XOR<QuestionAnswerCreateWithoutAssessmentTeamInput, QuestionAnswerUncheckedCreateWithoutAssessmentTeamInput>
  }

  export type QuestionAnswerCreateManyAssessmentTeamInputEnvelope = {
    data: QuestionAnswerCreateManyAssessmentTeamInput | QuestionAnswerCreateManyAssessmentTeamInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentUpsertWithoutAssessmentTeamInput = {
    update: XOR<AssessmentUpdateWithoutAssessmentTeamInput, AssessmentUncheckedUpdateWithoutAssessmentTeamInput>
    create: XOR<AssessmentCreateWithoutAssessmentTeamInput, AssessmentUncheckedCreateWithoutAssessmentTeamInput>
    where?: AssessmentWhereInput
  }

  export type AssessmentUpdateToOneWithWhereWithoutAssessmentTeamInput = {
    where?: AssessmentWhereInput
    data: XOR<AssessmentUpdateWithoutAssessmentTeamInput, AssessmentUncheckedUpdateWithoutAssessmentTeamInput>
  }

  export type AssessmentUpdateWithoutAssessmentTeamInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneRequiredWithoutAssessmentNestedInput
    AssessmentQuestion?: AssessmentQuestionUpdateManyWithoutAssessmentNestedInput
    OrganisationTemplate?: OrganisationTemplateUpdateOneWithoutAssessmentNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateWithoutAssessmentTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organisationTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    AssessmentQuestion?: AssessmentQuestionUncheckedUpdateManyWithoutAssessmentNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type OrganisationUpsertWithoutAssessmentTeamInput = {
    update: XOR<OrganisationUpdateWithoutAssessmentTeamInput, OrganisationUncheckedUpdateWithoutAssessmentTeamInput>
    create: XOR<OrganisationCreateWithoutAssessmentTeamInput, OrganisationUncheckedCreateWithoutAssessmentTeamInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutAssessmentTeamInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutAssessmentTeamInput, OrganisationUncheckedUpdateWithoutAssessmentTeamInput>
  }

  export type OrganisationUpdateWithoutAssessmentTeamInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Owner?: UserUpdateOneWithoutOrganisationNestedInput
    Assessment?: AssessmentUpdateManyWithoutOrganisationNestedInput
    Team?: TeamUpdateManyWithoutOrganisationNestedInput
    OrganisationTemplate?: OrganisationTemplateUpdateManyWithoutOrganisationNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutAssessmentTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Assessment?: AssessmentUncheckedUpdateManyWithoutOrganisationNestedInput
    Team?: TeamUncheckedUpdateManyWithoutOrganisationNestedInput
    OrganisationTemplate?: OrganisationTemplateUncheckedUpdateManyWithoutOrganisationNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type TeamUpsertWithoutAssessmentTeamInput = {
    update: XOR<TeamUpdateWithoutAssessmentTeamInput, TeamUncheckedUpdateWithoutAssessmentTeamInput>
    create: XOR<TeamCreateWithoutAssessmentTeamInput, TeamUncheckedCreateWithoutAssessmentTeamInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutAssessmentTeamInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutAssessmentTeamInput, TeamUncheckedUpdateWithoutAssessmentTeamInput>
  }

  export type TeamUpdateWithoutAssessmentTeamInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneRequiredWithoutTeamNestedInput
    OrganisationStructure?: OrganisationStructureUpdateManyWithoutTeamNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutAssessmentTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationStructure?: OrganisationStructureUncheckedUpdateManyWithoutTeamNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type QuestionAnswerUpsertWithWhereUniqueWithoutAssessmentTeamInput = {
    where: QuestionAnswerWhereUniqueInput
    update: XOR<QuestionAnswerUpdateWithoutAssessmentTeamInput, QuestionAnswerUncheckedUpdateWithoutAssessmentTeamInput>
    create: XOR<QuestionAnswerCreateWithoutAssessmentTeamInput, QuestionAnswerUncheckedCreateWithoutAssessmentTeamInput>
  }

  export type QuestionAnswerUpdateWithWhereUniqueWithoutAssessmentTeamInput = {
    where: QuestionAnswerWhereUniqueInput
    data: XOR<QuestionAnswerUpdateWithoutAssessmentTeamInput, QuestionAnswerUncheckedUpdateWithoutAssessmentTeamInput>
  }

  export type QuestionAnswerUpdateManyWithWhereWithoutAssessmentTeamInput = {
    where: QuestionAnswerScalarWhereInput
    data: XOR<QuestionAnswerUpdateManyMutationInput, QuestionAnswerUncheckedUpdateManyWithoutAssessmentTeamInput>
  }

  export type UserCreateWithoutOrganisationInput = {
    name: string
    firstName?: string | null
    lastName?: string | null
    email: string
    company?: string | null
    password: string
    rememberToken?: string | null
    logo?: string | null
    isActive?: boolean
    disabled?: boolean
    tfaSecret?: string | null
    fpwToken?: string | null
    qrCodeVisibility?: boolean
    isDureation?: boolean
    tfaStatus?: boolean
    emailVerifiedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    OrganisationStructure?: OrganisationStructureCreateNestedManyWithoutUserInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganisationInput = {
    id?: number
    name: string
    firstName?: string | null
    lastName?: string | null
    email: string
    company?: string | null
    password: string
    rememberToken?: string | null
    logo?: string | null
    isActive?: boolean
    disabled?: boolean
    tfaSecret?: string | null
    fpwToken?: string | null
    qrCodeVisibility?: boolean
    isDureation?: boolean
    tfaStatus?: boolean
    emailVerifiedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    OrganisationStructure?: OrganisationStructureUncheckedCreateNestedManyWithoutUserInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganisationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganisationInput, UserUncheckedCreateWithoutOrganisationInput>
  }

  export type AssessmentCreateWithoutOrganisationInput = {
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AssessmentQuestion?: AssessmentQuestionCreateNestedManyWithoutAssessmentInput
    OrganisationTemplate?: OrganisationTemplateCreateNestedOneWithoutAssessmentInput
    AssessmentTeam?: AssessmentTeamCreateNestedManyWithoutAssessmentInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUncheckedCreateWithoutOrganisationInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organisationTemplateId?: number | null
    AssessmentQuestion?: AssessmentQuestionUncheckedCreateNestedManyWithoutAssessmentInput
    AssessmentTeam?: AssessmentTeamUncheckedCreateNestedManyWithoutAssessmentInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentCreateOrConnectWithoutOrganisationInput = {
    where: AssessmentWhereUniqueInput
    create: XOR<AssessmentCreateWithoutOrganisationInput, AssessmentUncheckedCreateWithoutOrganisationInput>
  }

  export type AssessmentCreateManyOrganisationInputEnvelope = {
    data: AssessmentCreateManyOrganisationInput | AssessmentCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutOrganisationInput = {
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationStructure?: OrganisationStructureCreateNestedManyWithoutTeamInput
    AssessmentTeam?: AssessmentTeamCreateNestedManyWithoutTeamInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutOrganisationInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationStructure?: OrganisationStructureUncheckedCreateNestedManyWithoutTeamInput
    AssessmentTeam?: AssessmentTeamUncheckedCreateNestedManyWithoutTeamInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutOrganisationInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutOrganisationInput, TeamUncheckedCreateWithoutOrganisationInput>
  }

  export type TeamCreateManyOrganisationInputEnvelope = {
    data: TeamCreateManyOrganisationInput | TeamCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationTemplateCreateWithoutOrganisationInput = {
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Template?: TemplateCreateNestedOneWithoutOrganisationTemplateInput
    Assessment?: AssessmentCreateNestedManyWithoutOrganisationTemplateInput
  }

  export type OrganisationTemplateUncheckedCreateWithoutOrganisationInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId: number
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutOrganisationTemplateInput
  }

  export type OrganisationTemplateCreateOrConnectWithoutOrganisationInput = {
    where: OrganisationTemplateWhereUniqueInput
    create: XOR<OrganisationTemplateCreateWithoutOrganisationInput, OrganisationTemplateUncheckedCreateWithoutOrganisationInput>
  }

  export type OrganisationTemplateCreateManyOrganisationInputEnvelope = {
    data: OrganisationTemplateCreateManyOrganisationInput | OrganisationTemplateCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type QuestionAnswerCreateWithoutOrganisationInput = {
    assessmentStage: string
    questionMongoId: string
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationStructure?: OrganisationStructureCreateNestedOneWithoutQuestionAnswerInput
    Team?: TeamCreateNestedOneWithoutQuestionAnswerInput
    User?: UserCreateNestedOneWithoutQuestionAnswerInput
    AssessmentTeam?: AssessmentTeamCreateNestedOneWithoutQuestionAnswerInput
    Assessment?: AssessmentCreateNestedOneWithoutQuestionAnswerInput
    AssessmentQuestion?: AssessmentQuestionCreateNestedOneWithoutQuestionAnswerInput
  }

  export type QuestionAnswerUncheckedCreateWithoutOrganisationInput = {
    id?: number
    organisationStructureId?: number | null
    teamId?: number | null
    userId?: number | null
    assessmentTeamId?: number | null
    assessmentId?: number | null
    assessmentStage: string
    questionMongoId: string
    assessmentQuestionId?: number | null
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerCreateOrConnectWithoutOrganisationInput = {
    where: QuestionAnswerWhereUniqueInput
    create: XOR<QuestionAnswerCreateWithoutOrganisationInput, QuestionAnswerUncheckedCreateWithoutOrganisationInput>
  }

  export type QuestionAnswerCreateManyOrganisationInputEnvelope = {
    data: QuestionAnswerCreateManyOrganisationInput | QuestionAnswerCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentTeamCreateWithoutOrganisationInput = {
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Assessment: AssessmentCreateNestedOneWithoutAssessmentTeamInput
    Team: TeamCreateNestedOneWithoutAssessmentTeamInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutAssessmentTeamInput
  }

  export type AssessmentTeamUncheckedCreateWithoutOrganisationInput = {
    id?: number
    assessmentId: number
    teamId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutAssessmentTeamInput
  }

  export type AssessmentTeamCreateOrConnectWithoutOrganisationInput = {
    where: AssessmentTeamWhereUniqueInput
    create: XOR<AssessmentTeamCreateWithoutOrganisationInput, AssessmentTeamUncheckedCreateWithoutOrganisationInput>
  }

  export type AssessmentTeamCreateManyOrganisationInputEnvelope = {
    data: AssessmentTeamCreateManyOrganisationInput | AssessmentTeamCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrganisationInput = {
    update: XOR<UserUpdateWithoutOrganisationInput, UserUncheckedUpdateWithoutOrganisationInput>
    create: XOR<UserCreateWithoutOrganisationInput, UserUncheckedCreateWithoutOrganisationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrganisationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrganisationInput, UserUncheckedUpdateWithoutOrganisationInput>
  }

  export type UserUpdateWithoutOrganisationInput = {
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    tfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fpwToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeVisibility?: BoolFieldUpdateOperationsInput | boolean
    isDureation?: BoolFieldUpdateOperationsInput | boolean
    tfaStatus?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUpdateManyWithoutUserNestedInput
    OrganisationStructure?: OrganisationStructureUpdateManyWithoutUserNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    tfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fpwToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeVisibility?: BoolFieldUpdateOperationsInput | boolean
    isDureation?: BoolFieldUpdateOperationsInput | boolean
    tfaStatus?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    OrganisationStructure?: OrganisationStructureUncheckedUpdateManyWithoutUserNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AssessmentUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: AssessmentWhereUniqueInput
    update: XOR<AssessmentUpdateWithoutOrganisationInput, AssessmentUncheckedUpdateWithoutOrganisationInput>
    create: XOR<AssessmentCreateWithoutOrganisationInput, AssessmentUncheckedCreateWithoutOrganisationInput>
  }

  export type AssessmentUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: AssessmentWhereUniqueInput
    data: XOR<AssessmentUpdateWithoutOrganisationInput, AssessmentUncheckedUpdateWithoutOrganisationInput>
  }

  export type AssessmentUpdateManyWithWhereWithoutOrganisationInput = {
    where: AssessmentScalarWhereInput
    data: XOR<AssessmentUpdateManyMutationInput, AssessmentUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type AssessmentScalarWhereInput = {
    AND?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
    OR?: AssessmentScalarWhereInput[]
    NOT?: AssessmentScalarWhereInput | AssessmentScalarWhereInput[]
    id?: IntFilter<"Assessment"> | number
    name?: StringFilter<"Assessment"> | string
    description?: StringNullableFilter<"Assessment"> | string | null
    logo?: StringNullableFilter<"Assessment"> | string | null
    organisationId?: IntFilter<"Assessment"> | number
    password?: StringNullableFilter<"Assessment"> | string | null
    rememberToken?: StringNullableFilter<"Assessment"> | string | null
    isActive?: BoolFilter<"Assessment"> | boolean
    secretToken?: StringNullableFilter<"Assessment"> | string | null
    tfaToken?: StringNullableFilter<"Assessment"> | string | null
    createdAt?: DateTimeFilter<"Assessment"> | Date | string
    updatedAt?: DateTimeFilter<"Assessment"> | Date | string
    organisationTemplateId?: IntNullableFilter<"Assessment"> | number | null
  }

  export type TeamUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutOrganisationInput, TeamUncheckedUpdateWithoutOrganisationInput>
    create: XOR<TeamCreateWithoutOrganisationInput, TeamUncheckedCreateWithoutOrganisationInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutOrganisationInput, TeamUncheckedUpdateWithoutOrganisationInput>
  }

  export type TeamUpdateManyWithWhereWithoutOrganisationInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: IntFilter<"Team"> | number
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    logo?: StringNullableFilter<"Team"> | string | null
    organisationId?: IntFilter<"Team"> | number
    password?: StringNullableFilter<"Team"> | string | null
    rememberToken?: StringNullableFilter<"Team"> | string | null
    isActive?: BoolFilter<"Team"> | boolean
    secretToken?: StringNullableFilter<"Team"> | string | null
    tfaToken?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
  }

  export type OrganisationTemplateUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: OrganisationTemplateWhereUniqueInput
    update: XOR<OrganisationTemplateUpdateWithoutOrganisationInput, OrganisationTemplateUncheckedUpdateWithoutOrganisationInput>
    create: XOR<OrganisationTemplateCreateWithoutOrganisationInput, OrganisationTemplateUncheckedCreateWithoutOrganisationInput>
  }

  export type OrganisationTemplateUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: OrganisationTemplateWhereUniqueInput
    data: XOR<OrganisationTemplateUpdateWithoutOrganisationInput, OrganisationTemplateUncheckedUpdateWithoutOrganisationInput>
  }

  export type OrganisationTemplateUpdateManyWithWhereWithoutOrganisationInput = {
    where: OrganisationTemplateScalarWhereInput
    data: XOR<OrganisationTemplateUpdateManyMutationInput, OrganisationTemplateUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type OrganisationTemplateScalarWhereInput = {
    AND?: OrganisationTemplateScalarWhereInput | OrganisationTemplateScalarWhereInput[]
    OR?: OrganisationTemplateScalarWhereInput[]
    NOT?: OrganisationTemplateScalarWhereInput | OrganisationTemplateScalarWhereInput[]
    id?: IntFilter<"OrganisationTemplate"> | number
    name?: StringFilter<"OrganisationTemplate"> | string
    description?: StringNullableFilter<"OrganisationTemplate"> | string | null
    logo?: StringNullableFilter<"OrganisationTemplate"> | string | null
    organisationId?: IntFilter<"OrganisationTemplate"> | number
    password?: StringNullableFilter<"OrganisationTemplate"> | string | null
    rememberToken?: StringNullableFilter<"OrganisationTemplate"> | string | null
    isActive?: BoolFilter<"OrganisationTemplate"> | boolean
    secretToken?: StringNullableFilter<"OrganisationTemplate"> | string | null
    tfaToken?: StringNullableFilter<"OrganisationTemplate"> | string | null
    createdAt?: DateTimeFilter<"OrganisationTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"OrganisationTemplate"> | Date | string
    templateId?: IntFilter<"OrganisationTemplate"> | number
  }

  export type QuestionAnswerUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: QuestionAnswerWhereUniqueInput
    update: XOR<QuestionAnswerUpdateWithoutOrganisationInput, QuestionAnswerUncheckedUpdateWithoutOrganisationInput>
    create: XOR<QuestionAnswerCreateWithoutOrganisationInput, QuestionAnswerUncheckedCreateWithoutOrganisationInput>
  }

  export type QuestionAnswerUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: QuestionAnswerWhereUniqueInput
    data: XOR<QuestionAnswerUpdateWithoutOrganisationInput, QuestionAnswerUncheckedUpdateWithoutOrganisationInput>
  }

  export type QuestionAnswerUpdateManyWithWhereWithoutOrganisationInput = {
    where: QuestionAnswerScalarWhereInput
    data: XOR<QuestionAnswerUpdateManyMutationInput, QuestionAnswerUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type AssessmentTeamUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: AssessmentTeamWhereUniqueInput
    update: XOR<AssessmentTeamUpdateWithoutOrganisationInput, AssessmentTeamUncheckedUpdateWithoutOrganisationInput>
    create: XOR<AssessmentTeamCreateWithoutOrganisationInput, AssessmentTeamUncheckedCreateWithoutOrganisationInput>
  }

  export type AssessmentTeamUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: AssessmentTeamWhereUniqueInput
    data: XOR<AssessmentTeamUpdateWithoutOrganisationInput, AssessmentTeamUncheckedUpdateWithoutOrganisationInput>
  }

  export type AssessmentTeamUpdateManyWithWhereWithoutOrganisationInput = {
    where: AssessmentTeamScalarWhereInput
    data: XOR<AssessmentTeamUpdateManyMutationInput, AssessmentTeamUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type OrganisationStructureCreateWithoutOrganisationRoleInput = {
    organisationId: number
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Team?: TeamCreateNestedOneWithoutOrganisationStructureInput
    User: UserCreateNestedOneWithoutOrganisationStructureInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutOrganisationStructureInput
  }

  export type OrganisationStructureUncheckedCreateWithoutOrganisationRoleInput = {
    id?: number
    organisationId: number
    teamId?: number | null
    userId: number
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutOrganisationStructureInput
  }

  export type OrganisationStructureCreateOrConnectWithoutOrganisationRoleInput = {
    where: OrganisationStructureWhereUniqueInput
    create: XOR<OrganisationStructureCreateWithoutOrganisationRoleInput, OrganisationStructureUncheckedCreateWithoutOrganisationRoleInput>
  }

  export type RoleCreateWithoutOrganisationRoleInput = {
    name: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutOrganisationRoleInput = {
    id?: number
    name: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutOrganisationRoleInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutOrganisationRoleInput, RoleUncheckedCreateWithoutOrganisationRoleInput>
  }

  export type OrganisationStructureUpsertWithoutOrganisationRoleInput = {
    update: XOR<OrganisationStructureUpdateWithoutOrganisationRoleInput, OrganisationStructureUncheckedUpdateWithoutOrganisationRoleInput>
    create: XOR<OrganisationStructureCreateWithoutOrganisationRoleInput, OrganisationStructureUncheckedCreateWithoutOrganisationRoleInput>
    where?: OrganisationStructureWhereInput
  }

  export type OrganisationStructureUpdateToOneWithWhereWithoutOrganisationRoleInput = {
    where?: OrganisationStructureWhereInput
    data: XOR<OrganisationStructureUpdateWithoutOrganisationRoleInput, OrganisationStructureUncheckedUpdateWithoutOrganisationRoleInput>
  }

  export type OrganisationStructureUpdateWithoutOrganisationRoleInput = {
    organisationId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Team?: TeamUpdateOneWithoutOrganisationStructureNestedInput
    User?: UserUpdateOneRequiredWithoutOrganisationStructureNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutOrganisationStructureNestedInput
  }

  export type OrganisationStructureUncheckedUpdateWithoutOrganisationRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutOrganisationStructureNestedInput
  }

  export type RoleUpsertWithoutOrganisationRoleInput = {
    update: XOR<RoleUpdateWithoutOrganisationRoleInput, RoleUncheckedUpdateWithoutOrganisationRoleInput>
    create: XOR<RoleCreateWithoutOrganisationRoleInput, RoleUncheckedCreateWithoutOrganisationRoleInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutOrganisationRoleInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutOrganisationRoleInput, RoleUncheckedUpdateWithoutOrganisationRoleInput>
  }

  export type RoleUpdateWithoutOrganisationRoleInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutOrganisationRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserRole?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type TeamCreateWithoutOrganisationStructureInput = {
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation: OrganisationCreateNestedOneWithoutTeamInput
    AssessmentTeam?: AssessmentTeamCreateNestedManyWithoutTeamInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutOrganisationStructureInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AssessmentTeam?: AssessmentTeamUncheckedCreateNestedManyWithoutTeamInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutOrganisationStructureInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutOrganisationStructureInput, TeamUncheckedCreateWithoutOrganisationStructureInput>
  }

  export type OrganisationRoleCreateWithoutOrganisationStructureInput = {
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Role: RoleCreateNestedOneWithoutOrganisationRoleInput
  }

  export type OrganisationRoleUncheckedCreateWithoutOrganisationStructureInput = {
    id?: number
    isActive?: boolean | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganisationRoleCreateOrConnectWithoutOrganisationStructureInput = {
    where: OrganisationRoleWhereUniqueInput
    create: XOR<OrganisationRoleCreateWithoutOrganisationStructureInput, OrganisationRoleUncheckedCreateWithoutOrganisationStructureInput>
  }

  export type OrganisationRoleCreateManyOrganisationStructureInputEnvelope = {
    data: OrganisationRoleCreateManyOrganisationStructureInput | OrganisationRoleCreateManyOrganisationStructureInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOrganisationStructureInput = {
    name: string
    firstName?: string | null
    lastName?: string | null
    email: string
    company?: string | null
    password: string
    rememberToken?: string | null
    logo?: string | null
    isActive?: boolean
    disabled?: boolean
    tfaSecret?: string | null
    fpwToken?: string | null
    qrCodeVisibility?: boolean
    isDureation?: boolean
    tfaStatus?: boolean
    emailVerifiedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation?: OrganisationCreateNestedOneWithoutOwnerInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganisationStructureInput = {
    id?: number
    name: string
    firstName?: string | null
    lastName?: string | null
    email: string
    company?: string | null
    password: string
    rememberToken?: string | null
    logo?: string | null
    isActive?: boolean
    disabled?: boolean
    tfaSecret?: string | null
    fpwToken?: string | null
    qrCodeVisibility?: boolean
    isDureation?: boolean
    tfaStatus?: boolean
    emailVerifiedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation?: OrganisationUncheckedCreateNestedOneWithoutOwnerInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganisationStructureInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganisationStructureInput, UserUncheckedCreateWithoutOrganisationStructureInput>
  }

  export type QuestionAnswerCreateWithoutOrganisationStructureInput = {
    assessmentStage: string
    questionMongoId: string
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation?: OrganisationCreateNestedOneWithoutQuestionAnswerInput
    Team?: TeamCreateNestedOneWithoutQuestionAnswerInput
    User?: UserCreateNestedOneWithoutQuestionAnswerInput
    AssessmentTeam?: AssessmentTeamCreateNestedOneWithoutQuestionAnswerInput
    Assessment?: AssessmentCreateNestedOneWithoutQuestionAnswerInput
    AssessmentQuestion?: AssessmentQuestionCreateNestedOneWithoutQuestionAnswerInput
  }

  export type QuestionAnswerUncheckedCreateWithoutOrganisationStructureInput = {
    id?: number
    organisationId?: number | null
    teamId?: number | null
    userId?: number | null
    assessmentTeamId?: number | null
    assessmentId?: number | null
    assessmentStage: string
    questionMongoId: string
    assessmentQuestionId?: number | null
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerCreateOrConnectWithoutOrganisationStructureInput = {
    where: QuestionAnswerWhereUniqueInput
    create: XOR<QuestionAnswerCreateWithoutOrganisationStructureInput, QuestionAnswerUncheckedCreateWithoutOrganisationStructureInput>
  }

  export type QuestionAnswerCreateManyOrganisationStructureInputEnvelope = {
    data: QuestionAnswerCreateManyOrganisationStructureInput | QuestionAnswerCreateManyOrganisationStructureInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithoutOrganisationStructureInput = {
    update: XOR<TeamUpdateWithoutOrganisationStructureInput, TeamUncheckedUpdateWithoutOrganisationStructureInput>
    create: XOR<TeamCreateWithoutOrganisationStructureInput, TeamUncheckedCreateWithoutOrganisationStructureInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutOrganisationStructureInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutOrganisationStructureInput, TeamUncheckedUpdateWithoutOrganisationStructureInput>
  }

  export type TeamUpdateWithoutOrganisationStructureInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneRequiredWithoutTeamNestedInput
    AssessmentTeam?: AssessmentTeamUpdateManyWithoutTeamNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutOrganisationStructureInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AssessmentTeam?: AssessmentTeamUncheckedUpdateManyWithoutTeamNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type OrganisationRoleUpsertWithWhereUniqueWithoutOrganisationStructureInput = {
    where: OrganisationRoleWhereUniqueInput
    update: XOR<OrganisationRoleUpdateWithoutOrganisationStructureInput, OrganisationRoleUncheckedUpdateWithoutOrganisationStructureInput>
    create: XOR<OrganisationRoleCreateWithoutOrganisationStructureInput, OrganisationRoleUncheckedCreateWithoutOrganisationStructureInput>
  }

  export type OrganisationRoleUpdateWithWhereUniqueWithoutOrganisationStructureInput = {
    where: OrganisationRoleWhereUniqueInput
    data: XOR<OrganisationRoleUpdateWithoutOrganisationStructureInput, OrganisationRoleUncheckedUpdateWithoutOrganisationStructureInput>
  }

  export type OrganisationRoleUpdateManyWithWhereWithoutOrganisationStructureInput = {
    where: OrganisationRoleScalarWhereInput
    data: XOR<OrganisationRoleUpdateManyMutationInput, OrganisationRoleUncheckedUpdateManyWithoutOrganisationStructureInput>
  }

  export type OrganisationRoleScalarWhereInput = {
    AND?: OrganisationRoleScalarWhereInput | OrganisationRoleScalarWhereInput[]
    OR?: OrganisationRoleScalarWhereInput[]
    NOT?: OrganisationRoleScalarWhereInput | OrganisationRoleScalarWhereInput[]
    id?: IntFilter<"OrganisationRole"> | number
    isActive?: BoolNullableFilter<"OrganisationRole"> | boolean | null
    organisationStructureId?: IntFilter<"OrganisationRole"> | number
    roleId?: IntFilter<"OrganisationRole"> | number
    createdAt?: DateTimeFilter<"OrganisationRole"> | Date | string
    updatedAt?: DateTimeFilter<"OrganisationRole"> | Date | string
  }

  export type UserUpsertWithoutOrganisationStructureInput = {
    update: XOR<UserUpdateWithoutOrganisationStructureInput, UserUncheckedUpdateWithoutOrganisationStructureInput>
    create: XOR<UserCreateWithoutOrganisationStructureInput, UserUncheckedCreateWithoutOrganisationStructureInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrganisationStructureInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrganisationStructureInput, UserUncheckedUpdateWithoutOrganisationStructureInput>
  }

  export type UserUpdateWithoutOrganisationStructureInput = {
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    tfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fpwToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeVisibility?: BoolFieldUpdateOperationsInput | boolean
    isDureation?: BoolFieldUpdateOperationsInput | boolean
    tfaStatus?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneWithoutOwnerNestedInput
    UserRole?: UserRoleUpdateManyWithoutUserNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganisationStructureInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    tfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fpwToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeVisibility?: BoolFieldUpdateOperationsInput | boolean
    isDureation?: BoolFieldUpdateOperationsInput | boolean
    tfaStatus?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUncheckedUpdateOneWithoutOwnerNestedInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QuestionAnswerUpsertWithWhereUniqueWithoutOrganisationStructureInput = {
    where: QuestionAnswerWhereUniqueInput
    update: XOR<QuestionAnswerUpdateWithoutOrganisationStructureInput, QuestionAnswerUncheckedUpdateWithoutOrganisationStructureInput>
    create: XOR<QuestionAnswerCreateWithoutOrganisationStructureInput, QuestionAnswerUncheckedCreateWithoutOrganisationStructureInput>
  }

  export type QuestionAnswerUpdateWithWhereUniqueWithoutOrganisationStructureInput = {
    where: QuestionAnswerWhereUniqueInput
    data: XOR<QuestionAnswerUpdateWithoutOrganisationStructureInput, QuestionAnswerUncheckedUpdateWithoutOrganisationStructureInput>
  }

  export type QuestionAnswerUpdateManyWithWhereWithoutOrganisationStructureInput = {
    where: QuestionAnswerScalarWhereInput
    data: XOR<QuestionAnswerUpdateManyMutationInput, QuestionAnswerUncheckedUpdateManyWithoutOrganisationStructureInput>
  }

  export type OrganisationCreateWithoutOrganisationTemplateInput = {
    name: string
    description?: string | null
    isActive?: boolean | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Owner?: UserCreateNestedOneWithoutOrganisationInput
    Assessment?: AssessmentCreateNestedManyWithoutOrganisationInput
    Team?: TeamCreateNestedManyWithoutOrganisationInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutOrganisationInput
    AssessmentTeam?: AssessmentTeamCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutOrganisationTemplateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    ownerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutOrganisationInput
    Team?: TeamUncheckedCreateNestedManyWithoutOrganisationInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutOrganisationInput
    AssessmentTeam?: AssessmentTeamUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutOrganisationTemplateInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutOrganisationTemplateInput, OrganisationUncheckedCreateWithoutOrganisationTemplateInput>
  }

  export type TemplateCreateWithoutOrganisationTemplateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    TemplateStage?: TemplateStageCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUncheckedCreateWithoutOrganisationTemplateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    TemplateStage?: TemplateStageUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type TemplateCreateOrConnectWithoutOrganisationTemplateInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutOrganisationTemplateInput, TemplateUncheckedCreateWithoutOrganisationTemplateInput>
  }

  export type AssessmentCreateWithoutOrganisationTemplateInput = {
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation: OrganisationCreateNestedOneWithoutAssessmentInput
    AssessmentQuestion?: AssessmentQuestionCreateNestedManyWithoutAssessmentInput
    AssessmentTeam?: AssessmentTeamCreateNestedManyWithoutAssessmentInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUncheckedCreateWithoutOrganisationTemplateInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AssessmentQuestion?: AssessmentQuestionUncheckedCreateNestedManyWithoutAssessmentInput
    AssessmentTeam?: AssessmentTeamUncheckedCreateNestedManyWithoutAssessmentInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentCreateOrConnectWithoutOrganisationTemplateInput = {
    where: AssessmentWhereUniqueInput
    create: XOR<AssessmentCreateWithoutOrganisationTemplateInput, AssessmentUncheckedCreateWithoutOrganisationTemplateInput>
  }

  export type AssessmentCreateManyOrganisationTemplateInputEnvelope = {
    data: AssessmentCreateManyOrganisationTemplateInput | AssessmentCreateManyOrganisationTemplateInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationUpsertWithoutOrganisationTemplateInput = {
    update: XOR<OrganisationUpdateWithoutOrganisationTemplateInput, OrganisationUncheckedUpdateWithoutOrganisationTemplateInput>
    create: XOR<OrganisationCreateWithoutOrganisationTemplateInput, OrganisationUncheckedCreateWithoutOrganisationTemplateInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutOrganisationTemplateInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutOrganisationTemplateInput, OrganisationUncheckedUpdateWithoutOrganisationTemplateInput>
  }

  export type OrganisationUpdateWithoutOrganisationTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Owner?: UserUpdateOneWithoutOrganisationNestedInput
    Assessment?: AssessmentUpdateManyWithoutOrganisationNestedInput
    Team?: TeamUpdateManyWithoutOrganisationNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutOrganisationNestedInput
    AssessmentTeam?: AssessmentTeamUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutOrganisationTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Assessment?: AssessmentUncheckedUpdateManyWithoutOrganisationNestedInput
    Team?: TeamUncheckedUpdateManyWithoutOrganisationNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutOrganisationNestedInput
    AssessmentTeam?: AssessmentTeamUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type TemplateUpsertWithoutOrganisationTemplateInput = {
    update: XOR<TemplateUpdateWithoutOrganisationTemplateInput, TemplateUncheckedUpdateWithoutOrganisationTemplateInput>
    create: XOR<TemplateCreateWithoutOrganisationTemplateInput, TemplateUncheckedCreateWithoutOrganisationTemplateInput>
    where?: TemplateWhereInput
  }

  export type TemplateUpdateToOneWithWhereWithoutOrganisationTemplateInput = {
    where?: TemplateWhereInput
    data: XOR<TemplateUpdateWithoutOrganisationTemplateInput, TemplateUncheckedUpdateWithoutOrganisationTemplateInput>
  }

  export type TemplateUpdateWithoutOrganisationTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TemplateStage?: TemplateStageUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateUncheckedUpdateWithoutOrganisationTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TemplateStage?: TemplateStageUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type AssessmentUpsertWithWhereUniqueWithoutOrganisationTemplateInput = {
    where: AssessmentWhereUniqueInput
    update: XOR<AssessmentUpdateWithoutOrganisationTemplateInput, AssessmentUncheckedUpdateWithoutOrganisationTemplateInput>
    create: XOR<AssessmentCreateWithoutOrganisationTemplateInput, AssessmentUncheckedCreateWithoutOrganisationTemplateInput>
  }

  export type AssessmentUpdateWithWhereUniqueWithoutOrganisationTemplateInput = {
    where: AssessmentWhereUniqueInput
    data: XOR<AssessmentUpdateWithoutOrganisationTemplateInput, AssessmentUncheckedUpdateWithoutOrganisationTemplateInput>
  }

  export type AssessmentUpdateManyWithWhereWithoutOrganisationTemplateInput = {
    where: AssessmentScalarWhereInput
    data: XOR<AssessmentUpdateManyMutationInput, AssessmentUncheckedUpdateManyWithoutOrganisationTemplateInput>
  }

  export type OrganisationCreateWithoutQuestionAnswerInput = {
    name: string
    description?: string | null
    isActive?: boolean | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Owner?: UserCreateNestedOneWithoutOrganisationInput
    Assessment?: AssessmentCreateNestedManyWithoutOrganisationInput
    Team?: TeamCreateNestedManyWithoutOrganisationInput
    OrganisationTemplate?: OrganisationTemplateCreateNestedManyWithoutOrganisationInput
    AssessmentTeam?: AssessmentTeamCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutQuestionAnswerInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    ownerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutOrganisationInput
    Team?: TeamUncheckedCreateNestedManyWithoutOrganisationInput
    OrganisationTemplate?: OrganisationTemplateUncheckedCreateNestedManyWithoutOrganisationInput
    AssessmentTeam?: AssessmentTeamUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutQuestionAnswerInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutQuestionAnswerInput, OrganisationUncheckedCreateWithoutQuestionAnswerInput>
  }

  export type OrganisationStructureCreateWithoutQuestionAnswerInput = {
    organisationId: number
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Team?: TeamCreateNestedOneWithoutOrganisationStructureInput
    OrganisationRole?: OrganisationRoleCreateNestedManyWithoutOrganisationStructureInput
    User: UserCreateNestedOneWithoutOrganisationStructureInput
  }

  export type OrganisationStructureUncheckedCreateWithoutQuestionAnswerInput = {
    id?: number
    organisationId: number
    teamId?: number | null
    userId: number
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationRole?: OrganisationRoleUncheckedCreateNestedManyWithoutOrganisationStructureInput
  }

  export type OrganisationStructureCreateOrConnectWithoutQuestionAnswerInput = {
    where: OrganisationStructureWhereUniqueInput
    create: XOR<OrganisationStructureCreateWithoutQuestionAnswerInput, OrganisationStructureUncheckedCreateWithoutQuestionAnswerInput>
  }

  export type TeamCreateWithoutQuestionAnswerInput = {
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation: OrganisationCreateNestedOneWithoutTeamInput
    OrganisationStructure?: OrganisationStructureCreateNestedManyWithoutTeamInput
    AssessmentTeam?: AssessmentTeamCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutQuestionAnswerInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationStructure?: OrganisationStructureUncheckedCreateNestedManyWithoutTeamInput
    AssessmentTeam?: AssessmentTeamUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutQuestionAnswerInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutQuestionAnswerInput, TeamUncheckedCreateWithoutQuestionAnswerInput>
  }

  export type UserCreateWithoutQuestionAnswerInput = {
    name: string
    firstName?: string | null
    lastName?: string | null
    email: string
    company?: string | null
    password: string
    rememberToken?: string | null
    logo?: string | null
    isActive?: boolean
    disabled?: boolean
    tfaSecret?: string | null
    fpwToken?: string | null
    qrCodeVisibility?: boolean
    isDureation?: boolean
    tfaStatus?: boolean
    emailVerifiedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation?: OrganisationCreateNestedOneWithoutOwnerInput
    UserRole?: UserRoleCreateNestedManyWithoutUserInput
    OrganisationStructure?: OrganisationStructureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuestionAnswerInput = {
    id?: number
    name: string
    firstName?: string | null
    lastName?: string | null
    email: string
    company?: string | null
    password: string
    rememberToken?: string | null
    logo?: string | null
    isActive?: boolean
    disabled?: boolean
    tfaSecret?: string | null
    fpwToken?: string | null
    qrCodeVisibility?: boolean
    isDureation?: boolean
    tfaStatus?: boolean
    emailVerifiedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation?: OrganisationUncheckedCreateNestedOneWithoutOwnerInput
    UserRole?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    OrganisationStructure?: OrganisationStructureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuestionAnswerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionAnswerInput, UserUncheckedCreateWithoutQuestionAnswerInput>
  }

  export type AssessmentTeamCreateWithoutQuestionAnswerInput = {
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Assessment: AssessmentCreateNestedOneWithoutAssessmentTeamInput
    Organisation: OrganisationCreateNestedOneWithoutAssessmentTeamInput
    Team: TeamCreateNestedOneWithoutAssessmentTeamInput
  }

  export type AssessmentTeamUncheckedCreateWithoutQuestionAnswerInput = {
    id?: number
    assessmentId: number
    organisationId: number
    teamId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentTeamCreateOrConnectWithoutQuestionAnswerInput = {
    where: AssessmentTeamWhereUniqueInput
    create: XOR<AssessmentTeamCreateWithoutQuestionAnswerInput, AssessmentTeamUncheckedCreateWithoutQuestionAnswerInput>
  }

  export type AssessmentCreateWithoutQuestionAnswerInput = {
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation: OrganisationCreateNestedOneWithoutAssessmentInput
    AssessmentQuestion?: AssessmentQuestionCreateNestedManyWithoutAssessmentInput
    OrganisationTemplate?: OrganisationTemplateCreateNestedOneWithoutAssessmentInput
    AssessmentTeam?: AssessmentTeamCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentUncheckedCreateWithoutQuestionAnswerInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organisationTemplateId?: number | null
    AssessmentQuestion?: AssessmentQuestionUncheckedCreateNestedManyWithoutAssessmentInput
    AssessmentTeam?: AssessmentTeamUncheckedCreateNestedManyWithoutAssessmentInput
  }

  export type AssessmentCreateOrConnectWithoutQuestionAnswerInput = {
    where: AssessmentWhereUniqueInput
    create: XOR<AssessmentCreateWithoutQuestionAnswerInput, AssessmentUncheckedCreateWithoutQuestionAnswerInput>
  }

  export type AssessmentQuestionCreateWithoutQuestionAnswerInput = {
    assessmentStage: string
    questionMongoId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Assessment: AssessmentCreateNestedOneWithoutAssessmentQuestionInput
  }

  export type AssessmentQuestionUncheckedCreateWithoutQuestionAnswerInput = {
    id?: number
    assessmentId: number
    assessmentStage: string
    questionMongoId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentQuestionCreateOrConnectWithoutQuestionAnswerInput = {
    where: AssessmentQuestionWhereUniqueInput
    create: XOR<AssessmentQuestionCreateWithoutQuestionAnswerInput, AssessmentQuestionUncheckedCreateWithoutQuestionAnswerInput>
  }

  export type OrganisationUpsertWithoutQuestionAnswerInput = {
    update: XOR<OrganisationUpdateWithoutQuestionAnswerInput, OrganisationUncheckedUpdateWithoutQuestionAnswerInput>
    create: XOR<OrganisationCreateWithoutQuestionAnswerInput, OrganisationUncheckedCreateWithoutQuestionAnswerInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutQuestionAnswerInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutQuestionAnswerInput, OrganisationUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type OrganisationUpdateWithoutQuestionAnswerInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Owner?: UserUpdateOneWithoutOrganisationNestedInput
    Assessment?: AssessmentUpdateManyWithoutOrganisationNestedInput
    Team?: TeamUpdateManyWithoutOrganisationNestedInput
    OrganisationTemplate?: OrganisationTemplateUpdateManyWithoutOrganisationNestedInput
    AssessmentTeam?: AssessmentTeamUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutQuestionAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Assessment?: AssessmentUncheckedUpdateManyWithoutOrganisationNestedInput
    Team?: TeamUncheckedUpdateManyWithoutOrganisationNestedInput
    OrganisationTemplate?: OrganisationTemplateUncheckedUpdateManyWithoutOrganisationNestedInput
    AssessmentTeam?: AssessmentTeamUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationStructureUpsertWithoutQuestionAnswerInput = {
    update: XOR<OrganisationStructureUpdateWithoutQuestionAnswerInput, OrganisationStructureUncheckedUpdateWithoutQuestionAnswerInput>
    create: XOR<OrganisationStructureCreateWithoutQuestionAnswerInput, OrganisationStructureUncheckedCreateWithoutQuestionAnswerInput>
    where?: OrganisationStructureWhereInput
  }

  export type OrganisationStructureUpdateToOneWithWhereWithoutQuestionAnswerInput = {
    where?: OrganisationStructureWhereInput
    data: XOR<OrganisationStructureUpdateWithoutQuestionAnswerInput, OrganisationStructureUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type OrganisationStructureUpdateWithoutQuestionAnswerInput = {
    organisationId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Team?: TeamUpdateOneWithoutOrganisationStructureNestedInput
    OrganisationRole?: OrganisationRoleUpdateManyWithoutOrganisationStructureNestedInput
    User?: UserUpdateOneRequiredWithoutOrganisationStructureNestedInput
  }

  export type OrganisationStructureUncheckedUpdateWithoutQuestionAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationRole?: OrganisationRoleUncheckedUpdateManyWithoutOrganisationStructureNestedInput
  }

  export type TeamUpsertWithoutQuestionAnswerInput = {
    update: XOR<TeamUpdateWithoutQuestionAnswerInput, TeamUncheckedUpdateWithoutQuestionAnswerInput>
    create: XOR<TeamCreateWithoutQuestionAnswerInput, TeamUncheckedCreateWithoutQuestionAnswerInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutQuestionAnswerInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutQuestionAnswerInput, TeamUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type TeamUpdateWithoutQuestionAnswerInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneRequiredWithoutTeamNestedInput
    OrganisationStructure?: OrganisationStructureUpdateManyWithoutTeamNestedInput
    AssessmentTeam?: AssessmentTeamUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutQuestionAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationStructure?: OrganisationStructureUncheckedUpdateManyWithoutTeamNestedInput
    AssessmentTeam?: AssessmentTeamUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutQuestionAnswerInput = {
    update: XOR<UserUpdateWithoutQuestionAnswerInput, UserUncheckedUpdateWithoutQuestionAnswerInput>
    create: XOR<UserCreateWithoutQuestionAnswerInput, UserUncheckedCreateWithoutQuestionAnswerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuestionAnswerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuestionAnswerInput, UserUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type UserUpdateWithoutQuestionAnswerInput = {
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    tfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fpwToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeVisibility?: BoolFieldUpdateOperationsInput | boolean
    isDureation?: BoolFieldUpdateOperationsInput | boolean
    tfaStatus?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneWithoutOwnerNestedInput
    UserRole?: UserRoleUpdateManyWithoutUserNestedInput
    OrganisationStructure?: OrganisationStructureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    tfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fpwToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeVisibility?: BoolFieldUpdateOperationsInput | boolean
    isDureation?: BoolFieldUpdateOperationsInput | boolean
    tfaStatus?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUncheckedUpdateOneWithoutOwnerNestedInput
    UserRole?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    OrganisationStructure?: OrganisationStructureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AssessmentTeamUpsertWithoutQuestionAnswerInput = {
    update: XOR<AssessmentTeamUpdateWithoutQuestionAnswerInput, AssessmentTeamUncheckedUpdateWithoutQuestionAnswerInput>
    create: XOR<AssessmentTeamCreateWithoutQuestionAnswerInput, AssessmentTeamUncheckedCreateWithoutQuestionAnswerInput>
    where?: AssessmentTeamWhereInput
  }

  export type AssessmentTeamUpdateToOneWithWhereWithoutQuestionAnswerInput = {
    where?: AssessmentTeamWhereInput
    data: XOR<AssessmentTeamUpdateWithoutQuestionAnswerInput, AssessmentTeamUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type AssessmentTeamUpdateWithoutQuestionAnswerInput = {
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Assessment?: AssessmentUpdateOneRequiredWithoutAssessmentTeamNestedInput
    Organisation?: OrganisationUpdateOneRequiredWithoutAssessmentTeamNestedInput
    Team?: TeamUpdateOneRequiredWithoutAssessmentTeamNestedInput
  }

  export type AssessmentTeamUncheckedUpdateWithoutQuestionAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentUpsertWithoutQuestionAnswerInput = {
    update: XOR<AssessmentUpdateWithoutQuestionAnswerInput, AssessmentUncheckedUpdateWithoutQuestionAnswerInput>
    create: XOR<AssessmentCreateWithoutQuestionAnswerInput, AssessmentUncheckedCreateWithoutQuestionAnswerInput>
    where?: AssessmentWhereInput
  }

  export type AssessmentUpdateToOneWithWhereWithoutQuestionAnswerInput = {
    where?: AssessmentWhereInput
    data: XOR<AssessmentUpdateWithoutQuestionAnswerInput, AssessmentUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type AssessmentUpdateWithoutQuestionAnswerInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneRequiredWithoutAssessmentNestedInput
    AssessmentQuestion?: AssessmentQuestionUpdateManyWithoutAssessmentNestedInput
    OrganisationTemplate?: OrganisationTemplateUpdateOneWithoutAssessmentNestedInput
    AssessmentTeam?: AssessmentTeamUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateWithoutQuestionAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organisationTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    AssessmentQuestion?: AssessmentQuestionUncheckedUpdateManyWithoutAssessmentNestedInput
    AssessmentTeam?: AssessmentTeamUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentQuestionUpsertWithoutQuestionAnswerInput = {
    update: XOR<AssessmentQuestionUpdateWithoutQuestionAnswerInput, AssessmentQuestionUncheckedUpdateWithoutQuestionAnswerInput>
    create: XOR<AssessmentQuestionCreateWithoutQuestionAnswerInput, AssessmentQuestionUncheckedCreateWithoutQuestionAnswerInput>
    where?: AssessmentQuestionWhereInput
  }

  export type AssessmentQuestionUpdateToOneWithWhereWithoutQuestionAnswerInput = {
    where?: AssessmentQuestionWhereInput
    data: XOR<AssessmentQuestionUpdateWithoutQuestionAnswerInput, AssessmentQuestionUncheckedUpdateWithoutQuestionAnswerInput>
  }

  export type AssessmentQuestionUpdateWithoutQuestionAnswerInput = {
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Assessment?: AssessmentUpdateOneRequiredWithoutAssessmentQuestionNestedInput
  }

  export type AssessmentQuestionUncheckedUpdateWithoutQuestionAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateWithoutRoleInput = {
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutUserRoleInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: number
    userId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationRoleCreateWithoutRoleInput = {
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationStructure: OrganisationStructureCreateNestedOneWithoutOrganisationRoleInput
  }

  export type OrganisationRoleUncheckedCreateWithoutRoleInput = {
    id?: number
    isActive?: boolean | null
    organisationStructureId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganisationRoleCreateOrConnectWithoutRoleInput = {
    where: OrganisationRoleWhereUniqueInput
    create: XOR<OrganisationRoleCreateWithoutRoleInput, OrganisationRoleUncheckedCreateWithoutRoleInput>
  }

  export type OrganisationRoleCreateManyRoleInputEnvelope = {
    data: OrganisationRoleCreateManyRoleInput | OrganisationRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: IntFilter<"UserRole"> | number
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    isActive?: BoolFilter<"UserRole"> | boolean
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
    updatedAt?: DateTimeFilter<"UserRole"> | Date | string
  }

  export type OrganisationRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: OrganisationRoleWhereUniqueInput
    update: XOR<OrganisationRoleUpdateWithoutRoleInput, OrganisationRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<OrganisationRoleCreateWithoutRoleInput, OrganisationRoleUncheckedCreateWithoutRoleInput>
  }

  export type OrganisationRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: OrganisationRoleWhereUniqueInput
    data: XOR<OrganisationRoleUpdateWithoutRoleInput, OrganisationRoleUncheckedUpdateWithoutRoleInput>
  }

  export type OrganisationRoleUpdateManyWithWhereWithoutRoleInput = {
    where: OrganisationRoleScalarWhereInput
    data: XOR<OrganisationRoleUpdateManyMutationInput, OrganisationRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type OrganisationCreateWithoutTeamInput = {
    name: string
    description?: string | null
    isActive?: boolean | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Owner?: UserCreateNestedOneWithoutOrganisationInput
    Assessment?: AssessmentCreateNestedManyWithoutOrganisationInput
    OrganisationTemplate?: OrganisationTemplateCreateNestedManyWithoutOrganisationInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutOrganisationInput
    AssessmentTeam?: AssessmentTeamCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutTeamInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    ownerId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutOrganisationInput
    OrganisationTemplate?: OrganisationTemplateUncheckedCreateNestedManyWithoutOrganisationInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutOrganisationInput
    AssessmentTeam?: AssessmentTeamUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutTeamInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutTeamInput, OrganisationUncheckedCreateWithoutTeamInput>
  }

  export type OrganisationStructureCreateWithoutTeamInput = {
    organisationId: number
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationRole?: OrganisationRoleCreateNestedManyWithoutOrganisationStructureInput
    User: UserCreateNestedOneWithoutOrganisationStructureInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutOrganisationStructureInput
  }

  export type OrganisationStructureUncheckedCreateWithoutTeamInput = {
    id?: number
    organisationId: number
    userId: number
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationRole?: OrganisationRoleUncheckedCreateNestedManyWithoutOrganisationStructureInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutOrganisationStructureInput
  }

  export type OrganisationStructureCreateOrConnectWithoutTeamInput = {
    where: OrganisationStructureWhereUniqueInput
    create: XOR<OrganisationStructureCreateWithoutTeamInput, OrganisationStructureUncheckedCreateWithoutTeamInput>
  }

  export type OrganisationStructureCreateManyTeamInputEnvelope = {
    data: OrganisationStructureCreateManyTeamInput | OrganisationStructureCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentTeamCreateWithoutTeamInput = {
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Assessment: AssessmentCreateNestedOneWithoutAssessmentTeamInput
    Organisation: OrganisationCreateNestedOneWithoutAssessmentTeamInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutAssessmentTeamInput
  }

  export type AssessmentTeamUncheckedCreateWithoutTeamInput = {
    id?: number
    assessmentId: number
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutAssessmentTeamInput
  }

  export type AssessmentTeamCreateOrConnectWithoutTeamInput = {
    where: AssessmentTeamWhereUniqueInput
    create: XOR<AssessmentTeamCreateWithoutTeamInput, AssessmentTeamUncheckedCreateWithoutTeamInput>
  }

  export type AssessmentTeamCreateManyTeamInputEnvelope = {
    data: AssessmentTeamCreateManyTeamInput | AssessmentTeamCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type QuestionAnswerCreateWithoutTeamInput = {
    assessmentStage: string
    questionMongoId: string
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation?: OrganisationCreateNestedOneWithoutQuestionAnswerInput
    OrganisationStructure?: OrganisationStructureCreateNestedOneWithoutQuestionAnswerInput
    User?: UserCreateNestedOneWithoutQuestionAnswerInput
    AssessmentTeam?: AssessmentTeamCreateNestedOneWithoutQuestionAnswerInput
    Assessment?: AssessmentCreateNestedOneWithoutQuestionAnswerInput
    AssessmentQuestion?: AssessmentQuestionCreateNestedOneWithoutQuestionAnswerInput
  }

  export type QuestionAnswerUncheckedCreateWithoutTeamInput = {
    id?: number
    organisationId?: number | null
    organisationStructureId?: number | null
    userId?: number | null
    assessmentTeamId?: number | null
    assessmentId?: number | null
    assessmentStage: string
    questionMongoId: string
    assessmentQuestionId?: number | null
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerCreateOrConnectWithoutTeamInput = {
    where: QuestionAnswerWhereUniqueInput
    create: XOR<QuestionAnswerCreateWithoutTeamInput, QuestionAnswerUncheckedCreateWithoutTeamInput>
  }

  export type QuestionAnswerCreateManyTeamInputEnvelope = {
    data: QuestionAnswerCreateManyTeamInput | QuestionAnswerCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationUpsertWithoutTeamInput = {
    update: XOR<OrganisationUpdateWithoutTeamInput, OrganisationUncheckedUpdateWithoutTeamInput>
    create: XOR<OrganisationCreateWithoutTeamInput, OrganisationUncheckedCreateWithoutTeamInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutTeamInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutTeamInput, OrganisationUncheckedUpdateWithoutTeamInput>
  }

  export type OrganisationUpdateWithoutTeamInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Owner?: UserUpdateOneWithoutOrganisationNestedInput
    Assessment?: AssessmentUpdateManyWithoutOrganisationNestedInput
    OrganisationTemplate?: OrganisationTemplateUpdateManyWithoutOrganisationNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutOrganisationNestedInput
    AssessmentTeam?: AssessmentTeamUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Assessment?: AssessmentUncheckedUpdateManyWithoutOrganisationNestedInput
    OrganisationTemplate?: OrganisationTemplateUncheckedUpdateManyWithoutOrganisationNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutOrganisationNestedInput
    AssessmentTeam?: AssessmentTeamUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationStructureUpsertWithWhereUniqueWithoutTeamInput = {
    where: OrganisationStructureWhereUniqueInput
    update: XOR<OrganisationStructureUpdateWithoutTeamInput, OrganisationStructureUncheckedUpdateWithoutTeamInput>
    create: XOR<OrganisationStructureCreateWithoutTeamInput, OrganisationStructureUncheckedCreateWithoutTeamInput>
  }

  export type OrganisationStructureUpdateWithWhereUniqueWithoutTeamInput = {
    where: OrganisationStructureWhereUniqueInput
    data: XOR<OrganisationStructureUpdateWithoutTeamInput, OrganisationStructureUncheckedUpdateWithoutTeamInput>
  }

  export type OrganisationStructureUpdateManyWithWhereWithoutTeamInput = {
    where: OrganisationStructureScalarWhereInput
    data: XOR<OrganisationStructureUpdateManyMutationInput, OrganisationStructureUncheckedUpdateManyWithoutTeamInput>
  }

  export type OrganisationStructureScalarWhereInput = {
    AND?: OrganisationStructureScalarWhereInput | OrganisationStructureScalarWhereInput[]
    OR?: OrganisationStructureScalarWhereInput[]
    NOT?: OrganisationStructureScalarWhereInput | OrganisationStructureScalarWhereInput[]
    id?: IntFilter<"OrganisationStructure"> | number
    organisationId?: IntFilter<"OrganisationStructure"> | number
    teamId?: IntNullableFilter<"OrganisationStructure"> | number | null
    userId?: IntFilter<"OrganisationStructure"> | number
    isActive?: BoolNullableFilter<"OrganisationStructure"> | boolean | null
    createdAt?: DateTimeFilter<"OrganisationStructure"> | Date | string
    updatedAt?: DateTimeFilter<"OrganisationStructure"> | Date | string
  }

  export type AssessmentTeamUpsertWithWhereUniqueWithoutTeamInput = {
    where: AssessmentTeamWhereUniqueInput
    update: XOR<AssessmentTeamUpdateWithoutTeamInput, AssessmentTeamUncheckedUpdateWithoutTeamInput>
    create: XOR<AssessmentTeamCreateWithoutTeamInput, AssessmentTeamUncheckedCreateWithoutTeamInput>
  }

  export type AssessmentTeamUpdateWithWhereUniqueWithoutTeamInput = {
    where: AssessmentTeamWhereUniqueInput
    data: XOR<AssessmentTeamUpdateWithoutTeamInput, AssessmentTeamUncheckedUpdateWithoutTeamInput>
  }

  export type AssessmentTeamUpdateManyWithWhereWithoutTeamInput = {
    where: AssessmentTeamScalarWhereInput
    data: XOR<AssessmentTeamUpdateManyMutationInput, AssessmentTeamUncheckedUpdateManyWithoutTeamInput>
  }

  export type QuestionAnswerUpsertWithWhereUniqueWithoutTeamInput = {
    where: QuestionAnswerWhereUniqueInput
    update: XOR<QuestionAnswerUpdateWithoutTeamInput, QuestionAnswerUncheckedUpdateWithoutTeamInput>
    create: XOR<QuestionAnswerCreateWithoutTeamInput, QuestionAnswerUncheckedCreateWithoutTeamInput>
  }

  export type QuestionAnswerUpdateWithWhereUniqueWithoutTeamInput = {
    where: QuestionAnswerWhereUniqueInput
    data: XOR<QuestionAnswerUpdateWithoutTeamInput, QuestionAnswerUncheckedUpdateWithoutTeamInput>
  }

  export type QuestionAnswerUpdateManyWithWhereWithoutTeamInput = {
    where: QuestionAnswerScalarWhereInput
    data: XOR<QuestionAnswerUpdateManyMutationInput, QuestionAnswerUncheckedUpdateManyWithoutTeamInput>
  }

  export type TemplateStageCreateWithoutTemplateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    TemplateQuestion?: TemplateQuestionCreateNestedManyWithoutTemplateStageInput
  }

  export type TemplateStageUncheckedCreateWithoutTemplateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    TemplateQuestion?: TemplateQuestionUncheckedCreateNestedManyWithoutTemplateStageInput
  }

  export type TemplateStageCreateOrConnectWithoutTemplateInput = {
    where: TemplateStageWhereUniqueInput
    create: XOR<TemplateStageCreateWithoutTemplateInput, TemplateStageUncheckedCreateWithoutTemplateInput>
  }

  export type TemplateStageCreateManyTemplateInputEnvelope = {
    data: TemplateStageCreateManyTemplateInput | TemplateStageCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationTemplateCreateWithoutTemplateInput = {
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation: OrganisationCreateNestedOneWithoutOrganisationTemplateInput
    Assessment?: AssessmentCreateNestedManyWithoutOrganisationTemplateInput
  }

  export type OrganisationTemplateUncheckedCreateWithoutTemplateInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutOrganisationTemplateInput
  }

  export type OrganisationTemplateCreateOrConnectWithoutTemplateInput = {
    where: OrganisationTemplateWhereUniqueInput
    create: XOR<OrganisationTemplateCreateWithoutTemplateInput, OrganisationTemplateUncheckedCreateWithoutTemplateInput>
  }

  export type OrganisationTemplateCreateManyTemplateInputEnvelope = {
    data: OrganisationTemplateCreateManyTemplateInput | OrganisationTemplateCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type TemplateStageUpsertWithWhereUniqueWithoutTemplateInput = {
    where: TemplateStageWhereUniqueInput
    update: XOR<TemplateStageUpdateWithoutTemplateInput, TemplateStageUncheckedUpdateWithoutTemplateInput>
    create: XOR<TemplateStageCreateWithoutTemplateInput, TemplateStageUncheckedCreateWithoutTemplateInput>
  }

  export type TemplateStageUpdateWithWhereUniqueWithoutTemplateInput = {
    where: TemplateStageWhereUniqueInput
    data: XOR<TemplateStageUpdateWithoutTemplateInput, TemplateStageUncheckedUpdateWithoutTemplateInput>
  }

  export type TemplateStageUpdateManyWithWhereWithoutTemplateInput = {
    where: TemplateStageScalarWhereInput
    data: XOR<TemplateStageUpdateManyMutationInput, TemplateStageUncheckedUpdateManyWithoutTemplateInput>
  }

  export type TemplateStageScalarWhereInput = {
    AND?: TemplateStageScalarWhereInput | TemplateStageScalarWhereInput[]
    OR?: TemplateStageScalarWhereInput[]
    NOT?: TemplateStageScalarWhereInput | TemplateStageScalarWhereInput[]
    id?: IntFilter<"TemplateStage"> | number
    name?: StringFilter<"TemplateStage"> | string
    description?: StringNullableFilter<"TemplateStage"> | string | null
    isActive?: BoolFilter<"TemplateStage"> | boolean
    createdAt?: DateTimeFilter<"TemplateStage"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateStage"> | Date | string
    templateId?: IntFilter<"TemplateStage"> | number
  }

  export type OrganisationTemplateUpsertWithWhereUniqueWithoutTemplateInput = {
    where: OrganisationTemplateWhereUniqueInput
    update: XOR<OrganisationTemplateUpdateWithoutTemplateInput, OrganisationTemplateUncheckedUpdateWithoutTemplateInput>
    create: XOR<OrganisationTemplateCreateWithoutTemplateInput, OrganisationTemplateUncheckedCreateWithoutTemplateInput>
  }

  export type OrganisationTemplateUpdateWithWhereUniqueWithoutTemplateInput = {
    where: OrganisationTemplateWhereUniqueInput
    data: XOR<OrganisationTemplateUpdateWithoutTemplateInput, OrganisationTemplateUncheckedUpdateWithoutTemplateInput>
  }

  export type OrganisationTemplateUpdateManyWithWhereWithoutTemplateInput = {
    where: OrganisationTemplateScalarWhereInput
    data: XOR<OrganisationTemplateUpdateManyMutationInput, OrganisationTemplateUncheckedUpdateManyWithoutTemplateInput>
  }

  export type TemplateCreateWithoutTemplateStageInput = {
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationTemplate?: OrganisationTemplateCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUncheckedCreateWithoutTemplateStageInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationTemplate?: OrganisationTemplateUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type TemplateCreateOrConnectWithoutTemplateStageInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutTemplateStageInput, TemplateUncheckedCreateWithoutTemplateStageInput>
  }

  export type TemplateQuestionCreateWithoutTemplateStageInput = {
    question: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: number | null
    TemplateQuestionAnswer?: TemplateQuestionAnswerCreateNestedManyWithoutTemplateQuestionInput
  }

  export type TemplateQuestionUncheckedCreateWithoutTemplateStageInput = {
    id?: number
    question: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: number | null
    TemplateQuestionAnswer?: TemplateQuestionAnswerUncheckedCreateNestedManyWithoutTemplateQuestionInput
  }

  export type TemplateQuestionCreateOrConnectWithoutTemplateStageInput = {
    where: TemplateQuestionWhereUniqueInput
    create: XOR<TemplateQuestionCreateWithoutTemplateStageInput, TemplateQuestionUncheckedCreateWithoutTemplateStageInput>
  }

  export type TemplateQuestionCreateManyTemplateStageInputEnvelope = {
    data: TemplateQuestionCreateManyTemplateStageInput | TemplateQuestionCreateManyTemplateStageInput[]
    skipDuplicates?: boolean
  }

  export type TemplateUpsertWithoutTemplateStageInput = {
    update: XOR<TemplateUpdateWithoutTemplateStageInput, TemplateUncheckedUpdateWithoutTemplateStageInput>
    create: XOR<TemplateCreateWithoutTemplateStageInput, TemplateUncheckedCreateWithoutTemplateStageInput>
    where?: TemplateWhereInput
  }

  export type TemplateUpdateToOneWithWhereWithoutTemplateStageInput = {
    where?: TemplateWhereInput
    data: XOR<TemplateUpdateWithoutTemplateStageInput, TemplateUncheckedUpdateWithoutTemplateStageInput>
  }

  export type TemplateUpdateWithoutTemplateStageInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationTemplate?: OrganisationTemplateUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateUncheckedUpdateWithoutTemplateStageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationTemplate?: OrganisationTemplateUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateQuestionUpsertWithWhereUniqueWithoutTemplateStageInput = {
    where: TemplateQuestionWhereUniqueInput
    update: XOR<TemplateQuestionUpdateWithoutTemplateStageInput, TemplateQuestionUncheckedUpdateWithoutTemplateStageInput>
    create: XOR<TemplateQuestionCreateWithoutTemplateStageInput, TemplateQuestionUncheckedCreateWithoutTemplateStageInput>
  }

  export type TemplateQuestionUpdateWithWhereUniqueWithoutTemplateStageInput = {
    where: TemplateQuestionWhereUniqueInput
    data: XOR<TemplateQuestionUpdateWithoutTemplateStageInput, TemplateQuestionUncheckedUpdateWithoutTemplateStageInput>
  }

  export type TemplateQuestionUpdateManyWithWhereWithoutTemplateStageInput = {
    where: TemplateQuestionScalarWhereInput
    data: XOR<TemplateQuestionUpdateManyMutationInput, TemplateQuestionUncheckedUpdateManyWithoutTemplateStageInput>
  }

  export type TemplateQuestionScalarWhereInput = {
    AND?: TemplateQuestionScalarWhereInput | TemplateQuestionScalarWhereInput[]
    OR?: TemplateQuestionScalarWhereInput[]
    NOT?: TemplateQuestionScalarWhereInput | TemplateQuestionScalarWhereInput[]
    id?: IntFilter<"TemplateQuestion"> | number
    question?: StringFilter<"TemplateQuestion"> | string
    description?: StringNullableFilter<"TemplateQuestion"> | string | null
    isActive?: BoolFilter<"TemplateQuestion"> | boolean
    templateStageId?: IntFilter<"TemplateQuestion"> | number
    createdAt?: DateTimeFilter<"TemplateQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateQuestion"> | Date | string
    templateId?: IntNullableFilter<"TemplateQuestion"> | number | null
  }

  export type TemplateStageCreateWithoutTemplateQuestionInput = {
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Template: TemplateCreateNestedOneWithoutTemplateStageInput
  }

  export type TemplateStageUncheckedCreateWithoutTemplateQuestionInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId: number
  }

  export type TemplateStageCreateOrConnectWithoutTemplateQuestionInput = {
    where: TemplateStageWhereUniqueInput
    create: XOR<TemplateStageCreateWithoutTemplateQuestionInput, TemplateStageUncheckedCreateWithoutTemplateQuestionInput>
  }

  export type TemplateQuestionAnswerCreateWithoutTemplateQuestionInput = {
    answer: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateQuestionAnswerUncheckedCreateWithoutTemplateQuestionInput = {
    id?: number
    answer: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateQuestionAnswerCreateOrConnectWithoutTemplateQuestionInput = {
    where: TemplateQuestionAnswerWhereUniqueInput
    create: XOR<TemplateQuestionAnswerCreateWithoutTemplateQuestionInput, TemplateQuestionAnswerUncheckedCreateWithoutTemplateQuestionInput>
  }

  export type TemplateQuestionAnswerCreateManyTemplateQuestionInputEnvelope = {
    data: TemplateQuestionAnswerCreateManyTemplateQuestionInput | TemplateQuestionAnswerCreateManyTemplateQuestionInput[]
    skipDuplicates?: boolean
  }

  export type TemplateStageUpsertWithoutTemplateQuestionInput = {
    update: XOR<TemplateStageUpdateWithoutTemplateQuestionInput, TemplateStageUncheckedUpdateWithoutTemplateQuestionInput>
    create: XOR<TemplateStageCreateWithoutTemplateQuestionInput, TemplateStageUncheckedCreateWithoutTemplateQuestionInput>
    where?: TemplateStageWhereInput
  }

  export type TemplateStageUpdateToOneWithWhereWithoutTemplateQuestionInput = {
    where?: TemplateStageWhereInput
    data: XOR<TemplateStageUpdateWithoutTemplateQuestionInput, TemplateStageUncheckedUpdateWithoutTemplateQuestionInput>
  }

  export type TemplateStageUpdateWithoutTemplateQuestionInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Template?: TemplateUpdateOneRequiredWithoutTemplateStageNestedInput
  }

  export type TemplateStageUncheckedUpdateWithoutTemplateQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateQuestionAnswerUpsertWithWhereUniqueWithoutTemplateQuestionInput = {
    where: TemplateQuestionAnswerWhereUniqueInput
    update: XOR<TemplateQuestionAnswerUpdateWithoutTemplateQuestionInput, TemplateQuestionAnswerUncheckedUpdateWithoutTemplateQuestionInput>
    create: XOR<TemplateQuestionAnswerCreateWithoutTemplateQuestionInput, TemplateQuestionAnswerUncheckedCreateWithoutTemplateQuestionInput>
  }

  export type TemplateQuestionAnswerUpdateWithWhereUniqueWithoutTemplateQuestionInput = {
    where: TemplateQuestionAnswerWhereUniqueInput
    data: XOR<TemplateQuestionAnswerUpdateWithoutTemplateQuestionInput, TemplateQuestionAnswerUncheckedUpdateWithoutTemplateQuestionInput>
  }

  export type TemplateQuestionAnswerUpdateManyWithWhereWithoutTemplateQuestionInput = {
    where: TemplateQuestionAnswerScalarWhereInput
    data: XOR<TemplateQuestionAnswerUpdateManyMutationInput, TemplateQuestionAnswerUncheckedUpdateManyWithoutTemplateQuestionInput>
  }

  export type TemplateQuestionAnswerScalarWhereInput = {
    AND?: TemplateQuestionAnswerScalarWhereInput | TemplateQuestionAnswerScalarWhereInput[]
    OR?: TemplateQuestionAnswerScalarWhereInput[]
    NOT?: TemplateQuestionAnswerScalarWhereInput | TemplateQuestionAnswerScalarWhereInput[]
    id?: IntFilter<"TemplateQuestionAnswer"> | number
    answer?: StringFilter<"TemplateQuestionAnswer"> | string
    description?: StringNullableFilter<"TemplateQuestionAnswer"> | string | null
    isActive?: BoolFilter<"TemplateQuestionAnswer"> | boolean
    templateQuestionId?: IntFilter<"TemplateQuestionAnswer"> | number
    createdAt?: DateTimeFilter<"TemplateQuestionAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateQuestionAnswer"> | Date | string
  }

  export type TemplateQuestionCreateWithoutTemplateQuestionAnswerInput = {
    question: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: number | null
    TemplateStage: TemplateStageCreateNestedOneWithoutTemplateQuestionInput
  }

  export type TemplateQuestionUncheckedCreateWithoutTemplateQuestionAnswerInput = {
    id?: number
    question: string
    description?: string | null
    isActive?: boolean
    templateStageId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: number | null
  }

  export type TemplateQuestionCreateOrConnectWithoutTemplateQuestionAnswerInput = {
    where: TemplateQuestionWhereUniqueInput
    create: XOR<TemplateQuestionCreateWithoutTemplateQuestionAnswerInput, TemplateQuestionUncheckedCreateWithoutTemplateQuestionAnswerInput>
  }

  export type TemplateQuestionUpsertWithoutTemplateQuestionAnswerInput = {
    update: XOR<TemplateQuestionUpdateWithoutTemplateQuestionAnswerInput, TemplateQuestionUncheckedUpdateWithoutTemplateQuestionAnswerInput>
    create: XOR<TemplateQuestionCreateWithoutTemplateQuestionAnswerInput, TemplateQuestionUncheckedCreateWithoutTemplateQuestionAnswerInput>
    where?: TemplateQuestionWhereInput
  }

  export type TemplateQuestionUpdateToOneWithWhereWithoutTemplateQuestionAnswerInput = {
    where?: TemplateQuestionWhereInput
    data: XOR<TemplateQuestionUpdateWithoutTemplateQuestionAnswerInput, TemplateQuestionUncheckedUpdateWithoutTemplateQuestionAnswerInput>
  }

  export type TemplateQuestionUpdateWithoutTemplateQuestionAnswerInput = {
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    TemplateStage?: TemplateStageUpdateOneRequiredWithoutTemplateQuestionNestedInput
  }

  export type TemplateQuestionUncheckedUpdateWithoutTemplateQuestionAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateStageId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrganisationCreateWithoutOwnerInput = {
    name: string
    description?: string | null
    isActive?: boolean | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Assessment?: AssessmentCreateNestedManyWithoutOrganisationInput
    Team?: TeamCreateNestedManyWithoutOrganisationInput
    OrganisationTemplate?: OrganisationTemplateCreateNestedManyWithoutOrganisationInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutOrganisationInput
    AssessmentTeam?: AssessmentTeamCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateWithoutOwnerInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Assessment?: AssessmentUncheckedCreateNestedManyWithoutOrganisationInput
    Team?: TeamUncheckedCreateNestedManyWithoutOrganisationInput
    OrganisationTemplate?: OrganisationTemplateUncheckedCreateNestedManyWithoutOrganisationInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutOrganisationInput
    AssessmentTeam?: AssessmentTeamUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationCreateOrConnectWithoutOwnerInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutOwnerInput, OrganisationUncheckedCreateWithoutOwnerInput>
  }

  export type UserRoleCreateWithoutUserInput = {
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Role: RoleCreateNestedOneWithoutUserRoleInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: number
    roleId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationStructureCreateWithoutUserInput = {
    organisationId: number
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Team?: TeamCreateNestedOneWithoutOrganisationStructureInput
    OrganisationRole?: OrganisationRoleCreateNestedManyWithoutOrganisationStructureInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutOrganisationStructureInput
  }

  export type OrganisationStructureUncheckedCreateWithoutUserInput = {
    id?: number
    organisationId: number
    teamId?: number | null
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationRole?: OrganisationRoleUncheckedCreateNestedManyWithoutOrganisationStructureInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutOrganisationStructureInput
  }

  export type OrganisationStructureCreateOrConnectWithoutUserInput = {
    where: OrganisationStructureWhereUniqueInput
    create: XOR<OrganisationStructureCreateWithoutUserInput, OrganisationStructureUncheckedCreateWithoutUserInput>
  }

  export type OrganisationStructureCreateManyUserInputEnvelope = {
    data: OrganisationStructureCreateManyUserInput | OrganisationStructureCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuestionAnswerCreateWithoutUserInput = {
    assessmentStage: string
    questionMongoId: string
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation?: OrganisationCreateNestedOneWithoutQuestionAnswerInput
    OrganisationStructure?: OrganisationStructureCreateNestedOneWithoutQuestionAnswerInput
    Team?: TeamCreateNestedOneWithoutQuestionAnswerInput
    AssessmentTeam?: AssessmentTeamCreateNestedOneWithoutQuestionAnswerInput
    Assessment?: AssessmentCreateNestedOneWithoutQuestionAnswerInput
    AssessmentQuestion?: AssessmentQuestionCreateNestedOneWithoutQuestionAnswerInput
  }

  export type QuestionAnswerUncheckedCreateWithoutUserInput = {
    id?: number
    organisationId?: number | null
    organisationStructureId?: number | null
    teamId?: number | null
    assessmentTeamId?: number | null
    assessmentId?: number | null
    assessmentStage: string
    questionMongoId: string
    assessmentQuestionId?: number | null
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerCreateOrConnectWithoutUserInput = {
    where: QuestionAnswerWhereUniqueInput
    create: XOR<QuestionAnswerCreateWithoutUserInput, QuestionAnswerUncheckedCreateWithoutUserInput>
  }

  export type QuestionAnswerCreateManyUserInputEnvelope = {
    data: QuestionAnswerCreateManyUserInput | QuestionAnswerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationUpsertWithoutOwnerInput = {
    update: XOR<OrganisationUpdateWithoutOwnerInput, OrganisationUncheckedUpdateWithoutOwnerInput>
    create: XOR<OrganisationCreateWithoutOwnerInput, OrganisationUncheckedCreateWithoutOwnerInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutOwnerInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutOwnerInput, OrganisationUncheckedUpdateWithoutOwnerInput>
  }

  export type OrganisationUpdateWithoutOwnerInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Assessment?: AssessmentUpdateManyWithoutOrganisationNestedInput
    Team?: TeamUpdateManyWithoutOrganisationNestedInput
    OrganisationTemplate?: OrganisationTemplateUpdateManyWithoutOrganisationNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutOrganisationNestedInput
    AssessmentTeam?: AssessmentTeamUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Assessment?: AssessmentUncheckedUpdateManyWithoutOrganisationNestedInput
    Team?: TeamUncheckedUpdateManyWithoutOrganisationNestedInput
    OrganisationTemplate?: OrganisationTemplateUncheckedUpdateManyWithoutOrganisationNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutOrganisationNestedInput
    AssessmentTeam?: AssessmentTeamUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type OrganisationStructureUpsertWithWhereUniqueWithoutUserInput = {
    where: OrganisationStructureWhereUniqueInput
    update: XOR<OrganisationStructureUpdateWithoutUserInput, OrganisationStructureUncheckedUpdateWithoutUserInput>
    create: XOR<OrganisationStructureCreateWithoutUserInput, OrganisationStructureUncheckedCreateWithoutUserInput>
  }

  export type OrganisationStructureUpdateWithWhereUniqueWithoutUserInput = {
    where: OrganisationStructureWhereUniqueInput
    data: XOR<OrganisationStructureUpdateWithoutUserInput, OrganisationStructureUncheckedUpdateWithoutUserInput>
  }

  export type OrganisationStructureUpdateManyWithWhereWithoutUserInput = {
    where: OrganisationStructureScalarWhereInput
    data: XOR<OrganisationStructureUpdateManyMutationInput, OrganisationStructureUncheckedUpdateManyWithoutUserInput>
  }

  export type QuestionAnswerUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionAnswerWhereUniqueInput
    update: XOR<QuestionAnswerUpdateWithoutUserInput, QuestionAnswerUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionAnswerCreateWithoutUserInput, QuestionAnswerUncheckedCreateWithoutUserInput>
  }

  export type QuestionAnswerUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionAnswerWhereUniqueInput
    data: XOR<QuestionAnswerUpdateWithoutUserInput, QuestionAnswerUncheckedUpdateWithoutUserInput>
  }

  export type QuestionAnswerUpdateManyWithWhereWithoutUserInput = {
    where: QuestionAnswerScalarWhereInput
    data: XOR<QuestionAnswerUpdateManyMutationInput, QuestionAnswerUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutUserRoleInput = {
    name: string
    firstName?: string | null
    lastName?: string | null
    email: string
    company?: string | null
    password: string
    rememberToken?: string | null
    logo?: string | null
    isActive?: boolean
    disabled?: boolean
    tfaSecret?: string | null
    fpwToken?: string | null
    qrCodeVisibility?: boolean
    isDureation?: boolean
    tfaStatus?: boolean
    emailVerifiedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation?: OrganisationCreateNestedOneWithoutOwnerInput
    OrganisationStructure?: OrganisationStructureCreateNestedManyWithoutUserInput
    QuestionAnswer?: QuestionAnswerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserRoleInput = {
    id?: number
    name: string
    firstName?: string | null
    lastName?: string | null
    email: string
    company?: string | null
    password: string
    rememberToken?: string | null
    logo?: string | null
    isActive?: boolean
    disabled?: boolean
    tfaSecret?: string | null
    fpwToken?: string | null
    qrCodeVisibility?: boolean
    isDureation?: boolean
    tfaStatus?: boolean
    emailVerifiedAt?: Date | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    deletedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Organisation?: OrganisationUncheckedCreateNestedOneWithoutOwnerInput
    OrganisationStructure?: OrganisationStructureUncheckedCreateNestedManyWithoutUserInput
    QuestionAnswer?: QuestionAnswerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRoleInput, UserUncheckedCreateWithoutUserRoleInput>
  }

  export type RoleCreateWithoutUserRoleInput = {
    name: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationRole?: OrganisationRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUserRoleInput = {
    id?: number
    name: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    OrganisationRole?: OrganisationRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUserRoleInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserRoleInput, RoleUncheckedCreateWithoutUserRoleInput>
  }

  export type UserUpsertWithoutUserRoleInput = {
    update: XOR<UserUpdateWithoutUserRoleInput, UserUncheckedUpdateWithoutUserRoleInput>
    create: XOR<UserCreateWithoutUserRoleInput, UserUncheckedCreateWithoutUserRoleInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRoleInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRoleInput, UserUncheckedUpdateWithoutUserRoleInput>
  }

  export type UserUpdateWithoutUserRoleInput = {
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    tfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fpwToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeVisibility?: BoolFieldUpdateOperationsInput | boolean
    isDureation?: BoolFieldUpdateOperationsInput | boolean
    tfaStatus?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneWithoutOwnerNestedInput
    OrganisationStructure?: OrganisationStructureUpdateManyWithoutUserNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    disabled?: BoolFieldUpdateOperationsInput | boolean
    tfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    fpwToken?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeVisibility?: BoolFieldUpdateOperationsInput | boolean
    isDureation?: BoolFieldUpdateOperationsInput | boolean
    tfaStatus?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUncheckedUpdateOneWithoutOwnerNestedInput
    OrganisationStructure?: OrganisationStructureUncheckedUpdateManyWithoutUserNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleUpsertWithoutUserRoleInput = {
    update: XOR<RoleUpdateWithoutUserRoleInput, RoleUncheckedUpdateWithoutUserRoleInput>
    create: XOR<RoleCreateWithoutUserRoleInput, RoleUncheckedCreateWithoutUserRoleInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserRoleInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserRoleInput, RoleUncheckedUpdateWithoutUserRoleInput>
  }

  export type RoleUpdateWithoutUserRoleInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationRole?: OrganisationRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUserRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationRole?: OrganisationRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type AssessmentQuestionCreateManyAssessmentInput = {
    id?: number
    assessmentStage: string
    questionMongoId: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentTeamCreateManyAssessmentInput = {
    id?: number
    organisationId: number
    teamId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerCreateManyAssessmentInput = {
    id?: number
    organisationId?: number | null
    organisationStructureId?: number | null
    teamId?: number | null
    userId?: number | null
    assessmentTeamId?: number | null
    assessmentStage: string
    questionMongoId: string
    assessmentQuestionId?: number | null
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentQuestionUpdateWithoutAssessmentInput = {
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutAssessmentQuestionNestedInput
  }

  export type AssessmentQuestionUncheckedUpdateWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutAssessmentQuestionNestedInput
  }

  export type AssessmentQuestionUncheckedUpdateManyWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentTeamUpdateWithoutAssessmentInput = {
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneRequiredWithoutAssessmentTeamNestedInput
    Team?: TeamUpdateOneRequiredWithoutAssessmentTeamNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutAssessmentTeamNestedInput
  }

  export type AssessmentTeamUncheckedUpdateWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutAssessmentTeamNestedInput
  }

  export type AssessmentTeamUncheckedUpdateManyWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerUpdateWithoutAssessmentInput = {
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneWithoutQuestionAnswerNestedInput
    OrganisationStructure?: OrganisationStructureUpdateOneWithoutQuestionAnswerNestedInput
    Team?: TeamUpdateOneWithoutQuestionAnswerNestedInput
    User?: UserUpdateOneWithoutQuestionAnswerNestedInput
    AssessmentTeam?: AssessmentTeamUpdateOneWithoutQuestionAnswerNestedInput
    AssessmentQuestion?: AssessmentQuestionUpdateOneWithoutQuestionAnswerNestedInput
  }

  export type QuestionAnswerUncheckedUpdateWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationStructureId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    assessmentQuestionId?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationStructureId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    assessmentQuestionId?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerCreateManyAssessmentQuestionInput = {
    id?: number
    organisationId?: number | null
    organisationStructureId?: number | null
    teamId?: number | null
    userId?: number | null
    assessmentTeamId?: number | null
    assessmentId?: number | null
    assessmentStage: string
    questionMongoId: string
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerUpdateWithoutAssessmentQuestionInput = {
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneWithoutQuestionAnswerNestedInput
    OrganisationStructure?: OrganisationStructureUpdateOneWithoutQuestionAnswerNestedInput
    Team?: TeamUpdateOneWithoutQuestionAnswerNestedInput
    User?: UserUpdateOneWithoutQuestionAnswerNestedInput
    AssessmentTeam?: AssessmentTeamUpdateOneWithoutQuestionAnswerNestedInput
    Assessment?: AssessmentUpdateOneWithoutQuestionAnswerNestedInput
  }

  export type QuestionAnswerUncheckedUpdateWithoutAssessmentQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationStructureId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutAssessmentQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationStructureId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerCreateManyAssessmentTeamInput = {
    id?: number
    organisationId?: number | null
    organisationStructureId?: number | null
    teamId?: number | null
    userId?: number | null
    assessmentId?: number | null
    assessmentStage: string
    questionMongoId: string
    assessmentQuestionId?: number | null
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerUpdateWithoutAssessmentTeamInput = {
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneWithoutQuestionAnswerNestedInput
    OrganisationStructure?: OrganisationStructureUpdateOneWithoutQuestionAnswerNestedInput
    Team?: TeamUpdateOneWithoutQuestionAnswerNestedInput
    User?: UserUpdateOneWithoutQuestionAnswerNestedInput
    Assessment?: AssessmentUpdateOneWithoutQuestionAnswerNestedInput
    AssessmentQuestion?: AssessmentQuestionUpdateOneWithoutQuestionAnswerNestedInput
  }

  export type QuestionAnswerUncheckedUpdateWithoutAssessmentTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationStructureId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    assessmentQuestionId?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutAssessmentTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationStructureId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    assessmentQuestionId?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentCreateManyOrganisationInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organisationTemplateId?: number | null
  }

  export type TeamCreateManyOrganisationInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganisationTemplateCreateManyOrganisationInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId: number
  }

  export type QuestionAnswerCreateManyOrganisationInput = {
    id?: number
    organisationStructureId?: number | null
    teamId?: number | null
    userId?: number | null
    assessmentTeamId?: number | null
    assessmentId?: number | null
    assessmentStage: string
    questionMongoId: string
    assessmentQuestionId?: number | null
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentTeamCreateManyOrganisationInput = {
    id?: number
    assessmentId: number
    teamId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentUpdateWithoutOrganisationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AssessmentQuestion?: AssessmentQuestionUpdateManyWithoutAssessmentNestedInput
    OrganisationTemplate?: OrganisationTemplateUpdateOneWithoutAssessmentNestedInput
    AssessmentTeam?: AssessmentTeamUpdateManyWithoutAssessmentNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organisationTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
    AssessmentQuestion?: AssessmentQuestionUncheckedUpdateManyWithoutAssessmentNestedInput
    AssessmentTeam?: AssessmentTeamUncheckedUpdateManyWithoutAssessmentNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateManyWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organisationTemplateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TeamUpdateWithoutOrganisationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationStructure?: OrganisationStructureUpdateManyWithoutTeamNestedInput
    AssessmentTeam?: AssessmentTeamUpdateManyWithoutTeamNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationStructure?: OrganisationStructureUncheckedUpdateManyWithoutTeamNestedInput
    AssessmentTeam?: AssessmentTeamUncheckedUpdateManyWithoutTeamNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationTemplateUpdateWithoutOrganisationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Template?: TemplateUpdateOneWithoutOrganisationTemplateNestedInput
    Assessment?: AssessmentUpdateManyWithoutOrganisationTemplateNestedInput
  }

  export type OrganisationTemplateUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
    Assessment?: AssessmentUncheckedUpdateManyWithoutOrganisationTemplateNestedInput
  }

  export type OrganisationTemplateUncheckedUpdateManyWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionAnswerUpdateWithoutOrganisationInput = {
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationStructure?: OrganisationStructureUpdateOneWithoutQuestionAnswerNestedInput
    Team?: TeamUpdateOneWithoutQuestionAnswerNestedInput
    User?: UserUpdateOneWithoutQuestionAnswerNestedInput
    AssessmentTeam?: AssessmentTeamUpdateOneWithoutQuestionAnswerNestedInput
    Assessment?: AssessmentUpdateOneWithoutQuestionAnswerNestedInput
    AssessmentQuestion?: AssessmentQuestionUpdateOneWithoutQuestionAnswerNestedInput
  }

  export type QuestionAnswerUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationStructureId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    assessmentQuestionId?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationStructureId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    assessmentQuestionId?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentTeamUpdateWithoutOrganisationInput = {
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Assessment?: AssessmentUpdateOneRequiredWithoutAssessmentTeamNestedInput
    Team?: TeamUpdateOneRequiredWithoutAssessmentTeamNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutAssessmentTeamNestedInput
  }

  export type AssessmentTeamUncheckedUpdateWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutAssessmentTeamNestedInput
  }

  export type AssessmentTeamUncheckedUpdateManyWithoutOrganisationInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationRoleCreateManyOrganisationStructureInput = {
    id?: number
    isActive?: boolean | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerCreateManyOrganisationStructureInput = {
    id?: number
    organisationId?: number | null
    teamId?: number | null
    userId?: number | null
    assessmentTeamId?: number | null
    assessmentId?: number | null
    assessmentStage: string
    questionMongoId: string
    assessmentQuestionId?: number | null
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganisationRoleUpdateWithoutOrganisationStructureInput = {
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateOneRequiredWithoutOrganisationRoleNestedInput
  }

  export type OrganisationRoleUncheckedUpdateWithoutOrganisationStructureInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationRoleUncheckedUpdateManyWithoutOrganisationStructureInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerUpdateWithoutOrganisationStructureInput = {
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneWithoutQuestionAnswerNestedInput
    Team?: TeamUpdateOneWithoutQuestionAnswerNestedInput
    User?: UserUpdateOneWithoutQuestionAnswerNestedInput
    AssessmentTeam?: AssessmentTeamUpdateOneWithoutQuestionAnswerNestedInput
    Assessment?: AssessmentUpdateOneWithoutQuestionAnswerNestedInput
    AssessmentQuestion?: AssessmentQuestionUpdateOneWithoutQuestionAnswerNestedInput
  }

  export type QuestionAnswerUncheckedUpdateWithoutOrganisationStructureInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    assessmentQuestionId?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutOrganisationStructureInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    assessmentQuestionId?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentCreateManyOrganisationTemplateInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentUpdateWithoutOrganisationTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneRequiredWithoutAssessmentNestedInput
    AssessmentQuestion?: AssessmentQuestionUpdateManyWithoutAssessmentNestedInput
    AssessmentTeam?: AssessmentTeamUpdateManyWithoutAssessmentNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateWithoutOrganisationTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AssessmentQuestion?: AssessmentQuestionUncheckedUpdateManyWithoutAssessmentNestedInput
    AssessmentTeam?: AssessmentTeamUncheckedUpdateManyWithoutAssessmentNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutAssessmentNestedInput
  }

  export type AssessmentUncheckedUpdateManyWithoutOrganisationTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyRoleInput = {
    id?: number
    userId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganisationRoleCreateManyRoleInput = {
    id?: number
    isActive?: boolean | null
    organisationStructureId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutUserRoleNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationRoleUpdateWithoutRoleInput = {
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationStructure?: OrganisationStructureUpdateOneRequiredWithoutOrganisationRoleNestedInput
  }

  export type OrganisationRoleUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organisationStructureId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organisationStructureId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationStructureCreateManyTeamInput = {
    id?: number
    organisationId: number
    userId: number
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentTeamCreateManyTeamInput = {
    id?: number
    assessmentId: number
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerCreateManyTeamInput = {
    id?: number
    organisationId?: number | null
    organisationStructureId?: number | null
    userId?: number | null
    assessmentTeamId?: number | null
    assessmentId?: number | null
    assessmentStage: string
    questionMongoId: string
    assessmentQuestionId?: number | null
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganisationStructureUpdateWithoutTeamInput = {
    organisationId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationRole?: OrganisationRoleUpdateManyWithoutOrganisationStructureNestedInput
    User?: UserUpdateOneRequiredWithoutOrganisationStructureNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutOrganisationStructureNestedInput
  }

  export type OrganisationStructureUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationRole?: OrganisationRoleUncheckedUpdateManyWithoutOrganisationStructureNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutOrganisationStructureNestedInput
  }

  export type OrganisationStructureUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentTeamUpdateWithoutTeamInput = {
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Assessment?: AssessmentUpdateOneRequiredWithoutAssessmentTeamNestedInput
    Organisation?: OrganisationUpdateOneRequiredWithoutAssessmentTeamNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutAssessmentTeamNestedInput
  }

  export type AssessmentTeamUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutAssessmentTeamNestedInput
  }

  export type AssessmentTeamUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    assessmentId?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerUpdateWithoutTeamInput = {
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneWithoutQuestionAnswerNestedInput
    OrganisationStructure?: OrganisationStructureUpdateOneWithoutQuestionAnswerNestedInput
    User?: UserUpdateOneWithoutQuestionAnswerNestedInput
    AssessmentTeam?: AssessmentTeamUpdateOneWithoutQuestionAnswerNestedInput
    Assessment?: AssessmentUpdateOneWithoutQuestionAnswerNestedInput
    AssessmentQuestion?: AssessmentQuestionUpdateOneWithoutQuestionAnswerNestedInput
  }

  export type QuestionAnswerUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationStructureId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    assessmentQuestionId?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationStructureId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    assessmentQuestionId?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateStageCreateManyTemplateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganisationTemplateCreateManyTemplateInput = {
    id?: number
    name: string
    description?: string | null
    logo?: string | null
    organisationId: number
    password?: string | null
    rememberToken?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateStageUpdateWithoutTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TemplateQuestion?: TemplateQuestionUpdateManyWithoutTemplateStageNestedInput
  }

  export type TemplateStageUncheckedUpdateWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TemplateQuestion?: TemplateQuestionUncheckedUpdateManyWithoutTemplateStageNestedInput
  }

  export type TemplateStageUncheckedUpdateManyWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationTemplateUpdateWithoutTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneRequiredWithoutOrganisationTemplateNestedInput
    Assessment?: AssessmentUpdateManyWithoutOrganisationTemplateNestedInput
  }

  export type OrganisationTemplateUncheckedUpdateWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Assessment?: AssessmentUncheckedUpdateManyWithoutOrganisationTemplateNestedInput
  }

  export type OrganisationTemplateUncheckedUpdateManyWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateQuestionCreateManyTemplateStageInput = {
    id?: number
    question: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    templateId?: number | null
  }

  export type TemplateQuestionUpdateWithoutTemplateStageInput = {
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    TemplateQuestionAnswer?: TemplateQuestionAnswerUpdateManyWithoutTemplateQuestionNestedInput
  }

  export type TemplateQuestionUncheckedUpdateWithoutTemplateStageInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    TemplateQuestionAnswer?: TemplateQuestionAnswerUncheckedUpdateManyWithoutTemplateQuestionNestedInput
  }

  export type TemplateQuestionUncheckedUpdateManyWithoutTemplateStageInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TemplateQuestionAnswerCreateManyTemplateQuestionInput = {
    id?: number
    answer: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateQuestionAnswerUpdateWithoutTemplateQuestionInput = {
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateQuestionAnswerUncheckedUpdateWithoutTemplateQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateQuestionAnswerUncheckedUpdateManyWithoutTemplateQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyUserInput = {
    id?: number
    roleId: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganisationStructureCreateManyUserInput = {
    id?: number
    organisationId: number
    teamId?: number | null
    isActive?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionAnswerCreateManyUserInput = {
    id?: number
    organisationId?: number | null
    organisationStructureId?: number | null
    teamId?: number | null
    assessmentTeamId?: number | null
    assessmentId?: number | null
    assessmentStage: string
    questionMongoId: string
    assessmentQuestionId?: number | null
    password?: string | null
    rememberToken?: string | null
    notes?: string | null
    isActive?: boolean
    secretToken?: string | null
    tfaToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateOneRequiredWithoutUserRoleNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganisationStructureUpdateWithoutUserInput = {
    organisationId?: IntFieldUpdateOperationsInput | number
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Team?: TeamUpdateOneWithoutOrganisationStructureNestedInput
    OrganisationRole?: OrganisationRoleUpdateManyWithoutOrganisationStructureNestedInput
    QuestionAnswer?: QuestionAnswerUpdateManyWithoutOrganisationStructureNestedInput
  }

  export type OrganisationStructureUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OrganisationRole?: OrganisationRoleUncheckedUpdateManyWithoutOrganisationStructureNestedInput
    QuestionAnswer?: QuestionAnswerUncheckedUpdateManyWithoutOrganisationStructureNestedInput
  }

  export type OrganisationStructureUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: IntFieldUpdateOperationsInput | number
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerUpdateWithoutUserInput = {
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Organisation?: OrganisationUpdateOneWithoutQuestionAnswerNestedInput
    OrganisationStructure?: OrganisationStructureUpdateOneWithoutQuestionAnswerNestedInput
    Team?: TeamUpdateOneWithoutQuestionAnswerNestedInput
    AssessmentTeam?: AssessmentTeamUpdateOneWithoutQuestionAnswerNestedInput
    Assessment?: AssessmentUpdateOneWithoutQuestionAnswerNestedInput
    AssessmentQuestion?: AssessmentQuestionUpdateOneWithoutQuestionAnswerNestedInput
  }

  export type QuestionAnswerUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationStructureId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    assessmentQuestionId?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAnswerUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    organisationId?: NullableIntFieldUpdateOperationsInput | number | null
    organisationStructureId?: NullableIntFieldUpdateOperationsInput | number | null
    teamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentTeamId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentId?: NullableIntFieldUpdateOperationsInput | number | null
    assessmentStage?: StringFieldUpdateOperationsInput | string
    questionMongoId?: StringFieldUpdateOperationsInput | string
    assessmentQuestionId?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    secretToken?: NullableStringFieldUpdateOperationsInput | string | null
    tfaToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AssessmentCountOutputTypeDefaultArgs instead
     */
    export type AssessmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssessmentQuestionCountOutputTypeDefaultArgs instead
     */
    export type AssessmentQuestionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentQuestionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssessmentTeamCountOutputTypeDefaultArgs instead
     */
    export type AssessmentTeamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentTeamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganisationCountOutputTypeDefaultArgs instead
     */
    export type OrganisationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganisationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganisationStructureCountOutputTypeDefaultArgs instead
     */
    export type OrganisationStructureCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganisationStructureCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganisationTemplateCountOutputTypeDefaultArgs instead
     */
    export type OrganisationTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganisationTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamCountOutputTypeDefaultArgs instead
     */
    export type TeamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateCountOutputTypeDefaultArgs instead
     */
    export type TemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateStageCountOutputTypeDefaultArgs instead
     */
    export type TemplateStageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateStageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateQuestionCountOutputTypeDefaultArgs instead
     */
    export type TemplateQuestionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateQuestionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssessmentDefaultArgs instead
     */
    export type AssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssessmentQuestionDefaultArgs instead
     */
    export type AssessmentQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssessmentTeamDefaultArgs instead
     */
    export type AssessmentTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentTeamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganisationDefaultArgs instead
     */
    export type OrganisationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganisationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganisationRoleDefaultArgs instead
     */
    export type OrganisationRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganisationRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganisationStructureDefaultArgs instead
     */
    export type OrganisationStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganisationStructureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganisationTemplateDefaultArgs instead
     */
    export type OrganisationTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganisationTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionAnswerDefaultArgs instead
     */
    export type QuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionAnswerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamDefaultArgs instead
     */
    export type TeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateDefaultArgs instead
     */
    export type TemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateStageDefaultArgs instead
     */
    export type TemplateStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateStageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateQuestionDefaultArgs instead
     */
    export type TemplateQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateQuestionAnswerDefaultArgs instead
     */
    export type TemplateQuestionAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateQuestionAnswerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleDefaultArgs instead
     */
    export type UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}